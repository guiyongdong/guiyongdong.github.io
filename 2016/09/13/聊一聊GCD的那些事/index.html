
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="贵大头的博客">
    <title>聊一聊GCD的那些事 - 贵大头的博客</title>
    <meta name="author" content="贵永冬">
<link rel="icon" href="https://github.com/guiyongdong/Resource/blob/master/hexoImage/favicon.ico?raw=true">
    
    
        <link rel="icon" href="https://github.com/guiyongdong/Resource/blob/master/hexoImage/favicon.ico?raw=true">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。">
<meta property="og:type" content="blog">
<meta property="og:title" content="聊一聊GCD的那些事">
<meta property="og:url" content="http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/index.html">
<meta property="og:site_name" content="贵大头的博客">
<meta property="og:description" content="GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。">
<meta property="og:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/GCD1.png?raw=true">
<meta property="og:updated_time" content="2017-03-09T07:02:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="聊一聊GCD的那些事">
<meta name="twitter:description" content="GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。">
<meta name="twitter:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/GCD1.png?raw=true">
    
    
        
    
    
        <meta property="og:image" content="http://www.guiyongdong.com/assets/images/header.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-yrst5vo1nxaxbp2g3v9na2wg1lixlpr3ghbjdvskeixmu79deycecx3rh4bt.min.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">贵大头的博客</a>
    </div>
    
        
            <a  class="header-right-icon "
                href="#about">
        
        
            <i class="fa fa-lg fa-header.jpg"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/header.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">贵永冬</h4>
                
                    <h5 class="sidebar-profile-bio"><p>iOS开发者<br> 会一点RN和android,  十足的海贼迷</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/guiyongdong" target="_blank">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:564024928@qq.com" target="_blank">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">订阅</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            聊一聊GCD的那些事
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" datetime="2016-09-13T16:56:07+08:00">
	
		    9月 13, 2016
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <p>GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。</p>
<a id="more"></a>
<p><strong>目录</strong></p>
<blockquote>
<ol>
<li>文字描述</li>
<li>Dispatch Queue</li>
<li>dispatch_sync&amp;dispatch_async</li>
<li>创建的线程任务有四种执行方式</li>
<li>Dispatch Group</li>
<li>Dispatch Block</li>
<li>dispatch_after</li>
<li>dispatch_apply</li>
<li>dispatch_once</li>
<li>dispatch_barrier_async</li>
<li>dispatch_set_target_queue</li>
<li>dispatch_semaphore_t(信号量)</li>
<li>GCD定时器</li>
</ol>
</blockquote>
<h3 id="1-文字描述"><a href="#1-文字描述" class="headerlink" title="1. 文字描述"></a>1. 文字描述</h3><blockquote>
<p>GCD英文全称：Grand Central Dispatch 翻译就是 宏大的中央调度，是苹果开发的一种支持并行操作的机制,基于C语言，提供了非常多强大的函数</p>
</blockquote>
<p>在了解GCD并使用之前，必须要掌握四个名词：<strong>串行</strong>，<strong>并发</strong>，<strong>同步</strong>，<strong>异步</strong></p>
<p><strong>串行(Serial)：</strong><br>一个任务执行完, 再执行下一个任务</p>
<p><strong>并发 (Concurrent)：</strong><br>多个任务同时执行(自动开启多个线程),只有在异步函数下才有效</p>
<p><strong>同步(Synchronous)：</strong><br>在当前线程中执行任务，不具备开启新线程的能力<br>提交的任务在执行完成后才会返回<br>同步函数: dispatch_sync()</p>
<p><strong>异步 (Asynchronous)：</strong><br>在新的线程中执行任务, 具备开启线程的能力<br>在新线程中执行任务，具备开启新线程的能力<br>提交的任务立刻返回，在后台队列中执行<br>异步函数: dispatch_async()</p>
<hr>
<h3 id="2-Dispatch-Queue"><a href="#2-Dispatch-Queue" class="headerlink" title="2.Dispatch Queue"></a>2.Dispatch Queue</h3><p>Dispatch Queue是执行处理的等待队列, 按照先进先出(FIFO, First-In-First-Out)的顺序进行任务处理.<br>开发者将需要执行的任务添加到合适的Dispatch Queue中即可，Dispatch Queue会根据任务添加的顺序先到先执行，其中有以下几种队列：</p>
<p>另外, 队列分两种, 一种是<strong>串行队列(Serial Dispatch Queue)</strong>, 一种是<strong>并行队列(Concurrent Dispatch Queue)</strong>.</p>
<table>
<thead>
<tr>
<th>Dispatch Queue的种类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial Dispatch Queue</td>
<td style="text-align:center">等待现在执行中处理结束</td>
</tr>
<tr>
<td>Concurrent Dispatch Queue</td>
<td style="text-align:center">不等待现在执行中处理结束</td>
</tr>
</tbody>
</table>
<pre><code>
//创建一个串行队列
dispatch_queue_t serialQueue=dispatch_queue_create("com.serial.queue", DISPATCH_QUEUE_SERIAL);

//创建一个并发队列
dispatch_queue_t concurrentQueue=dispatch_queue_create("com.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);

//第一个参数为队列名，第二个参数为队列类型，当然，第二个参数人如果写NULL，创建出来的也是一个串行队列。然后我们在异步线程来执行这个队列：
</code></pre>

<p>另外系统为我们准备了两个队列</p>
<ul>
<li><p><strong>main dispatch queue</strong><br>功能跟主线程一样，通过dispatch_get_main_queue()来获取，提交到main queue的任务实际上都是在主线程执行的，所以这是一个串行队列<br><code>dispatch_queue_t queue = dispatch_get_main_queue();</code></p>
</li>
<li><p><strong>global dispatch queues</strong><br>系统给每个应用提供四个全局的并发队列，这四个队列分别有不同的优先级：高、默认、低以及后台，用户不能去创建全局队列，只能根据优先级去获取:</p>
<pre><code>dispatch_queue_t queue  = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</code></pre>    



</li>
</ul>
<hr>
<h3 id="3-dispatch-sync-amp-dispatch-async"><a href="#3-dispatch-sync-amp-dispatch-async" class="headerlink" title="3.dispatch_sync&amp;dispatch_async"></a>3.dispatch_sync&amp;dispatch_async</h3><p>执行队列中任务的两种方式，dispatch_sync是同步任务，dispatch_async是异步任务</p>
<p>1.<strong>用同步的方式执行任务(同步：synchronization)</strong>， 只能在当前线程中执行任务，不具备开启新线程的能力</p>
<pre><code>/*
 *  第一个参数：该任务所在的队列
 *  第二个参数：该任务要做的事情
 */
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code></pre>

<ul>
<li><p>假如我指定的队列A是串行队列，则该队列中只能有一个线程，也就是说我放在队列A中的任务，所以必须得一个一个的执行。不仅如此，在上面我们还手动选择了在队列A中用同步的方式执行任务，这也限制了，队列中的任务只能一个一个执行。</p>
</li>
<li><p>假如我指定的队列A是并行队列，则该队列中可以开辟多个线程去执行任务，虽然如此，但由于我们在上面手动选择了在队列A中用同步的方式执行线程，所以队列A中的任务也只能一个一个去执行，<strong>不能开辟多线程同时执行</strong>。</p>
</li>
</ul>
<p>2.用异步的方式执行任务(异步：asynchronous)，可以在新的线程中执行任务，具备开启新线程的能力。</p>
<pre><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code></pre>

<ul>
<li>假如此时我指定的队列B是并行队列，则表明该队列中可以存在多个线程，又因为我们采用的是异步的方式执行任务，所以在这个队列的任务可以实现同时运行。</li>
<li>假如此时我指定的队列B是串行队列，则表明该队列中，只能有一个线程，所以尽管我采用异步的方式执行任务，但该队列中的任务还是只能一个一个的运行。</li>
</ul>
<hr>
<h3 id="4-创建的线程任务有四种执行方式"><a href="#4-创建的线程任务有四种执行方式" class="headerlink" title="4.创建的线程任务有四种执行方式"></a>4.创建的线程任务有四种执行方式</h3><p><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/GCD1.png?raw=true" alt=""></p>
<h5 id="1-串行队列同步执行任务"><a href="#1-串行队列同步执行任务" class="headerlink" title="1. 串行队列同步执行任务"></a>1. 串行队列同步执行任务</h5><ul>
<li>同步不具有开辟新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程中执行任务。</li>
<li>按照串行的方式去执行任务</li>
</ul>
<pre><code>-(void)syncSERIAL{
    NSLog(@"star");
    //不会开辟新的线程
    dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_sync(queue, ^{
        NSLog(@"SERIAL_work_1 ");
    });
    dispatch_sync(queue, ^{
        NSLog(@"SERIAL_work_2 ");
    });
    dispatch_sync(queue, ^{
        NSLog(@"SERIAL_work_3 ");
    });

    NSLog(@"end");

}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:08:09.695 GCD_Demo[8196:1029563] star
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] SERIAL_work_1 
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] SERIAL_work_2 
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] SERIAL_work_3 
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] end</code></pre>

<p><strong>由于是同步操作，不能开辟线程，所以都是在主线程并按照顺序执行</strong></p>
<h5 id="2-串行队列异步执行任务"><a href="#2-串行队列异步执行任务" class="headerlink" title="2. 串行队列异步执行任务"></a>2. 串行队列异步执行任务</h5><ul>
<li>异步具有创建新线程的能力，会开辟新的线程去执行任务</li>
<li>按照串行的方式去执行任务</li>
</ul>
<pre><code>-(void)asyncSERIAL{
    NSLog(@"star");

    //会开辟新的线程,但是是串行执行任务
    dispatch_queue_t queue=dispatch_queue_create("ki", DISPATCH_QUEUE_SERIAL);
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:3];
        NSLog(@"SERIAL_work_1 ");
    });
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"SERIAL_work_2 ");
    });
    dispatch_async(queue, ^{
        NSLog(@"SERIAL_work_3 ");
    });

    NSLog(@"end");

}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:09:58.494 GCD_Demo[8213:1031268] star
2016-07-20 20:09:58.495 GCD_Demo[8213:1031268] end
2016-07-20 20:10:01.496 GCD_Demo[8213:1031315] SERIAL_work_1 
2016-07-20 20:10:03.502 GCD_Demo[8213:1031315] SERIAL_work_2 
2016-07-20 20:10:03.502 GCD_Demo[8213:1031315] SERIAL_work_3</code></pre>

<p><strong>因为是异步操作，所以有个编号为2的子线程被开辟，但有因为是串行队列，所以只开辟了一个线程。最终造就了三个任务顺序执行。</strong></p>
<h5 id="3-并行队列同步执行任务"><a href="#3-并行队列同步执行任务" class="headerlink" title="3. 并行队列同步执行任务"></a>3. 并行队列同步执行任务</h5><ul>
<li>同步不具有创建新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程去执行任务</li>
<li>按照同步的方式去执行任务</li>
</ul>
<pre><code>-(void)syncCONCURRENT{
  NSLog(@"star");
  //不会开辟新的线程
  //串行执行命令
  dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
  dispatch_sync(queue, ^{
      [NSThread sleepForTimeInterval:3];
      NSLog(@"CONCURRENT_work_1 ");
  });
  dispatch_sync(queue, ^{
      [NSThread sleepForTimeInterval:2];
      NSLog(@"CONCURRENT_work_2 ");
  });
  dispatch_sync(queue, ^{
      NSLog(@"CONCURRENT_work_3 ");
  });

  NSLog(@"end");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:13:03.753 GCD_Demo[8232:1033759] star
2016-07-20 20:13:06.755 GCD_Demo[8232:1033759] CONCURRENT_work_1 
2016-07-20 20:13:08.756 GCD_Demo[8232:1033759] CONCURRENT_work_2 
2016-07-20 20:13:08.756 GCD_Demo[8232:1033759] CONCURRENT_work_3 
2016-07-20 20:13:08.757 GCD_Demo[8232:1033759] end</code></pre>

<p><strong>虽然并行队列决定了该队列中可以有多个线程，但由于是同步操作，不能开辟线程，所以还都是在主线程中按顺序执行。</strong></p>
<h5 id="4-并发队列异步执行任务-常用"><a href="#4-并发队列异步执行任务-常用" class="headerlink" title="4. 并发队列异步执行任务(常用)"></a>4. 并发队列异步执行任务(常用)</h5><ul>
<li>异步具有创建新线程的能力，会开辟新的线程去执行任务，不会在当前程序的主线程去执行任务</li>
<li>按照并发的方式去执行任务</li>
</ul>
<pre><code>-(void)asyncCONCURRENT{
  NSLog(@"star");

  //一个队列 为 每个任务开辟一个线程
  dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
  dispatch_async(queue, ^{
      [NSThread sleepForTimeInterval:3];
      NSLog(@"CONCURRENT_work_1 ");
  });
  dispatch_async(queue, ^{
      [NSThread sleepForTimeInterval:2];
      NSLog(@"CONCURRENT_work_2 ");
  });
  dispatch_async(queue, ^{
      NSLog(@"CONCURRENT_work_3 ");
  });

  NSLog(@"end");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:18:26.768 GCD_Demo[8256:1038143] star
2016-07-20 20:18:26.768 GCD_Demo[8256:1038143] end
2016-07-20 20:18:26.769 GCD_Demo[8256:1038192] CONCURRENT_work_3 
2016-07-20 20:18:28.771 GCD_Demo[8256:1038179] CONCURRENT_work_2 
2016-07-20 20:18:29.773 GCD_Demo[8256:1038188] CONCURRENT_work_1</code></pre>

<p><strong>并行队列可以里可以有多个线程，同步执行的方式又可以开辟多个线程，所以这里实现了多个线程并行执行。</strong></p>
<hr>
<h3 id="5-Dispatch-Group"><a href="#5-Dispatch-Group" class="headerlink" title="5.Dispatch Group"></a>5.Dispatch Group</h3><p>当我们想在gcd queue中所有的任务执行完毕之后做些特定事情的时候，也就是队列的同步问题，如果队列是串行的话，那将该操作最后添加到队列中即可，但如果队列是并行队列的话，这时候就可以利用dispatch_group来实现了，dispatch_group能很方便的解决同步的问题。dispatch_group_create可以创建一个group对象，然后可以添加block到该组里面，下面看下它的一些用法：</p>
<ul>
<li><p>dispatch_group_notify<br>  是通过异步的方式通知，所以，不会阻塞线程</p>
<pre><code>-(void)asyncGroupNotify
{
NSLog(@"star");
dispatch_group_t group=dispatch_group_create();
dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
dispatch_group_async(group, queue, ^{
    [NSThread sleepForTimeInterval:1];
    NSLog(@"group_work_1");
});
dispatch_group_async(group, queue, ^{
    [NSThread sleepForTimeInterval:6];
    NSLog(@"group_work_2");
});
dispatch_group_async(group, queue, ^{
    [NSThread sleepForTimeInterval:2];
    NSLog(@"group_work_3");
});

dispatch_group_notify(group, queue, ^{
    NSLog(@"dispatch_group_Notify 结束");
});
}</code></pre>

</li>
</ul>
<p>运行结果</p>
<pre><code>2016-07-21 13:51:40.600 GCD_Demo[9044:1162213] star
2016-07-21 13:51:41.605 GCD_Demo[9044:1162359] group_work_1
2016-07-21 13:51:42.608 GCD_Demo[9044:1162389] group_work_3
2016-07-21 13:51:46.603 GCD_Demo[9044:1162349] group_work_2
2016-07-21 13:51:46.605 GCD_Demo[9044:1162349] dispatch_group_Notify 结束</code></pre>

<ul>
<li>dispatch_group_wait<br>  会阻塞当前线程，知道任务都完成时才会继续执行下面的代码</li>
</ul>
<pre><code>-(void)asyncGroupWait
{
    NSLog(@"star");
    dispatch_group_t group=dispatch_group_create();
    dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_async(group, queue, ^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"group_work_1");
    });
    dispatch_group_async(group, queue, ^{
        [NSThread sleepForTimeInterval:6];
        NSLog(@"group_work_2");
    });
    dispatch_group_async(group, queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"group_work_3");
    });

    //在此设置了一个12秒的等待时间，如果group的执行结束没有到12秒那么就返回0
    //如果执行group的执行时间超过了12秒，那么返回非0 数值，
    //在使用dispatch_group_wait函数的时候，会阻塞当前线程，阻塞的时间 在wait函数时间值和当前group执行时间值取最小的。
    long kk=dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 12 * NSEC_PER_SEC));
    if(kk==0)
    {
         NSLog(@"dispatch_group_wait 结果1");
    }
    else
    {
         NSLog(@"dispatch_group_wait 结果2");
    }

}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 13:56:47.471 GCD_Demo[9065:1165380] star
2016-07-21 13:56:48.472 GCD_Demo[9065:1165494] group_work_1
2016-07-21 13:56:49.476 GCD_Demo[9065:1165502] group_work_3
2016-07-21 13:56:53.475 GCD_Demo[9065:1165485] group_work_2
2016-07-21 13:56:53.475 GCD_Demo[9065:1165380] dispatch_group_wait 结果1</code></pre>

<ul>
<li>dispatch_group_enter&amp;dispatch_group_leave<br>  假如我们不想使用dispatch_group_async异步的将任务丢到group中去执行，这时候就需要用到dispatch_group_enter跟dispatch_group_leave方法，这两个方法要配对出现，以下这两种方法是等价的：</li>
</ul>
<pre><code>-(void)asyncGroupEnter
{
  // 群组－统一监控一组任务
  dispatch_group_t group = dispatch_group_create();

  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

  // 1> 入组 -> 之后的 block 会被 group 监听
  // dispatch_group_enter 一定和 dispatch_group_leave 要配对出现
  dispatch_group_enter(group);
  dispatch_async(queue, ^{
      NSLog(@"dispatch_async_work1");

      // block 的末尾，所有任务执行完毕后，添加一个出组
      dispatch_group_leave(group);
  });

  //  再次入组
  dispatch_group_enter(group);
  dispatch_async(queue, ^{
      [NSThread sleepForTimeInterval:6];

      NSLog(@"dispatch_async_work1");

      // block 的末尾，所有任务执行完毕后，添加一个出组
      dispatch_group_leave(group);
  });

  // 群组结束
  dispatch_group_notify(group, dispatch_get_main_queue(), ^{
      NSLog(@"OVER");
  });  
  NSLog(@"come here");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 15:21:40.707 GCD_Demo[9256:1205427] come here
2016-07-21 15:21:40.707 GCD_Demo[9256:1205465] dispatch_async_work1
2016-07-21 15:21:46.709 GCD_Demo[9256:1205460] dispatch_async_work1
2016-07-21 15:21:46.710 GCD_Demo[9256:1205427] OVER</code></pre>



<hr>
<h3 id="6-Dispatch-Block"><a href="#6-Dispatch-Block" class="headerlink" title="6. Dispatch Block"></a>6. Dispatch Block</h3><p>添加到gcd队列中执行的任务是以block的形式添加的，block封装了需要执行功能，block带来的开发效率提升就不说了，gcd跟block可以说是一对好基友，能够很好的配合使用。</p>
<pre><code>-(void)dispatchBlock
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block=dispatch_block_create(0, ^{
        NSLog(@"dispatchBlock_work");
    });

    dispatch_sync(queue, block);
}</code></pre>

<h5 id="1-dispatch-block-wait"><a href="#1-dispatch-block-wait" class="headerlink" title="1.dispatch_block_wait"></a>1.dispatch_block_wait</h5><p>当需要等待前面的任务执行完毕时，我们可以使用dispatch_block_wait这个接口，设置等待时间DISPATCH_TIME_FOREVER会一直等待直到前面的任务完成.用法跟dispatch_group_wait类似</p>
<pre><code>-(void)dispatchBlockWait
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block = dispatch_block_create(0, ^{
        NSLog(@"before sleep");
        [NSThread sleepForTimeInterval:6];
        NSLog(@"after sleep");
    });
    dispatch_async(queue, block);
    //等待前面的任务执行完毕
    long kk=dispatch_block_wait(block, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));
    if(kk==0)
    {
        NSLog(@"coutinue");
    }
    else
    {
        NSLog(@"timeOut！！！");
    }
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:28:38.313 GCD_Demo[9533:1251011] before sleep
2016-07-21 16:28:41.314 GCD_Demo[9533:1250971] timeOut！！！
2016-07-21 16:28:44.318 GCD_Demo[9533:1251011] after sleep</code></pre>

<h5 id="2-dispatch-block-notify"><a href="#2-dispatch-block-notify" class="headerlink" title="2.dispatch_block_notify"></a>2.dispatch_block_notify</h5><p>dispatch_block_notify当观察的某个block执行结束之后立刻通知提交另一特定的block到指定的queue中执行，该函数有三个参数，第一参数是需要观察的block，第二个参数是被通知block提交执行的queue，第三参数是当需要被通知执行的block</p>
<pre><code>-(void)dispatchBlockNotify
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t previousBlock = dispatch_block_create(0, ^{
        NSLog(@"previousBlock begin");
        [NSThread sleepForTimeInterval:2];
        NSLog(@"previousBlock done");
    });
    dispatch_async(queue, previousBlock);
    dispatch_block_t notifyBlock = dispatch_block_create(0, ^{
        NSLog(@"notifyBlock");
    });
    //当previousBlock执行完毕后，提交notifyBlock到global queue中执行
    dispatch_block_notify(previousBlock, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), notifyBlock);
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:38:19.756 GCD_Demo[9664:1261328] previousBlock begin
2016-07-21 16:38:21.762 GCD_Demo[9664:1261328] previousBlock done
2016-07-21 16:38:21.762 GCD_Demo[9664:1261329] notifyBlock</code></pre>

<h5 id="3-dispatch-block-cancel"><a href="#3-dispatch-block-cancel" class="headerlink" title="3. dispatch_block_cancel"></a>3. dispatch_block_cancel</h5><p>可以取消提交到队列的block</p>
<pre><code>-(void)dispatchBlockCancel
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
    dispatch_block_t block1 = dispatch_block_create(0, ^{
        NSLog(@"block1 begin");
        [NSThread sleepForTimeInterval:1];
        NSLog(@"block1 done");
    });
    dispatch_block_t block2 = dispatch_block_create(0, ^{
        NSLog(@"block2 ");
    });
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_block_cancel(block2);
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:50:28.140 GCD_Demo[9723:1272259] block1 begin
2016-07-21 16:50:29.144 GCD_Demo[9723:1272259] block1 done</code></pre>


<hr>
<h3 id="7-dispatch-after"><a href="#7-dispatch-after" class="headerlink" title="7.dispatch_after"></a>7.dispatch_after</h3><p>来延迟执行的GCD方法，因为在主线程中我们不能用sleep来延迟方法的调用，所以用它是最合适的，我们做一个简单的例子：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)dispatchAfter</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatchAfter_star"</span>);</div><div class="line">    int64_t time=<span class="number">2</span>*<span class="built_in">NSEC_PER_SEC</span>;</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_queue_t</span> mainQueue=dispatch_get_main_queue();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">        dispatch_time_t disTime=dispatch_time(DISPATCH_TIME_NOW, time*i);</div><div class="line"></div><div class="line">        dispatch_after(disTime, mainQueue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"dispatchAfter_work"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果</p>
<pre><code>2016-07-21 16:12:07.204 GCD_Demo[9439:1237251] dispatchAfter_star
2016-07-21 16:12:07.211 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:09.398 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:11.205 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:13.205 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:15.205 GCD_Demo[9439:1237251] dispatchAfter_work</code></pre>


<hr>
<h3 id="8-dispatch-apply"><a href="#8-dispatch-apply" class="headerlink" title="8.dispatch_apply"></a>8.dispatch_apply</h3><p>dispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次，如果队列是并发队列，则会并发执行block任务，dispatch_apply是一个同步调用，block任务执行n次后才返回。</p>
<pre><code>-(void)dispatchApply
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);


    dispatch_apply(6, queue, ^(size_t i) {
        NSLog(@"do a job %zu times",i);

    });
    NSLog(@"go on");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 17:04:54.558 GCD_Demo[9831:1284549] do a job 0 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284583] do a job 1 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284589] do a job 2 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284593] do a job 3 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284549] do a job 4 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284583] do a job 5 times
2016-07-21 17:04:54.566 GCD_Demo[9831:1284549] go on</code></pre>


<hr>
<h3 id="9-dispatch-once"><a href="#9-dispatch-once" class="headerlink" title="9.dispatch_once"></a>9.dispatch_once</h3><p>整个程序运行中只会执行一次，使用dispatch_once可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或者同步。所有问题都由GCD在底层处理。由于每次调用时都必须使用完全相同的标记，所以标记要声明成static。所以用在单例模式上是最好的</p>
<pre><code>static SingletonTimer * instance;
static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
    instance = [[SingletonTimer alloc] init];
});

return instance;</code></pre>


<hr>
<h3 id="10-dispatch-barrier-async"><a href="#10-dispatch-barrier-async" class="headerlink" title="10. dispatch_barrier_async"></a>10. dispatch_barrier_async</h3><p>dispatch_barrier_async用于等待前面的任务执行完毕后自己才执行，而它后面的任务需等待它完成之后才执行。一个典型的例子就是数据的读写，通常为了防止文件读写导致冲突，我们会创建一个串行的队列，所有的文件操作都是通过这个队列来执行，比如FMDB，这样就可以避免读写冲突。不过其实这样效率是有提升的空间的，当没有更新数据时，读操作其实是可以并行进行的，而写操作需要串行的执行</p>
<pre><code>-(void)diapatchBarrier
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);

    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:6];
        NSLog(@"dispatch_async_work1");
    });
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"dispatch_async_work2");
    });
    dispatch_barrier_async(queue, ^{
        NSLog(@"dispatch_async_work3");
        [NSThread sleepForTimeInterval:1];

    });
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"dispatch_async_work4");
    });
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 15:54:24.402 GCD_Demo[9354:1225160] dispatch_async_work2
2016-07-21 15:54:28.403 GCD_Demo[9354:1225152] dispatch_async_work1
2016-07-21 15:54:28.403 GCD_Demo[9354:1225152] dispatch_async_work3
2016-07-21 15:54:30.412 GCD_Demo[9354:1225152] dispatch_async_work4</code></pre>


<hr>
<h3 id="11-dispatch-set-target-queue"><a href="#11-dispatch-set-target-queue" class="headerlink" title="11.dispatch_set_target_queue"></a>11.dispatch_set_target_queue</h3><p>1.系统的Global Queue是可以指定优先级的，那我们可以用到dispatch_set_target_queue这个方法来指定自己创建队列的优先级</p>
<pre><code>-(void)DispatchSet
{
    dispatch_queue_t serialDiapatchQueue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t dispatchgetglobalqueue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
    dispatch_set_target_queue(serialDiapatchQueue, dispatchgetglobalqueue);
    dispatch_async(serialDiapatchQueue, ^{
        NSLog(@"我优先级低，先让让");
    });
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"我优先级高,我先block");
    });
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 17:22:02.512 GCD_Demo[9902:1297023] 我优先级高,我先block
2016-07-21 17:22:02.512 GCD_Demo[9902:1297035] 我优先级低，先让让</code></pre>

<p>2.dispatch_set_target_queue除了能用来设置队列的优先级之外，还能够创建队列的层次体系，当我们想让不同队列中的任务同步的执行时，我们可以创建一个串行队列，然后将这些队列的target指向新创建的队列即可</p>
<pre><code>-(void)dispatchSet2
{
    dispatch_queue_t targetQueue = dispatch_queue_create("target_queue", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue1 = dispatch_queue_create("queue1", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue2 = dispatch_queue_create("queue2", DISPATCH_QUEUE_CONCURRENT);


    dispatch_set_target_queue(queue1, targetQueue);
    dispatch_set_target_queue(queue2, targetQueue);

    dispatch_async(queue1, ^{
        [NSThread sleepForTimeInterval:3.f];
        NSLog(@"do job1");

    });
    dispatch_async(queue2, ^{
        [NSThread sleepForTimeInterval:2.f];
        NSLog(@"do job2");

    });
    dispatch_async(queue2, ^{
        [NSThread sleepForTimeInterval:1.f];
        NSLog(@"do job3");

    });
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 17:28:54.327 GCD_Demo[10043:1303853] do job1
2016-07-21 17:28:56.331 GCD_Demo[10043:1303853] do job2
2016-07-21 17:28:57.335 GCD_Demo[10043:1303853] do job3</code></pre>


<hr>
<h3 id="12-dispatch-semaphore-t"><a href="#12-dispatch-semaphore-t" class="headerlink" title="12.dispatch_semaphore_t"></a>12.dispatch_semaphore_t</h3><p>信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra 介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。</p>
<pre><code>- (void)downloadImageURLWithString:(NSString *)URLString
{
    // 1
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    NSURL *url = [NSURL URLWithString:URLString];
    __unused Photo *photo = [[Photo alloc]
                             initwithURL:url
                             withCompletionBlock:^(UIImage *image, NSError *error) {
                                 if (error) {
                                     XCTFail(@"%@ failed. %@", URLString, error);
                                 }

                                 // 2
                                 dispatch_semaphore_signal(semaphore);
                             }];

    // 3
    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);
    if (dispatch_semaphore_wait(semaphore, timeoutTime)) {
        XCTFail(@"%@ timed out", URLString);
    }
}</code></pre>

<p>下面来说明你代码中的信号量是如何工作的：</p>
<ol>
<li>创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。</li>
<li>在 Completion Block 里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。</li>
<li>这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过 10 秒钟就会返回——一个平衡点！</li>
</ol>
<hr>
<h3 id="13-GCD定时器"><a href="#13-GCD定时器" class="headerlink" title="13.GCD定时器"></a>13.GCD定时器</h3><p>基于以前讲的runloop中的CFRunLoopTimerRef :</p>
<ul>
<li>CFRunLoopTimerRef是基于时间的触发器</li>
<li>CFRunLoopTimerRef基本上说的就是NSTimer,它受RunLoop的Mode的影响(Tracking,Defalult)</li>
<li>GCD的定时器不受RunLoop中Mode的影响(RunLoop内部也是基于GCD实现的,可以根据源码看到), 比如滚动TableView的时候,GCD的定时器不受影响</li>
<li>一般NSTimer不是特别准, NSTimer是在RunLoop中, RunLoop要处理各种东西(source,timer,observe),有时导致NSTimer不是特别准</li>
</ul>
<p>GCD定时器算是一个源(source),类型是Timer</p>
<pre><code>-(void)startTime{
    __block int timeout=30; //倒计时时间
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);

    dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行
    dispatch_source_set_event_handler(_timer, ^{
        if(timeout=0){ //倒计时结束，关闭
            dispatch_source_cancel(_timer);
            dispatch_async(dispatch_get_main_queue(), ^{
                //倒计时时间结束，回到主线程 根据自己需求设置

            });
        }else{
            //            int minutes = timeout / 60;
            int seconds = timeout % 60;
            NSString *strTime = [NSString stringWithFormat:@"%.2d", seconds];
            dispatch_async(dispatch_get_main_queue(), ^{
                //设置界面的按钮显示 根据自己需求设置
                NSLog(@"____%@",strTime);
                [l_timeButton setTitle:[NSString stringWithFormat:@"%@秒后重新发送",strTime] forState:UIControlStateNormal];
                l_timeButton.userInteractionEnabled = NO;

            });
            timeout--;

        }
    });
    dispatch_resume(_timer);

}</code></pre>






<!-- more -->
            
        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/GCD/">GCD</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/09/18/聊一聊NSOperation的那些事/"  data-tooltip="聊一聊NSOperation的那些事">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/09/08/RunLoop总结/" data-tooltip="RunLoop总结">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://v.t.sina.com.cn/share/share.php?url=http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/&amp;title=聊一聊GCD的那些事">
                <i class="fa fa-weibo"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/">
                <i class="fa fa-qq"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default"  href="javascript:show();" >
                <i class="fa fa-wechat (alias)"></i>
            </a>
        </li>
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>
<div id="jiathis_weixin_modal" style="z-index:1000;display:none; background-clip: padding-box;background-color: #FFFFFF;border: 1px solid rgba(0, 0, 0, 0.3);  border-radius: 6px 6px 6px 6px;  box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); left: 50%; margin: -200px 0 0 -200px;overflow: hidden; position: fixed; top: 50%; width:360px;height:370px; overflow:hidden;" class="jiathis_weixin_modal"><div class="jiathis_modal_header" id="jiathis_modal_header" style="border-bottom: 1px solid #EEEEEE; padding: 9px 15px;"><a style="text-decoration:none;  margin-top: 2px; color: #000000; float: right;  font-size: 20px;  font-weight: bold; cursor:pointer;line-height: 20px; opacity: 0.2; text-shadow: 0 1px 0 #FFFFFF;" class="jiathis_weixin_close" id="jiathis_weixin_close" href="javascript:hidden();" target="_self">×</a><h3 id="jiathis_weixin_h3" style=" line-height: 30px; margin: 0; font-weight:normal; font-family:" 微软雅黑";"="">分享到微信朋友圈</h3></div><div class="jiathis_modal_body" id="jiathis_modal_body" style="text-align:center;height:251px;"><p id="jiathis_webchat"><img alt="二维码加载失败..." style="margin-top: 15px;" src="http://s.jiathis.com/qrcode.php?url=http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/" height="220" width="220"></p></div><div class="jiathis_modal_footer" id="jiathis_modal_footer" style="border-radius: 0 0 6px 6px; border-top: 1px solid #DDDDDD; box-shadow: 0 1px 0 #FFFFFF inset; height:100%;padding:0 10px;padding-top:11px;text-align: right; font-size:12px;"><div id="jiathis_weixin_tip" style="text-align:left;margin:0; padding:0;font-size:12px;background-color: #FFFFFF;">打开微信，点击底部的“发现”，使用 “扫一扫” 即可将网页分享到我的朋友圈。</div></div></div>

<script charset="utf-8">
    function show(){
        $("#jiathis_weixin_modal").css("display", "block")
    }
    function hidden(){
        $("#jiathis_weixin_modal").css("display", "none")
    } 
</script>







        
            
                
<div class="duoshuo">
<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script>
var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: "3b1a42e3f91145d197b9e8b6e2f2a144",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>
</div>



            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 贵永冬. All Rights Reserved.
    </span>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/09/18/聊一聊NSOperation的那些事/"  data-tooltip="聊一聊NSOperation的那些事">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/09/08/RunLoop总结/" data-tooltip="RunLoop总结">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://v.t.sina.com.cn/share/share.php?url=http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/&amp;title=聊一聊GCD的那些事">
                <i class="fa fa-weibo"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/">
                <i class="fa fa-qq"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default"  href="javascript:show();" >
                <i class="fa fa-wechat (alias)"></i>
            </a>
        </li>
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>
<div id="jiathis_weixin_modal" style="z-index:1000;display:none; background-clip: padding-box;background-color: #FFFFFF;border: 1px solid rgba(0, 0, 0, 0.3);  border-radius: 6px 6px 6px 6px;  box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); left: 50%; margin: -200px 0 0 -200px;overflow: hidden; position: fixed; top: 50%; width:360px;height:370px; overflow:hidden;" class="jiathis_weixin_modal"><div class="jiathis_modal_header" id="jiathis_modal_header" style="border-bottom: 1px solid #EEEEEE; padding: 9px 15px;"><a style="text-decoration:none;  margin-top: 2px; color: #000000; float: right;  font-size: 20px;  font-weight: bold; cursor:pointer;line-height: 20px; opacity: 0.2; text-shadow: 0 1px 0 #FFFFFF;" class="jiathis_weixin_close" id="jiathis_weixin_close" href="javascript:hidden();" target="_self">×</a><h3 id="jiathis_weixin_h3" style=" line-height: 30px; margin: 0; font-weight:normal; font-family:" 微软雅黑";"="">分享到微信朋友圈</h3></div><div class="jiathis_modal_body" id="jiathis_modal_body" style="text-align:center;height:251px;"><p id="jiathis_webchat"><img alt="二维码加载失败..." style="margin-top: 15px;" src="http://s.jiathis.com/qrcode.php?url=http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/" height="220" width="220"></p></div><div class="jiathis_modal_footer" id="jiathis_modal_footer" style="border-radius: 0 0 6px 6px; border-top: 1px solid #DDDDDD; box-shadow: 0 1px 0 #FFFFFF inset; height:100%;padding:0 10px;padding-top:11px;text-align: right; font-size:12px;"><div id="jiathis_weixin_tip" style="text-align:left;margin:0; padding:0;font-size:12px;background-color: #FFFFFF;">打开微信，点击底部的“发现”，使用 “扫一扫” 即可将网页分享到我的朋友圈。</div></div></div>

<script charset="utf-8">
    function show(){
        $("#jiathis_weixin_modal").css("display", "block")
    }
    function hidden(){
        $("#jiathis_weixin_modal").css("display", "none")
    } 
</script>







                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <ul class="share-options">
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/">
                <i class="fa fa-weibo"></i><span>微博</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/">
                <i class="fa fa-qq"></i><span>QQ</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn"  href="javascript:show();" >
                <i class="fa fa-wechat (alias)"></i><span>微信</span>
            </a>
        </li>
    </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>



<div id="jiathis_weixin_modal" style="display:none; background-clip: padding-box;background-color: #FFFFFF;border: 1px solid rgba(0, 0, 0, 0.3);  border-radius: 6px 6px 6px 6px;  box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); left: 50%; margin: -200px 0 0 -200px;overflow: hidden; position: fixed; top: 50%; width:360px;height:370px; overflow:hidden;" class="jiathis_weixin_modal"><div class="jiathis_modal_header" id="jiathis_modal_header" style="border-bottom: 1px solid #EEEEEE; padding: 9px 15px;"><a style="text-decoration:none;  margin-top: 2px; color: #000000; float: right;  font-size: 20px;  font-weight: bold; cursor:pointer;line-height: 20px; opacity: 0.2; text-shadow: 0 1px 0 #FFFFFF;" class="jiathis_weixin_close" id="jiathis_weixin_close" href="javascript:hidden();" target="_self">×</a><h3 id="jiathis_weixin_h3" style=" line-height: 30px; margin: 0; font-weight:normal; font-family:" 微软雅黑";"="">分享到微信朋友圈</h3></div><div class="jiathis_modal_body" id="jiathis_modal_body" style="text-align:center;height:251px;"><p id="jiathis_webchat"><img alt="二维码加载失败..." style="margin-top: 15px;" src="http://s.jiathis.com/qrcode.php?url=http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/" height="220" width="220"></p></div><div class="jiathis_modal_footer" id="jiathis_modal_footer" style="border-radius: 0 0 6px 6px; border-top: 1px solid #DDDDDD; box-shadow: 0 1px 0 #FFFFFF inset; height:100%;padding:0 10px;padding-top:11px;text-align: right; font-size:12px;"><div id="jiathis_weixin_tip" style="text-align:left;margin:0; padding:0;font-size:12px;background-color: #FFFFFF;">打开微信，点击底部的“发现”，使用 “扫一扫” 即可将网页分享到我的朋友圈。</div></div></div>

<script charset="utf-8">
    function show(){
        $("#jiathis_weixin_modal").css("display", "block")
    }
    function hidden(){
        $("#jiathis_weixin_modal").css("display", "none")
    } 
</script>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/header.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">贵永冬</h4>
        
            <div id="about-card-bio"><p>iOS开发者<br> 会一点RN和android,  十足的海贼迷</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>郑州市时空隧道信息技术有限公司</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                河南 郑州
            </div>
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/08/11/初识ReactiveCocoa/">
                            <h3 class="media-heading">初识ReactiveCocoa</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年8月11日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>(简称为RAC), 是由Github开源的一个应用于iOS和OS开发的新框架, RAC具有函数式编程和响应式编程的特性, 通过这篇文章对RAC有一个简单的了解。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/08/12/深入ReactiveCocoa/">
                            <h3 class="media-heading">深入ReactiveCocoa</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年8月12日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>(简称为RAC),上一篇文章，我们简单的对RAC有个初步的了解，在开发中，我们实际用到的基本都是上一篇所介绍的知识，这篇文章我们对RAC有个深入的了解。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/06/ReactiveCocoa和RXSwift速查表/">
                            <h3 class="media-heading">ReactiveCocoa和RXSwift速查表</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>在接触了RAC以后,对RAC有了一个基本的了解，这里整理了一下RAC脑图，方便日后查看。ps(<a href="https://github.com/aiqiuqiu/FRPCheatSheeta">转载</a>)</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/06/关于RAC的一些资料/">
                            <h3 class="media-heading">关于RAC的一些资料</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>看了这么多RAC资料，在这里我整理了一下，以备学习。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/08/RunLoop总结/">
                            <h3 class="media-heading">RunLoop总结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月8日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>最近研究了一下RunLoop，在这里对RunLoop做一个总结，主要是对<code>&lt;CoreFoundation/CFRunLoop.h&gt;</code>的头文件函数总结。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/">
                            <h3 class="media-heading">聊一聊GCD的那些事</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月13日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/18/聊一聊NSOperation的那些事/">
                            <h3 class="media-heading">聊一聊NSOperation的那些事</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月18日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>在iOS开发中，多线程技术用到最多的就是GCD和NSOperation，上一篇文章已经对GCD有了全面的了解，这篇文章简单的聊一聊NSOperation。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/21/iOS动画篇-transfrom/">
                            <h3 class="media-heading">iOS动画篇之UIView动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月21日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/22/iOS动画篇之CoreAnimation动画/">
                            <h3 class="media-heading">iOS动画篇之CoreAnimation动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>App如果想被大众喜欢，漂亮的UI和精美的动画都是必不可少的，苹果虽然为UIView提供了一些常用动画，但是大部分看起来比较不错的效果都是通过操作Layer层实现的，因此了解核心动画是必要的.CoreAnimation是直接作用在CALayer上的(并非UIView上)非常强大的跨Mac OS X和iOS平台的动画处理API，Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/22/iOS动画之CATransition动画/">
                            <h3 class="media-heading">iOS动画之CATransition动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>今天主要用到的动画类是CALayer下的CATransition至于各种动画类中如何继承的在这也不做赘述，网上的资料是一抓一大把。好废话少说切入今天的正题。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 43 篇文章
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-rt08quwts7iav5x0cfd2ym0gb5qkd1lvrsmwrakxtkhefmaaes4ywkmnjnwf.min.js"></script>
<script src="/assets/js/prism.js"></script>
<!--SCRIPTS END-->

    
        <script type="text/javascript">
            var duoshuoQuery = {short_name:'guiyongdong'};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>
    



    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script>
    <script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
    <script>
        var algoliaClient = algoliasearch('DWKE0MOOLY', '141d50cf933ece6dd635747973c4fe00');
        var algoliaIndex = algoliaClient.initIndex('blog');
    </script>

    </body>
</html>
