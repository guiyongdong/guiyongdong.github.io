
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="贵大头的博客">
    <title>【转】iOS Memory Deep Dive - 贵大头的博客</title>
    <meta name="author" content="贵永冬">
<link rel="icon" href="https://github.com/guiyongdong/Resource/blob/master/hexoImage/favicon.ico?raw=true">
    
    
        <link rel="icon" href="https://github.com/guiyongdong/Resource/blob/master/hexoImage/favicon.ico?raw=true">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="前言仅以此文解答自己大学以来多年对内存管理的疑惑。
经典操作系统的虚拟内存为什么要有虚拟内存？随着计算机的发展，我们的计算机处理的任务也变得越来越繁多，但是对于某台固定的计算机，CPU 和 Memory都是固定的，如果有些直接使用物理内存地址的话会带来很多问题。首先编译器不能以一种抽象的角度来描绘内存，在执行的过程中如果某个进程占据的内存过大，这个进程可能就无法运行，即便运行了，内存相对来说是非常">
<meta property="og:type" content="blog">
<meta property="og:title" content="【转】iOS Memory Deep Dive">
<meta property="og:url" content="https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/index.html">
<meta property="og:site_name" content="贵大头的博客">
<meta property="og:description" content="前言仅以此文解答自己大学以来多年对内存管理的疑惑。
经典操作系统的虚拟内存为什么要有虚拟内存？随着计算机的发展，我们的计算机处理的任务也变得越来越繁多，但是对于某台固定的计算机，CPU 和 Memory都是固定的，如果有些直接使用物理内存地址的话会带来很多问题。首先编译器不能以一种抽象的角度来描绘内存，在执行的过程中如果某个进程占据的内存过大，这个进程可能就无法运行，即便运行了，内存相对来说是非常">
<meta property="og:updated_time" content="2018-10-27T11:09:05.832Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【转】iOS Memory Deep Dive">
<meta name="twitter:description" content="前言仅以此文解答自己大学以来多年对内存管理的疑惑。
经典操作系统的虚拟内存为什么要有虚拟内存？随着计算机的发展，我们的计算机处理的任务也变得越来越繁多，但是对于某台固定的计算机，CPU 和 Memory都是固定的，如果有些直接使用物理内存地址的话会带来很多问题。首先编译器不能以一种抽象的角度来描绘内存，在执行的过程中如果某个进程占据的内存过大，这个进程可能就无法运行，即便运行了，内存相对来说是非常">
    
    
        
    
    
        <meta property="og:image" content="https://guiyongdong.github.io/assets/images/header.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-yrst5vo1nxaxbp2g3v9na2wg1lixlpr3ghbjdvskeixmu79deycecx3rh4bt.min.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">贵大头的博客</a>
    </div>
    
        
            <a  class="header-right-icon "
                href="#about">
        
        
            <i class="fa fa-lg fa-header.jpg"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/header.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">贵永冬</h4>
                
                    <h5 class="sidebar-profile-bio"><p>iOS开发者<br> 会一点RN和android,  十足的海贼迷</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/guiyongdong" target="_blank">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:564024928@qq.com" target="_blank">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">订阅</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            【转】iOS Memory Deep Dive
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" datetime="2018-10-16T13:06:45+08:00">
	
		    10月 16, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>仅以此文解答自己大学以来多年对内存管理的疑惑。</p>
<h2 id="经典操作系统的虚拟内存"><a href="#经典操作系统的虚拟内存" class="headerlink" title="经典操作系统的虚拟内存"></a>经典操作系统的虚拟内存</h2><h3 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h3><p>随着计算机的发展，我们的计算机处理的任务也变得越来越繁多，但是对于某台固定的计算机，CPU 和 Memory<br>都是固定的，如果有些直接使用物理内存地址的话会带来很多问题。首先编译器不能以一种抽象的角度来描绘内存，在执行的过程中如果某个进程占据的内存过大，这个进程可能就无法运行，即便运行了，内存相对来说是非常不安全的，一个不小心操作到了别的进程的内存，可能导致进程的崩溃，如果写入了内核使用的内存可能导致操作系统的崩溃。</p>
<p>现代操作系统的内存管理是非常多计算机科学家智慧的结晶，这种管理方式就是  <strong>虚拟内存 (Virtual Memory/VM)</strong> 。VM<br>是一系列技术的总称，包括硬件异常，物理地址，主存，磁盘文件，操作系统内核软件的内存管理。</p>
<p>虚拟内存提供了三大重要的特性：</p>
<ol>
<li><p>它将主存看做在存储在磁盘上的地址空间的高速缓存，利用程序的局部性原理，只将活跃的内存加载到主存中，提高了主存的利用率；</p>
</li>
<li><p>为每个进程提供了一个抽象的统一的连续的私有的地址空间。简化了内存管理方式；</p>
</li>
<li><p>对内存进行分段（segment）提供权限能力，保护每个进程的地址空间不会被其他进程影响；</p>
</li>
</ol>
<a id="more"></a>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>在一些早期的操作系统和一些嵌入式操作系统中，内存管理使用的地址是物理地址，现代操作系统基本使用的是 <code>虚拟地址（Virtual
Addressing）</code>的寻址方式，使用 <strong>虚拟地址</strong> 时 CPU 将 <code>VA</code> 送到 <code>MMU</code> 中去翻译为物理地址。</p>
<blockquote>
<p>注：  <strong>MMU （Memory Management Unit）</strong>  内存管理单元一般是一个 CPU<br>上的专用芯片，是一个硬件。结合操作系统共同完成地址翻译工作。</p>
</blockquote>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>通常来说地址空间是 <strong>线性的</strong> 。假设我们有 {0, 1, 2, ..N-1 } 个内存地址，我们可以用 n<br>位二进制来表示内存地址，那么我们就叫这个地址空间为 n 位地址空间。现代操作系统通常是 32 或者 64(但是很多操作系统只用了48位寻址)的。</p>
<pre><code>2^10 = 1k  
2^20 = 1M  
2^30 = 1G  
2^40 = 1T  
2^50 = 1P  
2^60 = 1E  
</code></pre><p>这么看来大家能理解为什么 32位 的操作系统最大只支持 4G 内存空间了。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>现代操作系统将内存划分为页，来简化内存管理，一个页其实就是一段连续的内存地址的集合，通常有 4k 和 16k（iOS 64位是16K）的，成为<br><code>Virtual Page</code> 虚拟页。与之对应的物理内存被称为 <code>Physical Page</code> 物理页。</p>
<blockquote>
<p>注意：虚拟页的个数可能和物理页个数不一样。比如说一个 64 位操作系统中，使用 48 位地址空间的虚拟页大小为<br>16K，那么其虚拟页数可达到（2^48/2^14 = 16M个），假设物理内存只有 4G，那么物理页可能只有 (2^32/2^14 = 256k个)</p>
</blockquote>
<p>操作系统将虚拟页和物理页的映射关系称为 <strong>页表</strong> （Page Table），每个映射叫  <strong>页表条目</strong> （Page Table<br>Entry/Item），操作系统为每个进程提供一个页表放在主存中，CPU 在使用虚拟地址时交给 MMU 去翻译地址，MMU 去查询在主存中的页表来翻译。</p>
<h4 id="缺页处理"><a href="#缺页处理" class="headerlink" title="缺页处理"></a>缺页处理</h4><p>每个 <code>Page Table Entry</code> 都包含了一些描述信息，比如当前页的状态{未分配，缓存的，未缓存的}。</p>
<ol>
<li><p>未分配的不用多说代表未使用的内存；</p>
</li>
<li><p>缓存的代表已经加载进物理内存了；</p>
</li>
<li><p>未缓存的代表还没放在物理内存。</p>
</li>
</ol>
<p>当 CPU 要读取一个页时，检查标记发现当前的页是未缓存的，会触发一个（Page Falut） <strong>缺页中断</strong><br>，这时内核、操作系统的缺页异常处理程序，去选择一个牺牲页（有时候内存够用不用置换别的界面），然后检查这个页面是否有修改，有修改会先写磁盘，然后将需要使用到的内存加载到物理内存中，然后更新<br><code>PTE</code>，随后操作系统重新把虚拟地址发送到地址翻译硬件去重新处理。</p>
<blockquote>
<p>注：有些操作系统无虚拟虚拟内存置换逻辑，如 iOS，取而代之的是内存压缩和收到内存警告时杀死进程的行为。</p>
</blockquote>
<h3 id="虚拟内存带来的好处"><a href="#虚拟内存带来的好处" class="headerlink" title="虚拟内存带来的好处"></a>虚拟内存带来的好处</h3><ol>
<li><p>简化链接过程，允许每个进程都提供统一的内存地址的抽象，独立于物理内存；</p>
</li>
<li><p>简化加载，操作系统加载可执行文件和共享文件时，只是创建了 <strong>页表</strong> ，待访问到缺页时，操作系统再去加载；</p>
</li>
<li><p>简化共享，不同进程的 PT 中的 PTE 可以执行相同的物理地址，如动态库的代码；</p>
</li>
<li><p>内存保护，PT 中的 PTE 中描述了一个虚拟页的权限信息，（R， W， X），指令如果违反了这些权限信息，就会造成 Segment Fault</p>
</li>
</ol>
<h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>虚拟地址翻译到物理地址是软硬件结合实现的。我们通常几个方面来描述。</p>
<h4 id="如何索引"><a href="#如何索引" class="headerlink" title="如何索引"></a>如何索引</h4><p>现代操作系统将地址分为两部分， <strong>页号</strong> 和 <strong>片</strong><br>了（是不是很类型网络号和主机号），由于虚拟页和物理页的大小是相同的，页偏移可以看做虚拟页和物理页的页内地址，且相同；页号则做为 PT 的索引查找到对应的<br>PTE，然后查找对应的物理页地址。</p>
<h4 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h4><p>是不是像前面所说的简单的划分为两部分就足够了呢？</p>
<p>举个例子:</p>
<ol>
<li><p>我们假设一台电脑是 32 位的，分页大小位 4k，也就说页内地址占据了 12 位，页号地址位 20 位；</p>
</li>
<li><p>我们假设一台电脑是 64 位的，地址空间 48 位，分页大小为 16k，也就说页内地址占据了 14 位，页号地址位 34 位</p>
</li>
</ol>
<p>我们粗略估算一个 PTE 为 4KB，对于 32位 的操作系统每个进程的页表需要 2^20 = 4M 个页表项常驻内存尚可接受，但是对于寻址为 48位<br>的操作系统来说，每个进程的页表为需要 2^32 = 4G 个页表项，这是无法接受的。</p>
<p>计算机的世界所有的难题都可以用多加一层的办法来解决，所以现代操作系统通常都使用多级页表，减少页表项的个数。将虚拟地址分为多端，代表了一级、二级、多级页表。通过多级页表可以大大减少内存占用。</p>
<h4 id="减少内存"><a href="#减少内存" class="headerlink" title="减少内存"></a>减少内存</h4><p>众所周知 CPU 要比 Memory 快 <code>10^3</code> 个数量级，即便 CPU 中的 <code>L3Cache</code> 也比 Memory 快很多，如果 MMU<br>的地址翻译都要去查找多级 PT，这个开销就会非常巨大，但是所幸程序的局部性原理能够解救我们。MMU 芯片内置一个 <strong>翻译后备缓冲器</strong><br>（Transalation Lookaside Buffer TLB ）的硬件来充当缓存，加快地址翻译的效率.</p>
<h3 id="现代-OS-虚拟内存系统"><a href="#现代-OS-虚拟内存系统" class="headerlink" title="现代 OS 虚拟内存系统"></a>现代 OS 虚拟内存系统</h3><p>操作系统为每个进程维护一个单独的虚拟地址空间，分为两部分：</p>
<ol>
<li><p><strong>内核虚拟内存</strong> ：包含内核中的代码和数据结构，还有一些被映射到所有进程共享的内存页面。还有一些页表，内核在进程上下文中执行代码使用的栈。</p>
</li>
<li><p><strong>进程虚拟内存</strong> ：OS 将内存组织为一些区域（Segment）的集合，代码端，数据端，共享库端，线程栈都是不同的区域，分段的原因是便于管理内存的权限，如果了解过 Mach-O 文件或者 ELF 文件的读者可以看到相同的 Segment 里面的内存权限是相同的，每个 Segment 再划分不同的内容为 section。</p>
</li>
</ol>
<p>在内核中描述一个进程的数据结构概略为如下</p>
<p>pgb 指向第一级页表的基址</p>
<p>每个区域的描述主要有以下几个</p>
<ul>
<li><p><strong>vm_start</strong>  指向这个区域的起始处</p>
</li>
<li><p><strong>vm_end</strong>  指向这个区域的结束出</p>
</li>
<li><p><strong>vm_prot</strong>  内存区域的读写权限</p>
</li>
<li><p><strong>vm_flasg</strong>  一些标志位 私有的还是共享的</p>
</li>
<li><p><strong>vm_next</strong>  指向下一个 vm_area_struct 的描述</p>
</li>
</ul>
<h4 id="内存映射-MMAP"><a href="#内存映射-MMAP" class="headerlink" title="内存映射 MMAP"></a>内存映射 MMAP</h4><p>类 Unix 操作系统可以映射一个普通磁盘上的文件的连续部分到一个固定的内存区域。操作系统会自动管理映射的内容。</p>
<p>内存映射允许不同的进程映射不同的虚拟内存到同一块物理内容上，他们可以是共享的也可以是私有的。</p>
<p>对于共享的，通常多个进程映射到相同的共享对象上。对与私有的，不同进程初始映射的时候操作系统为了节省资源，并没有产生真的副本，直到某个进程修改了这个私有对象，操作系统运用<br><code>copy on write</code> 技术在此时才发生真正的文件拷贝。</p>
<p>mmap 在类 unix 操作系统上作为一个系统调用存在，函数签名如下</p>
<pre><code>void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset);  
     addr 代表要从那块虚拟地址开始映射，通常可以不用指定传递NULL让操作系统自己给我们选择  
     len 映射多少长度的内容  
        prot 映射文件的访问权限 读写可执行权限等  
        PROT_EXEFC 可执行权限  
        PROT_READ 可读权限  
        PROT_WRITE 可写权限  
        PROT_NONE 无法访问权限  
    flags 访问文件的标记  
        MAP_SHARED 共享的  
        MAP_PRIVATE私有的  
        MAP_ANON 私有的  
</code></pre><p>举个例子将任意文件映射到 stdout</p>
<pre><code>#include &lt;sys/mman.h&gt;  

int main(int argc, const char * argv[]) {  
    struct stat stat;  
    int fd;  
    if (argc != 2) {  
        printf(&quot;must pass file path&quot;);  
        return 1;  
    }  
    fd = open(argv[1], O_RDONLY, 0);  
    fstat(fd, &amp;stat);  
    char *buffer = mmap(NULL, stat.st_size, PROT_READ, MAP_PRIVATE, fd, 0);  
    printf(&quot;%s&quot;, buffer);  
    return 0;  
}  
</code></pre><h4 id="MMAP-在-iOS-中的用处"><a href="#MMAP-在-iOS-中的用处" class="headerlink" title="MMAP 在 iOS 中的用处"></a>MMAP 在 iOS 中的用处</h4><ol>
<li><p>mmap 让读写一个文件像操作一个内存地址一样简单方便；</p>
</li>
<li><p>mmap 效率极高，不用将一个内容从磁盘读入内核态再拷贝至用户态；</p>
</li>
<li><p>mmap 映射的文件由操作系统接管，如果进程 Crash 操作系统会保证文件刷新回磁盘；</p>
</li>
</ol>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>虽然可以使用上面的低级 API 去映射内存，但是需要动态申请内存用来做变量处理的时候就需要 <strong>动态内存分配器</strong> （Dunamic memory<br>allocator），简单理解为 <code>malloc calloc realloc free</code> 等函数来自的库就称为<br><code>DMA</code>。动态内存分配器将一个内存的区域（Heao）分为不同的大小的块（block），这些块要不然就是分配的，要不然就是空闲的。</p>
<p>如何设计分配器又是一个大难题。 几乎所有的计算机语言都采用以下两种：</p>
<ol>
<li><p>显式分配器（手动管理内容）</p>
</li>
<li><p>隐式分配器（GC）</p>
</li>
</ol>
<h3 id="隐式内存分配器"><a href="#隐式内存分配器" class="headerlink" title="隐式内存分配器"></a>隐式内存分配器</h3><p>通常比较知名的语言 <code>Java javaScript Ruby</code> 等都使用 GC，最早的 GC<br>只是使用标记清除算法来管理内容，通过几十年的迭代，早已更新出了数种算法共同参与的 GC。这里就不再赘述了。</p>
<h3 id="显式内存分配器"><a href="#显式内存分配器" class="headerlink" title="显式内存分配器"></a>显式内存分配器</h3><p>C 语言提供了一些列的方法来管理动态内存。如</p>
<ol>
<li><p><strong>malloc</strong>  申请内容并返回初始化的内存首地址；</p>
</li>
<li><p><strong>calloc</strong>  同 malloc 一致，并且会将申请到的内存全置为0；</p>
</li>
<li><p><strong>realloc</strong>  重新分配原本已经申请的内存空间；</p>
</li>
<li><p><strong>free</strong>  释放内容空间；</p>
</li>
<li><p><strong>sbrk</strong>  扩展收缩堆</p>
</li>
</ol>
<h4 id="如何实现一个自己的显式内存分配器"><a href="#如何实现一个自己的显式内存分配器" class="headerlink" title="如何实现一个自己的显式内存分配器"></a>如何实现一个自己的显式内存分配器</h4><p>首先我们要明确内存分配器的需求</p>
<ol>
<li><p>处理任意顺序的申请内存和释放内存；</p>
</li>
<li><p>立即响应，不应为了性能而重新排列或者缓存请求；</p>
</li>
<li><p>所有内容都在 heap 里存放；</p>
</li>
<li><p>对齐块，使之可以存放任意类型的数据；</p>
</li>
<li><p>不修改已分配的内存块；</p>
</li>
</ol>
<p>鉴于对齐和处理任意顺序内存管理的需求，堆利用效率可能会降低，主要会产生内存碎片(Fragmentation) 。内存碎片分为两种：</p>
<ol>
<li><p><strong>内部碎片</strong> ：通常是指一个分配过的块数据并不是全部块的内容，通常有元信息，对齐的字节等；</p>
</li>
<li><p><strong>外部碎片</strong> ：是指不连续的可用的块，通常外部碎片过多会产生所有空白块相加可以满足申请的资源，但是他们不连续。需要整理碎片。</p>
</li>
</ol>
<h4 id="实现显式内存分配器的重点"><a href="#实现显式内存分配器的重点" class="headerlink" title="实现显式内存分配器的重点"></a>实现显式内存分配器的重点</h4><ol>
<li><p>空闲块组织</p>
</li>
<li><p>如何分配新申请的块</p>
</li>
<li><p>如何组织空闲快的剩余部分</p>
</li>
<li><p>如何合并刚释放的块</p>
</li>
</ol>
<h4 id="显式内存分配器的实现方案"><a href="#显式内存分配器的实现方案" class="headerlink" title="显式内存分配器的实现方案"></a>显式内存分配器的实现方案</h4><h5 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h5><p>这种方式在 malloc<br>申请内存的时候，实际上申请的是实际所需内存加上部门元信息大小的块，然后返回指针是有效数据的首地址，元信息直接存在数据块中，所以称为隐式空闲链表。</p>
<p>隐式链表需要处理如何分割空闲块和合并空闲块。</p>
<h5 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h5><p>由于隐式空闲链表的搜索效率较低，其实是不适用通用的内存分配的。可以使用某种形式的数据结构去管理这些内存块。基本分为几种：</p>
<ol>
<li><p>简单分离器存储</p>
</li>
<li><p>分离适配法</p>
</li>
<li><p>伙伴系统法</p>
</li>
</ol>
<p>关于详细的设计需要读者查看更多算法知识的文档。</p>
<h4 id="显式内存分配器的实现"><a href="#显式内存分配器的实现" class="headerlink" title="显式内存分配器的实现"></a>显式内存分配器的实现</h4><p>显式内存分配器的需求已经很清晰，下面有个简单的例子可以参考，这时候对于 C 类语言的内存管理应该不会太过恐惧了，</p>
<ul>
<li><strong>C++实现一个简易的内存池分配器</strong> <a href="https://blog.csdn.net/oyoung_2012/article/details/78874869" target="_blank" rel="external">https://blog.csdn.net/oyoung_2012/article/details/78874869</a></li>
</ul>
<p>毕竟源码面前了无秘密。</p>
<h2 id="iOS的虚拟内存"><a href="#iOS的虚拟内存" class="headerlink" title="iOS的虚拟内存"></a>iOS的虚拟内存</h2><h3 id="iOS-内存的分页大小"><a href="#iOS-内存的分页大小" class="headerlink" title="iOS 内存的分页大小"></a>iOS 内存的分页大小</h3><p>在 arm64 之后的芯片，操作系统通常使用 16KB 作为页大小，我们写的程序中的虚拟内存地址右移动 14位 则可得到页编号。MMU 通过 TLB<br>和固定在内存进程虚拟区域的页表来翻译来物理地址。</p>
<p>下面一份代码可以获取页大小。</p>
<pre><code>int main(int argc, char * argv[]) {  
    //    获取虚拟内存分页数据 14为页内地址  
    printf(&quot;page-size%ld mask:%ld, shift%d \n&quot;, vm_kernel_page_size, vm_kernel_page_mask, vm_kernel_page_shift);  
    printf(&quot;%ld\n&quot;, sysconf(_SC_PAGE_SIZE));  
    printf(&quot;%d\n&quot;, getpagesize());  
    printf(&quot;%d\n&quot;, PAGE_SIZE); // 编译时确定不建议使用  
    return 0;  
}  
</code></pre><p>在观察 Crash 日志的时候，有时候注意崩溃的页号可以帮助我们寻找崩溃的原因。</p>
<h3 id="页面的类型"><a href="#页面的类型" class="headerlink" title="页面的类型"></a>页面的类型</h3><p>当操作系统分配一个页面时，内存被称为 <code>Clean</code> 的，表示这个内存页面没有使用，是可以被释放或者重建的，但是一旦写入，操作系统会将其标记为<br><code>Dirty</code>，这意味着磁盘或者其他地方没有此内存页面的备份，无法恢复它。</p>
<p>由于 iPhone 设备为了减少闪存的寿命，并没有在闪存上使用交换分区，因此无论使用多少，在内存压力高紧时，操作系统不会将 Dirty 写好磁盘，而是释放<br>Clean 的页面。如可执行代码（Mach-O）的映射和内存映射文件，或者是 kill 掉进程。</p>
<p>因此使用 dirty 的内存越多，对我们的进程的稳定性越差。</p>
<h4 id="iOS-内存的优化"><a href="#iOS-内存的优化" class="headerlink" title="iOS 内存的优化"></a>iOS 内存的优化</h4><p>在其他常见的操作系统上，由于局部性原理，OS 会将不常用的内存页面写入磁盘，但是 iOS 没有交换空间，取而代之的是内存压缩技术。iOS 将不常用到的<br>dirty 页面压缩以减少页面占用量，在再次访问到的时候重新解压缩。这些都在操作系统层面实现，对进程无感知，有趣的是如果当前进程收到了<br><code>memoryWarning</code>，进程这时候准备释放大量的误用内存，如果访问到过多的压缩内存，再解压缩内存的时候反而会导致内存压力更大，然后被 OS kill<br>掉。</p>
<h3 id="iOS-进程中的堆和栈"><a href="#iOS-进程中的堆和栈" class="headerlink" title="iOS 进程中的堆和栈"></a>iOS 进程中的堆和栈</h3><p>需要注意的是通常操作系统书籍中描述的进程虚拟内存模型都是这样的</p>
<p>Process Virtual Memory</p>
<p>这实际是个用于解析给读者的简化模型，对于多线程程序来说，每个线程都有自己的线程栈。在iOS上通常主线程线程栈大小为 1MB，子线程栈大小为<br>512KB，如果你有一台越狱机，可以试验 <code>ulimt -a</code> 命令观察栈大小的默认参数。</p>
<h3 id="iOS平台上的常见编程语言的内存管理方式"><a href="#iOS平台上的常见编程语言的内存管理方式" class="headerlink" title="iOS平台上的常见编程语言的内存管理方式"></a>iOS平台上的常见编程语言的内存管理方式</h3><p>iOS 上常用的 Swift、Objective-C、C、C++ 都使用显式的内存管理策略，比如 malloc 和 free，new 和<br>delete，alloc 和 dealloc。在 Objective-C 和 Swift 通常使用一种叫做引用计数的简化模型来管理堆内存。现代 Clang<br>已经支持 ARC 的技术帮助程序员解脱内存管理的困扰，但是本质上还是显式内存管理。</p>
<p>建议读者可以读一下 <code>ARC的参考文档</code><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html" target="_blank" rel="external">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a></p>
<p>顺便提一下 Xcode10 版本中的 Clang 已经支持在 C 结构体中对于 Objective-C 对象的 ARC 管理，请参看<br><code>whats_new_in_llvm</code></p>
<h3 id="内存分类"><a href="#内存分类" class="headerlink" title="内存分类"></a>内存分类</h3><p>要想合理的使用内存，必须要掌握不同类型内存的区别，才能更合理的使用内存并且在内存资源匮乏的低端机器上写出“高内存性能”的应用。</p>
<p>首先在 Apple 的官方文档中内存主要分为以下几类。</p>
<ol>
<li><p><strong>Free Memory</strong>  当前空闲的memory</p>
</li>
<li><p><strong>Used Mamory</strong>  当前正在使用的内存</p>
</li>
</ol>
<p>我们最关心的当然是 Used Memory，它又分为以下几类。</p>
<ol>
<li><p><strong>Wired Memory</strong> ：一般是内核占用的常驻内存，比如可执行文件的镜像 Image，内核所有的数据等，无法释放，在OS运行期间必须常驻内存；</p>
</li>
<li><p><strong>Active Memory</strong>  活跃的内存，当前正在使用的内存；</p>
</li>
<li><p><strong>Inactive Memory</strong>  不活跃的内存，最近用过，但是现在不怎么用了，按照局部性原则可以被置换出物理内存的内存；</p>
</li>
<li><p><strong>Purgeable Memory</strong>  可释放的内存，通常在 Foundation 中是 <code>NSDiscardableContent</code> 的子类，或者是 <code>NSCache</code> 等。</p>
</li>
</ol>
<p>等等~。上面说的好像跟没说一样/(ㄒoㄒ)/~~。我们换种方式从物理内存和虚拟内存的层面来解释。</p>
<hr>
<p>首先我们的虚拟内存使用的是 Page 来描述的。一个 Page 有两种状态 Dirty 和 Clean。在 iOS 中 Clean 是可以被回收的。</p>
<h4 id="Virtual-Memory-分类"><a href="#Virtual-Memory-分类" class="headerlink" title="Virtual Memory 分类"></a>Virtual Memory 分类</h4><ol>
<li><p><strong>Clean Memory</strong>  主要包括 system framework、binary executable 、memory mapped files</p>
</li>
<li><p><strong>Dirty Memory</strong>  包括 Heap allocation、caches、decompressed images 等。</p>
</li>
</ol>
<p>(每个进程拥有一份独立的 Virtual memory pace) Virtual Memory = clean Memory</p>
<h4 id="PhySical-Memory"><a href="#PhySical-Memory" class="headerlink" title="PhySical Memory"></a>PhySical Memory</h4><p>物理内存是指真正加载在主存中的内存，所以实际了解真正的物理内存占用才对我们内存管理帮助更大。</p>
<ol>
<li><p>DirtyMemory</p>
</li>
<li><p>Clean Memory but loaded。</p>
</li>
<li><p>Page Table</p>
</li>
<li><p>ComPressed memory</p>
</li>
<li><p>IOKit Used</p>
</li>
<li><p>Purgeable</p>
</li>
</ol>
<h3 id="内存测量工具"><a href="#内存测量工具" class="headerlink" title="内存测量工具"></a>内存测量工具</h3><p>了解到前面说的内存分类之后我们应该怎么测量我们的内存分布呢。主要有几种工具：命令行工具、Xcode工具、代码工具等。</p>
<h4 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h4><p>如果你开发的是 Mac 程序，Mac OS 自带的有一下几种。</p>
<ol>
<li><p>top 程序</p>
</li>
<li><p>heap 程序</p>
</li>
<li><p>leaks 程序</p>
</li>
<li><p>vmmap 程序</p>
</li>
</ol>
<p>这些工具读者查看 Man Page 即可。</p>
<p>需要注意的是。以上工具分析的大多是虚拟内存，也就是说对于桌面级程序更适合，但是对于 iOS 中没有交换空间，且拥有 Jetsam<br>监控程序的设备，可能还需要更精准的测量工具。</p>
<p>顺便提一句。一个堆区上 malloc 的程序如果并没有使用，虽然它是 Clean 的，但是也会被程序统计到。理论上 malloc<br>可以申请到的虚拟内存大小非常接近 <code>Virtual Memory Space</code> 的大小（这么说的原因是 前文也提到了 malloc<br>实际上是动态分配器程序提供的一些列函数，为了性能，大多数动态分配器都讲堆分为好几块用来做不同大小虚拟内存的管理，因此malloc可以申请到的虚拟内存大小实际决定于动分配器代码的实现。有兴趣的读者可以读一下。)</p>
<h4 id="Xcode-提供的工具"><a href="#Xcode-提供的工具" class="headerlink" title="Xcode 提供的工具"></a>Xcode 提供的工具</h4><ol>
<li><p>Xcode Debug Area</p>
</li>
<li><p>Instruments</p>
</li>
<li><p>DebugMemoryGraph</p>
</li>
</ol>
<p>Memory Report</p>
<p>instruments</p>
<p>DebugMemoryGraph</p>
<p>Scheme</p>
<blockquote>
<p>Tips：配置了 <code>MallocStackLogging</code> 的话甚至可以追踪每个虚拟内存中的对象申请堆栈，便于我们更好的发现问题。</p>
</blockquote>
<p> <strong>注意点：所有Xcode提供的工具必须使用真机测试才能最难接近用户的使用环境</strong></p>
<h4 id="代码工具"><a href="#代码工具" class="headerlink" title="代码工具"></a>代码工具</h4><p>我们通过开发工具可以用来测量我们的内存，但是到了线上这些都用不了，能精准的测量 APP 用到的物理内存才比较重要。</p>
<p>大部分的代码测量内存是通过拿到 Mach 内核提供的 <code>task_info</code> 来测量的，但是这个信息更多的是虚拟内存层面的信息，不能正确的衡量物理内存。</p>
<pre><code>#include &lt;malloc/malloc.h&gt;  
#include &lt;mach/mach_host.h&gt;  
#include &lt;mach/task.h&gt;  

int main(int argc, char * argv[]) {  
    @autoreleasepool {  
        // method 1  
        struct mstats currentStat = mstats();  
        printf(&quot;Freed Bytes:%ld, Used Bytes:%ld Total Bytes:%ld&quot;, currentStat.bytes_free, currentStat.bytes_used, currentStat.bytes_total);  
        // method 2  
        vm_statistics_data_t vmStats;  
        mach_msg_type_number_t infoCount = HOST_VM_INFO_COUNT;  
        kern_return_t kernReturn = host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmStats, &amp;infoCount);  
        printf(&quot;free: %lu\nactive: %lu\ninactive: %lu\nwire: %lu\nzero fill: %lu\nreactivations: %lu\npageins: %lu\npageouts: %lu\nfaults: %u\ncow_faults: %u\nlookups: %u\nhits: %u&quot;,  
              vmStats.free_count * vm_page_size,  
              vmStats.active_count * vm_page_size,  
              vmStats.inactive_count * vm_page_size,  
              vmStats.wire_count * vm_page_size,  
              vmStats.zero_fill_count * vm_page_size,  
              vmStats.reactivations * vm_page_size,  
              vmStats.pageins * vm_page_size,  
              vmStats.pageouts * vm_page_size,  
              vmStats.faults,  
              vmStats.cow_faults,  
              vmStats.lookups,  
              vmStats.hits  
              );  
        // method3  
        task_basic_info_data_t taskInfo;  
        infoCount = TASK_BASIC_INFO_COUNT;  
        kernReturn = task_info(mach_task_self(),  
                                             TASK_BASIC_INFO,  
                                             (task_info_t)&amp;taskInfo,  
                                             &amp;infoCount);  

        if (kernReturn == KERN_SUCCESS) {  
            printf(&quot;resdientSize is :%ld&quot;, taskInfo.resident_size);  
        }  
        return 0;  
    }  
}  
</code></pre><p>其中尤其是和 Xcode Debug Area 的差距较大，有时候可能会偏差 <code>50M-100M</code>，于是有大佬拔出了 Xcode 的<br><code>DebugServer</code> 和 <code>WebKit</code> 中的的物理内存计算方式（2018WWDC 苹果也说了 footPrint才是真正的物理内存使用<br><code>ios_memory_deep_dive</code>）</p>
<p>代码如下</p>
<pre><code>std::optional&lt;size_t&gt; memoryFootprint()  
{  
    task_vm_info_data_t vmInfo;  
    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;  
    kern_return_t result = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &amp;vmInfo, &amp;count);  
    if (result != KERN_SUCCESS)  
        return std::nullopt;  
    return static_cast&lt;size_t&gt;(vmInfo.phys_footprint);  
}  
</code></pre><h4 id="线上检查工具"><a href="#线上检查工具" class="headerlink" title="线上检查工具"></a>线上检查工具</h4><p>线上检查内存通常会检查内存泄漏，一般有开源的工具</p>
<ol>
<li><p>MLeaksFinder</p>
</li>
<li><p>FBRetainCycleDetector</p>
</li>
</ol>
<h3 id="高性能使用内存"><a href="#高性能使用内存" class="headerlink" title="高性能使用内存"></a>高性能使用内存</h3><p>了解完那么多原理和分析的工具，那么在日常使用中有没有什么指导原则可以帮助我们来写出更快，内存占用更低的代码呢？</p>
<ol>
<li><p>首先熟读 <code>ARCMenual</code>，大部分 iOS 开发者其实是完全不清楚 ARC 是怎么实现的，还有相对于的原则，尤其是 Autorelease 修饰的指针，还有在多线程情况下的原则。</p>
</li>
<li><p>用 <code>weak</code> 修饰替换 <code>unsafe_unretain</code></p>
</li>
<li><p>使用 <code>weak strong dance</code> 来解决 block 中的循环引用问题。需要注意的是大部分人都以为使用了 weak 指针就可以了。其实不然，在block 内必须使用 strong 重新绑定变量，避免在多线程情况下 <code>weak</code> 变量为空导致 Crash，使用 strong 指针前判断是否为空</p>
</li>
</ol>
<p>例：</p>
<pre><code>- (void)test {  
    weak __typeof(self) weakSelf = self;  
    [xxobjc onCompleate:^(){  
        strong __typeof(self) self = weakSelf;  
        if (!self) { return; }  
        [xx moreCompleate:&amp;(){  
            strong __typeof(self) self = weakSelf;  
            if (!self) { return; }  
            // do something  
        }];  
    }];  
}  
</code></pre><ol>
<li><p>小心方法中的self，在 Objective-C的方法中 隐含的 self 是 <code>__unsafed_unretain</code> 的；</p>
</li>
<li><p>使用 <code>Autoreleasepool</code> 来降低循环中的内存峰值，避免 OOM；</p>
</li>
<li><p>要处理 <code>Memory Warning</code>；</p>
</li>
<li><p>C/C++ new 出来的要 delete，malloc 的要 free；</p>
</li>
<li><p>UITableView/UICollectionView 的重用（不单单是cell重用，cell 使用的子view也要重用。）；</p>
</li>
<li><p>[UIImage imageNamed:] 适合于 UI 界面中的贴图的读取，较大的资源文件应该尽量避免使用；</p>
</li>
<li><p>WKWebView 是跨进程通信的，不会占用我们的 APP 使用的物理内存量；</p>
</li>
<li><p><code>try_catch_finally</code> 一定要清理资源；</p>
</li>
<li><p>尽量少引用 <code>performaSelector:</code> 会对 ARC 的内存管理产生错误，导致内存泄漏；</p>
</li>
<li><p>lazy load 那些大的内存对象，尤其是需要保证线程安全，可以参考 java 中的懒汉式 <code>Double Check</code> 写法；</p>
</li>
<li><p>需要在收到内存警告的时候释放的 Cache，用 NSCache 代替 NSDictionary，使用 NSPurgableData 代替NSData.</p>
</li>
</ol>
<p>前文中我们说到 iOS 的没有交换分区的概念，取而代之的是压缩内存的办法，倘若在使用 NSDictionary<br>的时候收到内存警告，然后去释放这个NSDictionary，如果占据的内存过大，很可能在解压的过程中就被 JetSem Kill<br>掉，如果你的内存只是误用的缓存或者是可重建的数据，就把 NSCache 当初 NSDictionary 用吧。同理 NSPurableData 也是。</p>
<ol>
<li><p>不要使用像素过大的图片文件，即便一个图片在磁盘中很小，但是因为图片像素宽高很大也会占据更多的内存，这里有个公式可以计算<code>widthPx * HeightPx * 4Bytes per pixel(alpha red green blue)</code>。即便在 iOS 12 中已经可以优化单色图的内存占用，可毕竟是 iOS 12，现在好多公司还在支持iOS8 ~~</p>
</li>
<li><p>使用 NSData 和 UIImage 的 mmap 加载选型来加载那些可以被重建的数据；</p>
</li>
<li><p>在子线程手动申请（maloc）大内存的的时候 ping 一下主线程，因为子线程无法收到内存警告的传递；</p>
</li>
</ol>
<pre><code>- (void)test {  
    // current on sub Thread  
    // if main thread is memory warning it will blocked  
    dispatch_sync(dispatch_get_main_queue(), ^{  
        [some description]  
    });  
    malloc(huge memory);  
}  
</code></pre>
            
        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Objective-C/">Objective-C</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/10/27/【转】iOS系统中导航栏的转场解决方案与最佳实践/"  data-tooltip="【转】iOS系统中导航栏的转场解决方案与最佳实践">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/07/22/AVFoundation之AVAudioRecorder/" data-tooltip="AVFoundation之AVAudioRecorder">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://v.t.sina.com.cn/share/share.php?url=https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/&amp;title=【转】iOS Memory Deep Dive">
                <i class="fa fa-weibo"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/">
                <i class="fa fa-qq"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default"  href="javascript:show();" >
                <i class="fa fa-wechat (alias)"></i>
            </a>
        </li>
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>
<div id="jiathis_weixin_modal" style="z-index:1000;display:none; background-clip: padding-box;background-color: #FFFFFF;border: 1px solid rgba(0, 0, 0, 0.3);  border-radius: 6px 6px 6px 6px;  box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); left: 50%; margin: -200px 0 0 -200px;overflow: hidden; position: fixed; top: 50%; width:360px;height:370px; overflow:hidden;" class="jiathis_weixin_modal"><div class="jiathis_modal_header" id="jiathis_modal_header" style="border-bottom: 1px solid #EEEEEE; padding: 9px 15px;"><a style="text-decoration:none;  margin-top: 2px; color: #000000; float: right;  font-size: 20px;  font-weight: bold; cursor:pointer;line-height: 20px; opacity: 0.2; text-shadow: 0 1px 0 #FFFFFF;" class="jiathis_weixin_close" id="jiathis_weixin_close" href="javascript:hidden();" target="_self">×</a><h3 id="jiathis_weixin_h3" style=" line-height: 30px; margin: 0; font-weight:normal; font-family:" 微软雅黑";"="">分享到微信朋友圈</h3></div><div class="jiathis_modal_body" id="jiathis_modal_body" style="text-align:center;height:251px;"><p id="jiathis_webchat"><img alt="二维码加载失败..." style="margin-top: 15px;" src="http://b.bshare.cn/barCode?site=weixin&amp;url=https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/" height="220" width="220"></p></div><div class="jiathis_modal_footer" id="jiathis_modal_footer" style="border-radius: 0 0 6px 6px; border-top: 1px solid #DDDDDD; box-shadow: 0 1px 0 #FFFFFF inset; height:100%;padding:0 10px;padding-top:11px;text-align: right; font-size:12px;"><div id="jiathis_weixin_tip" style="text-align:left;margin:0; padding:0;font-size:12px;background-color: #FFFFFF;">打开微信，点击底部的“发现”，使用 “扫一扫” 即可将网页分享到我的朋友圈。</div></div></div>

<script charset="utf-8">
    function show(){
        $("#jiathis_weixin_modal").css("display", "block")
    }
    function hidden(){
        $("#jiathis_weixin_modal").css("display", "none")
    } 
</script>







        
            
                
<div class="duoshuo">
<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script>
var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: "3b1a42e3f91145d197b9e8b6e2f2a144",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>
</div>



            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 贵永冬. All Rights Reserved.
    </span>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/10/27/【转】iOS系统中导航栏的转场解决方案与最佳实践/"  data-tooltip="【转】iOS系统中导航栏的转场解决方案与最佳实践">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/07/22/AVFoundation之AVAudioRecorder/" data-tooltip="AVFoundation之AVAudioRecorder">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://v.t.sina.com.cn/share/share.php?url=https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/&amp;title=【转】iOS Memory Deep Dive">
                <i class="fa fa-weibo"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/">
                <i class="fa fa-qq"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default"  href="javascript:show();" >
                <i class="fa fa-wechat (alias)"></i>
            </a>
        </li>
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>
<div id="jiathis_weixin_modal" style="z-index:1000;display:none; background-clip: padding-box;background-color: #FFFFFF;border: 1px solid rgba(0, 0, 0, 0.3);  border-radius: 6px 6px 6px 6px;  box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); left: 50%; margin: -200px 0 0 -200px;overflow: hidden; position: fixed; top: 50%; width:360px;height:370px; overflow:hidden;" class="jiathis_weixin_modal"><div class="jiathis_modal_header" id="jiathis_modal_header" style="border-bottom: 1px solid #EEEEEE; padding: 9px 15px;"><a style="text-decoration:none;  margin-top: 2px; color: #000000; float: right;  font-size: 20px;  font-weight: bold; cursor:pointer;line-height: 20px; opacity: 0.2; text-shadow: 0 1px 0 #FFFFFF;" class="jiathis_weixin_close" id="jiathis_weixin_close" href="javascript:hidden();" target="_self">×</a><h3 id="jiathis_weixin_h3" style=" line-height: 30px; margin: 0; font-weight:normal; font-family:" 微软雅黑";"="">分享到微信朋友圈</h3></div><div class="jiathis_modal_body" id="jiathis_modal_body" style="text-align:center;height:251px;"><p id="jiathis_webchat"><img alt="二维码加载失败..." style="margin-top: 15px;" src="http://b.bshare.cn/barCode?site=weixin&amp;url=https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/" height="220" width="220"></p></div><div class="jiathis_modal_footer" id="jiathis_modal_footer" style="border-radius: 0 0 6px 6px; border-top: 1px solid #DDDDDD; box-shadow: 0 1px 0 #FFFFFF inset; height:100%;padding:0 10px;padding-top:11px;text-align: right; font-size:12px;"><div id="jiathis_weixin_tip" style="text-align:left;margin:0; padding:0;font-size:12px;background-color: #FFFFFF;">打开微信，点击底部的“发现”，使用 “扫一扫” 即可将网页分享到我的朋友圈。</div></div></div>

<script charset="utf-8">
    function show(){
        $("#jiathis_weixin_modal").css("display", "block")
    }
    function hidden(){
        $("#jiathis_weixin_modal").css("display", "none")
    } 
</script>







                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <ul class="share-options">
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/">
                <i class="fa fa-weibo"></i><span>微博</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/">
                <i class="fa fa-qq"></i><span>QQ</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn"  href="javascript:show();" >
                <i class="fa fa-wechat (alias)"></i><span>微信</span>
            </a>
        </li>
    </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>



<div id="jiathis_weixin_modal" style="display:none; background-clip: padding-box;background-color: #FFFFFF;border: 1px solid rgba(0, 0, 0, 0.3);  border-radius: 6px 6px 6px 6px;  box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); left: 50%; margin: -200px 0 0 -200px;overflow: hidden; position: fixed; top: 50%; width:360px;height:370px; overflow:hidden;" class="jiathis_weixin_modal"><div class="jiathis_modal_header" id="jiathis_modal_header" style="border-bottom: 1px solid #EEEEEE; padding: 9px 15px;"><a style="text-decoration:none;  margin-top: 2px; color: #000000; float: right;  font-size: 20px;  font-weight: bold; cursor:pointer;line-height: 20px; opacity: 0.2; text-shadow: 0 1px 0 #FFFFFF;" class="jiathis_weixin_close" id="jiathis_weixin_close" href="javascript:hidden();" target="_self">×</a><h3 id="jiathis_weixin_h3" style=" line-height: 30px; margin: 0; font-weight:normal; font-family:" 微软雅黑";"="">分享到微信朋友圈</h3></div><div class="jiathis_modal_body" id="jiathis_modal_body" style="text-align:center;height:251px;"><p id="jiathis_webchat"><img alt="二维码加载失败..." style="margin-top: 15px;" src="http://pan.baidu.com/share/qrcode?url=https://guiyongdong.github.io/2018/10/16/【转】iOS-Memory-Deep-Dive/" height="220" width="220"></p></div><div class="jiathis_modal_footer" id="jiathis_modal_footer" style="border-radius: 0 0 6px 6px; border-top: 1px solid #DDDDDD; box-shadow: 0 1px 0 #FFFFFF inset; height:100%;padding:0 10px;padding-top:11px;text-align: right; font-size:12px;"><div id="jiathis_weixin_tip" style="text-align:left;margin:0; padding:0;font-size:12px;background-color: #FFFFFF;">打开微信，点击底部的“发现”，使用 “扫一扫” 即可将网页分享到我的朋友圈。</div></div></div>

<script charset="utf-8">
    function show(){
        $("#jiathis_weixin_modal").css("display", "block")
    }
    function hidden(){
        $("#jiathis_weixin_modal").css("display", "none")
    } 
</script>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/header.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">贵永冬</h4>
        
            <div id="about-card-bio"><p>iOS开发者<br> 会一点RN和android,  十足的海贼迷</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>河南信悦通网络科技有限公司</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                河南 郑州
            </div>
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/08/11/初识ReactiveCocoa/">
                            <h3 class="media-heading">初识ReactiveCocoa</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年8月11日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>(简称为RAC), 是由Github开源的一个应用于iOS和OS开发的新框架, RAC具有函数式编程和响应式编程的特性, 通过这篇文章对RAC有一个简单的了解。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/08/12/深入ReactiveCocoa/">
                            <h3 class="media-heading">深入ReactiveCocoa</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年8月12日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>(简称为RAC),上一篇文章，我们简单的对RAC有个初步的了解，在开发中，我们实际用到的基本都是上一篇所介绍的知识，这篇文章我们对RAC有个深入的了解。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/06/ReactiveCocoa和RXSwift速查表/">
                            <h3 class="media-heading">ReactiveCocoa和RXSwift速查表</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>在接触了RAC以后,对RAC有了一个基本的了解，这里整理了一下RAC脑图，方便日后查看。ps(<a href="https://github.com/aiqiuqiu/FRPCheatSheeta">转载</a>)</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/06/关于RAC的一些资料/">
                            <h3 class="media-heading">关于RAC的一些资料</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>看了这么多RAC资料，在这里我整理了一下，以备学习。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/08/RunLoop总结/">
                            <h3 class="media-heading">RunLoop总结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月8日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>最近研究了一下RunLoop，在这里对RunLoop做一个总结，主要是对<code>&lt;CoreFoundation/CFRunLoop.h&gt;</code>的头文件函数总结。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/13/聊一聊GCD的那些事/">
                            <h3 class="media-heading">聊一聊GCD的那些事</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月13日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/18/聊一聊NSOperation的那些事/">
                            <h3 class="media-heading">聊一聊NSOperation的那些事</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月18日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>在iOS开发中，多线程技术用到最多的就是GCD和NSOperation，上一篇文章已经对GCD有了全面的了解，这篇文章简单的聊一聊NSOperation。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/21/iOS动画篇-transfrom/">
                            <h3 class="media-heading">iOS动画篇之UIView动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月21日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/22/iOS动画篇之CoreAnimation动画/">
                            <h3 class="media-heading">iOS动画篇之CoreAnimation动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>App如果想被大众喜欢，漂亮的UI和精美的动画都是必不可少的，苹果虽然为UIView提供了一些常用动画，但是大部分看起来比较不错的效果都是通过操作Layer层实现的，因此了解核心动画是必要的.CoreAnimation是直接作用在CALayer上的(并非UIView上)非常强大的跨Mac OS X和iOS平台的动画处理API，Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/22/iOS动画之CATransition动画/">
                            <h3 class="media-heading">iOS动画之CATransition动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>今天主要用到的动画类是CALayer下的CATransition至于各种动画类中如何继承的在这也不做赘述，网上的资料是一抓一大把。好废话少说切入今天的正题。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 61 篇文章
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-rt08quwts7iav5x0cfd2ym0gb5qkd1lvrsmwrakxtkhefmaaes4ywkmnjnwf.min.js"></script>
<script src="/assets/js/prism.js"></script>
<!--SCRIPTS END-->

    
        <script type="text/javascript">
            var duoshuoQuery = {short_name:'guiyongdong'};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>
    



    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script>
    <script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
    <script>
        var algoliaClient = algoliasearch('DWKE0MOOLY', '141d50cf933ece6dd635747973c4fe00');
        var algoliaIndex = algoliaClient.initIndex('blog');
    </script>

    </body>
</html>
