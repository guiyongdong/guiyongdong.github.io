
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="贵大头的博客">
    <title>归档 - 贵大头的博客</title>
    <meta name="author" content="贵永冬">
<link rel="icon" href="https://github.com/guiyongdong/Resource/blob/master/hexoImage/favicon.ico?raw=true">
    
    
        <link rel="icon" href="https://github.com/guiyongdong/Resource/blob/master/hexoImage/favicon.ico?raw=true">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="iOS开发者">
<meta property="og:type" content="blog">
<meta property="og:title" content="贵大头的博客">
<meta property="og:url" content="https://guiyongdong.github.io/archives/index.html">
<meta property="og:site_name" content="贵大头的博客">
<meta property="og:description" content="iOS开发者">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="贵大头的博客">
<meta name="twitter:description" content="iOS开发者">
    
    
        
    
    
        <meta property="og:image" content="https://guiyongdong.github.io/assets/images/header.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-yrst5vo1nxaxbp2g3v9na2wg1lixlpr3ghbjdvskeixmu79deycecx3rh4bt.min.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">贵大头的博客</a>
    </div>
    
        
            <a  class="header-right-icon "
                href="#about">
        
        
            <i class="fa fa-lg fa-header.jpg"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/header.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">贵永冬</h4>
                
                    <h5 class="sidebar-profile-bio"><p>iOS开发者<br> 会一点RN和android,  十足的海贼迷</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/guiyongdong" target="_blank">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:564024928@qq.com" target="_blank">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">订阅</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/10/27/【转】iOS系统中导航栏的转场解决方案与最佳实践/">
                            【转】iOS系统中导航栏的转场解决方案与最佳实践
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-10-27T19:00:48+08:00">
	
		    10月 27, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <h2 id="【转】iOS系统中导航栏的转场解决方案与最佳实践"><a href="#【转】iOS系统中导航栏的转场解决方案与最佳实践" class="headerlink" title="【转】iOS系统中导航栏的转场解决方案与最佳实践"></a>【转】iOS系统中导航栏的转场解决方案与最佳实践</h2><p> <strong>前言</strong>  </p>
<p>目前，开源社区和业界内已经存在一些 iOS 导航栏转场的解决方案，但对于历史包袱沉重的美团 App<br>而言，这些解决方案并不完美。有的方案不能满足复杂的页面跳转场景，有的方案迁移成本较大，为此我们提出了一套解决方案并开发了相应的转场库，目前该转场库已经成为美团点评多个<br>App 的基础组件之一。</p>
<p>在美团 App<br>开发的早期，涉及到导航栏样式改变的需求时，经常会遇到转场效果不佳或者与预期样式不符的“小问题”。在业务体量较小的情况下，为了满足快速的业务迭代，通常会使用硬编码的方式来解决这一类“小问题”。但随着美团<br>App 业务的高速发展，这种硬编码的方式遇到了以下的挑战：</p>
<ol>
<li><p>业务模块的不断增加，导致使用硬编码方式编写的代码维护成本增加，代码质量迅速下降。</p>
</li>
<li><p>大型 App 的路由系统使得页面间的跳转变得更加自由和灵活，也使得导航栏相关的问题激增，不但增加了问题的排查难度，还降低了整体的开发效率。</p>
</li>
<li><p>App 中的导航栏属于各个业务方的公用资源，由于缺乏相应的约束机制和最佳实践，导致业务方之间的代码耦合程度不断增加。</p>
</li>
</ol>
<p>从各个角度来看，硬编码的方式已经不能很好的解决此类问题，美团 App 需要一个更加合理、更加持久、更加简单易行的解决方案来处理导航栏转场问题。</p>
<p>本文将从导航栏的概念入手，通过讲解转场过程中的状态管理、转换时机和样式变化等内容，引出了在大型应用中导航栏转场的三种常见解决方案，并对美团的解决方案进行剖析，同时介绍了我们总结的最佳实践。</p>
<p> <strong>重新认识导航栏</strong></p>
<h3 id="导航栏里的-MVC"><a href="#导航栏里的-MVC" class="headerlink" title="导航栏里的 MVC"></a><strong>导航栏里的 MVC</strong></h3><p>在 iOS 系统中， 苹果公司不仅建议开发者遵循 MVC 开发框架，在他们的代码里也可以看到 MVC 的影子，导航栏组件的构成就是一个类似 MVC<br>的结构，让我们先看看下面这张图：</p>
<p>在这张图里，我们可以将 UINavigationController 看做是 C，UINavigationBar 看做是 V，而<br>UIViewController 和 UINavigationItem 组成的 Stack 可以看做是 M。这里要说明的是，每个<br>UIViewController 都有一个属于自己的 UINavigationItem，也就是说它们是一一对应的。</p>
<p>UINavigationController 通过驱动 Stack 中的 UIViewController 的变化来实现 View 层级的变化，也就是<br>UINavigationBar 的改变。而 UINavigationBar 样式的数据就存储在 UIViewController 的<br>UINavigationItem 中。这也就是为什么我们在代码里只要设置 <code>self.navigationItem</code> 的相关属性就可以改变<br>UINavigationBar 的样式。</p>
<p>很多时候，国内的开发者会将 UINavigationBar 和 UINavigationController<br>混在一起叫导航栏，这样的做法不仅增加了开发者之间的沟通成本，也容易导致误解。毕竟它们是两个完全不一样的东西。</p>
<p>所以本文为了更好的阐明问题，会采用英文区分不同的概念，当需要描述笼统的导航栏概念时，会使用导航栏组件一词。</p>
<p>通过这一节的回顾，我们应该明确了 NavigationItem、ViewController、NavigationBar 和<br>NavigationController 在 MVC 框架下的角色。下面我们会重新梳理一下导航栏的生命周期和各个相关方法的调用顺序。</p>
<h3 id="导航栏组件的生命周期"><a href="#导航栏组件的生命周期" class="headerlink" title="导航栏组件的生命周期"></a><strong>导航栏组件的生命周期</strong></h3><p>大家可以通过下图获得更为直观的感受，进而了解到导航栏组件在 push 过程中各个方法的调用顺序。</p>
<p>值得注意的地方有两点：</p>
<p>第一个是 UINavigationController 作为 UINavigationBar<br>的代理，在没有特殊需求的情况下，不应该修改其代理方法，这里是通过符号断点获取它们的调用顺序。如果我们创建了一个自定义的导航栏组件系统，它的调用顺序可能会与此不同。</p>
<p>第二个是用虚线圈起来的方法，它们也有可能不被调用，这与 ViewController<br>里的布局代码相关，假设跳转到新页面后，新旧页面中的控件位置会发生变化，或者由于数据改变驱动了控件之间的约束关系发生变化，这就会带来新一轮的布局，进而触发<br><code>viewWillLayoutSubview</code> 和 <code>viewDidLayoutSubview</code><br>这两个方法。当然，具体的调用顺序会与业务代码紧密相关，如果我们发现顺序有所不同，也不必惊慌。</p>
<p>下面这张图展示了导航栏在 pop 过程中各个方法的调用顺序：</p>
<p>除了上面说到的两点，pop 过程中还需要注意一点，那就是从 B 返回到 A 的过程中，A 视图控制器的 viewDidLoad<br>方法并不会被调用。关于这个问题，只要提醒一下，大多数人都会反应过来是为什么。不过在实际开发过程中，总会有人忘记这一点。</p>
<p>通过这两个图，我们已经基本了解了导航栏组件的生命周期和相关方法的调用顺序，这也是后面章节的理论基础。</p>
<h3 id="导航栏组件的改变与革新"><a href="#导航栏组件的改变与革新" class="headerlink" title="导航栏组件的改变与革新"></a><strong>导航栏组件的改变与革新</strong></h3><p>导航栏组件在 iOS 11 发布时，获得了重大更新，这个更新可不是增加了一个大标题样式（Large Title Display<br>Mode）那么简单，需要注意的地方大概有两点：</p>
<ol>
<li><p>导航栏全面支持 Auto Layout 且 NavigationBar 的层级发生了明显的改变，关于这一点可以阅读 <a href="http://sketchk.xyz/2018/02/23/How-to-make-your-UIBarButtonItem-perfect-match-in-iOS/" target="_blank" rel="external">UIBarButtonItem 在 iOS 11 上的改变及应对方案</a> 。</p>
</li>
<li><p>由于引进了 Safe Area 等概念，topLayoutGuide 和 bottomLayoutGuide 等属性会逐渐废弃，虽然变化不大，但如果我们的导航栏在转场过程中总是出现视图上下移动的现象，不妨从这个方面思考一下，如果想深究可以查看 <a href="https://developer.apple.com/videos/play/wwdc2017/412/" target="_blank" rel="external">WWDC 2017 Session 412</a>。</p>
</li>
</ol>
<h2 id="导航栏组件到底怎么了？"><a href="#导航栏组件到底怎么了？" class="headerlink" title="导航栏组件到底怎么了？"></a><strong>导航栏组件到底怎么了？</strong></h2><p>经常有人说 iOS 的原生导航栏组件不好使用，抱怨主要集中在导航栏组件的状态管理和控件的布局问题上。</p>
<p>控件的布局问题随着 iOS 11 的到来已经变得相对容易处理了不少，但导航栏组件的状态管理仍然让开发者头疼不已。</p>
<p>可能已经有朋友在思考导航栏组件的状态管理到底是什么东西？不要着急，下面的章节就会做相关的介绍。</p>
<h3 id="导航栏的状态管理"><a href="#导航栏的状态管理" class="headerlink" title="导航栏的状态管理"></a><strong>导航栏的状态管理</strong></h3><p>虽然导航栏组件的 push 和 pop 动画给人一种每次操作后都会创建一遍导航栏组件的错觉，但实际上这些 ViewController 都是由一个<br>NavigationController 所管理，所以你看到的 NavigationBar 是唯一的。</p>
<p>在 NavigationController 的 Stack 存储结构下，每当 Stack 中的 ViewController 修改了导航栏，势必会影响其他<br>ViewController 展示的效果。</p>
<p>例如下图所示的场景，如果 NavigationBar 原先的颜色是绿色，但之后进入 Stack 里的 ViewController 将<br>NavigationBar 颜色修改为紫色后，在此之后 push 的 ViewController 会从默认的绿色变为紫色，直到有新的<br>ViewController 修改导航栏颜色才会发生变化。</p>
<p>虽然在 push 过程中，NavigationBar 的变化听起来合情合理，但如果你在 NavigationBar 为绿色的 ViewController<br>里设置不当的话，那么当你 pop 回这个 ViewController 时，NavigationBar 可就不一定是绿色了，它还会保持为紫色的状态。</p>
<p>通过这个例子，我们大概会意识到在导航栏里的 Stack 中，每个 ViewController<br>都可以永久的影响导航栏样式，这种全局性的变化要求我们在实际开发中必须坚持“谁修改，谁复原”的原则，否则就会造成导航栏状态的混乱。这不仅仅是样式上的混乱，在一些极端状况下，还有可能会引起<br>Stack 混乱，进而造成 Crash 的情况。</p>
<h3 id="导航栏样式转换的时机"><a href="#导航栏样式转换的时机" class="headerlink" title="导航栏样式转换的时机"></a><strong>导航栏样式转换的时机</strong></h3><p>我们刚才提到了“谁修改，谁复原”的原则，但何时修改，何时复原呢？</p>
<p>对于那些存储在 Stack 中的 ViewController 而言，它其实就是在不断的经历 appear 和 disappear 的过程，结合<br>ViewController 的生命周期来看，<code>viewWillAppear:</code> 和 <code>viewWillDisappear:</code><br>是两个完美的时间节点，但很多人却对这两个方法的调用存在疑惑。</p>
<p>苹果公司在它的 API 文档中专门用了一段文字来解答大家的疑惑，这段文字的标题为《Handling View-Related<br>Notifications》，在这里我们直接引用原文：</p>
<blockquote>
<p>When the visibility of its views changes, a view controller automatically<br>calls its own methods so that subclasses can respond to the change. Use a<br>method like viewWillAppear: to prepare your views to appear onscreen, and use<br>the viewWillDisappear: to save changes or other state information. Use other<br>methods to make appropriate changes.<br>Figure 1 shows the possible visible states for a view controller’s views and<br>the state transitions that can occur. Not all ‘will’ callback methods are<br>paired with only a ‘did’ callback method. You need to ensure that if you start<br>a process in a ‘will’ callback method, you end the process in both the<br>corresponding ‘did’ and the opposite ‘will’ callback method.</p>
</blockquote>
<p>这里很好的解释了所有的 will 系列方法和 did 系列方法的对应关系，同时也给我们吃了一个定心丸，那就是在 appearing 和<br>disappearing 状态之间会由 will 系列方法进行衔接，避免了状态中断。这对于连续 push 或者连续 pop<br>的情况是及其重要的，否则我们无法做到 “谁修改，谁复原”的原则。</p>
<p>通常来说，如果只是一个简单的导航栏样式变化，我们的代码结构大体会如下所示：</p>
<pre><code>- (void)viewWillAppear:(BOOL)animated{  
    [super viewWillAppear:animated];  
    // MARK: change the navigationbar style   
}  

- (void)viewWillDisappear:(BOOL)animated{  
    [super viewWillDisappear:animated];  
    // MARK: restore the navigationbar style  
}  
</code></pre><p>现在，我们明确了修改时机，接下来要明确的就是导航栏的样式会进行怎样的变化。</p>
<h3 id="导航栏的样式变化"><a href="#导航栏的样式变化" class="headerlink" title="导航栏的样式变化"></a><strong>导航栏的样式变化</strong></h3><p>对于不同 ViewController 之间的导航栏样式变化，大多可以总结为两种情况：</p>
<ol>
<li><p>导航栏的显示与否</p>
</li>
<li><p>导航栏的颜色变化</p>
</li>
</ol>
<h4 id="导航栏的显示与否"><a href="#导航栏的显示与否" class="headerlink" title="导航栏的显示与否"></a>导航栏的显示与否</h4><p>对于显示与否的问题，可以在上一节提到的两个方法里调用 <code>setNavigationBarHidden:animated:</code> 方法，这里需要提醒的有两点：</p>
<ol>
<li><p>在导航栏转场的过程中，不要天真的以为 <code>setNavigationBarHidden:</code> 和 <code>setNavigationBarHidden:animated:</code> 的效果是一样的，直接使用 <code>setNavigationBarHidden:</code> 会造成导航栏转场过程中的闪现、背景错乱等问题，这一现象在使用手势驱动转场的场景中十分常见，所以正确的方式是使用带有 animated 参数的 API。</p>
</li>
<li><p>在 push 和 pop 的方法里也会带有 animated 参数，尽量保证与 <code>setNavigationBarHidden:animated:</code> 中的 animated 参数一致。</p>
</li>
</ol>
<h4 id="导航栏的颜色变化"><a href="#导航栏的颜色变化" class="headerlink" title="导航栏的颜色变化"></a>导航栏的颜色变化</h4><p>颜色变化的问题就稍微复杂一些，在 iOS 7 后，导航栏增加了 translucent 效果，这使得导航栏背景色的变化出现了两种情况：</p>
<ol>
<li><p>translucent 属性值为 YES 的前提下，更改导航栏的背景色。</p>
</li>
<li><p>translucent 属性值为 NO 的前提下，更改导航栏的背景色。</p>
</li>
</ol>
<p>对于第一种情况，我们需要调用 UINavigationBar 的 <code>setBackgroundColor:</code> 方法。</p>
<p>对于第二种情况我们需要调用 UINavigationBar 的 <code>setBackgroundImage:forBarMetrics:</code> 方法。</p>
<p>对于第二种情况，这里有三点需要提示：</p>
<ol>
<li><p>在设置透明效果时，我们通常可以直接设置一个 <code>[UIImage new]</code> 创建的对象，无须创建一个颜色为透明色的图片。</p>
</li>
<li><p>在使用 <code>setBackgroundImage:forBarMetrics:</code> 方法的过程中，如果图像里存在 alpha 值小于 1.0 的像素点，则 translucent 的值为 YES，反之为 NO。也就是说，如果我们真的想让导航栏变成纯色且没有 translucent 效果，请保证所有像素点的 alpha 值等于 1。</p>
</li>
<li><p>如果设置了一个完全不透明的图片且强行将 NavigationBar 的 translucent 属性设置为 YES 的话，系统会自动修正这个图片并为它添加一个透明度，用于模拟 translucent 效果。</p>
</li>
<li><p>如果我们使用了一个带有透明效果的图片且导航栏的 translucent 效果为 NO 的话，那么系统会在这个带有透明效果的图片背后，添加一个不透明的纯色图片用于整体效果的合成。这个纯色图片的颜色取决于 barStyle 属性，当属性为 UIBarStyleBlack 时为黑色，当属性为 UIBarStyleDefault 时为白色，如果我们设置了 barTintColor，则以设置的颜色为基准。</p>
</li>
</ol>
<h4 id="分清楚-transparent，translucent，opaque，alpha-和-opacity-也挺重要"><a href="#分清楚-transparent，translucent，opaque，alpha-和-opacity-也挺重要" class="headerlink" title="分清楚 transparent，translucent，opaque，alpha 和 opacity 也挺重要"></a>分清楚 transparent，translucent，opaque，alpha 和 opacity 也挺重要</h4><p>在刚接触导航栏 API 时，许多人经常会把文档里的这些英文词搞混，也不太明白带有这些词的变量为什么有的是布尔型，有的是浮点型，总之一切都让人很困惑。</p>
<p>在这里将做了一个总结，这对于理解 Apple 的 API 设计原则十分有帮助。</p>
<p>transparent， translucent， opaque<br>三个词经常会用在一起，它用于描述物体的透光强度，为了让大家更好的理解这三个词，这里做了三个比喻：</p>
<ul>
<li><p>transparent 是指透明，就好比我们可以透过一面干净的玻璃清楚的看到外面的风景。</p>
</li>
<li><p>translucent 是指半透明，就好比我们可以透过一面有点磨砂效果的塑料墙看外面的风景，不能说看不见，但我们肯定看不清。</p>
</li>
<li><p>opaque 是指不透明，就好比我们透过一个堵石墙是看不见任何外面的东西，眼前看到的只有这面墙。</p>
</li>
</ul>
<p>这三个词更多的是用来表述一种状态，不需要量化，所以这与这三个词相关的属性，一般都是 BOOL 类型。</p>
<p>alpha 和 opacity 经常会在一起使用，它要表示的就是透明度，在 Web 端这两个属性有着明显的区别。</p>
<p>在 Web 端里，opacity 是设定整个元素的透明值，而 alpha 一般是放在颜色设置里面，所以我们可以做到对特定对元素的某个属性设定<br>alpha，比如背景、边框、文字等。</p>
<pre><code>div {  
  width: 100px;  
  height: 100px;  
  background: rgba(0,0,0,0.5);  
  border: 1px solid #000000;  
  opacity: 0.5;  
}  
</code></pre><p>这一概念同样适用于 iOS 里的概念，比如我们可以通过 alpha 通道单独的去设置<br>backgroudColor、borderColor，它们互不影响，且有着独立的 alpha 通道，我们也可以通过 opacity 统一设置整个 view<br>的透明度。</p>
<p>但与 Web 端不一致的是，iOS 里面的 view 不光拥有独立的 alpha 属性，同时也是基于 CALayer，所以我们可以看到任意 UIView<br>对象下面都会有一个 layer 的属性，用于表明 CALayer 对象。view 的 alpha 属性与 layer 里面的 opacity<br>属性是一个相等的关系，需要注意的是 view 上的 alpha 属性是 Web 端并不具备的一个能力，所以笔者认为：在 iOS 中去说 alpha<br>时，要区分是在说 view 上的属性，还是在说颜色通道里的 alpha。</p>
<p>由于这两个词都是在描述程度，所以我们看到它们都是 CGFloat 类型：</p>
<h3 id="转场过程中需要注意的问题和细节"><a href="#转场过程中需要注意的问题和细节" class="headerlink" title="转场过程中需要注意的问题和细节"></a><strong>转场过程中需要注意的问题和细节</strong></h3><p>说完了导航栏的转场时机和转场方式，其实大体上你已经能处理好不同样式间的转换，但还有一些细节需要你去考虑，下面我们来说说其中需要你关注的两点。</p>
<h4 id="translucent-属性带来的布局改变"><a href="#translucent-属性带来的布局改变" class="headerlink" title="translucent 属性带来的布局改变"></a>translucent 属性带来的布局改变</h4><p>translucent 会影响导航栏组件里 ViewController 的 View 布局，这里需要大家理清 5 个 API 的使用场景：</p>
<ol>
<li><p>edgesForExtendedLayout</p>
</li>
<li><p>extendedLayoutIncluedsOpaqueBars</p>
</li>
<li><p>automaticallyAdjustScrollViewInsets</p>
</li>
<li><p>contentInsetAdjustmentBehavior</p>
</li>
<li><p>additionalSafeAreaInsets</p>
</li>
</ol>
<p>前三个 API 是 iOS 11 之前的 API，它们之间的区别和联系在 Stack Overflow 上有一个比较精彩的回答 - <a href="https://stackoverflow.com/questions/18798792/explaining-difference-
between-automaticallyadjustsscrollviewinsets-
extendedlayo" target="_blank" rel="external">Explaining<br>difference between automaticallyAdjustsScrollViewInsets,<br>extendedLayoutIncludesOpaqueBars, edgesForExtendedLayout in<br>iOS7</a>，我在这里就不做详细阐述，总结一下它的观点就是:</p>
<p>如果我们先定义一个 UINavigationController，它里面包含了多个 UIViewController，每个 UIViewController<br>里面包含一个 UIView 对象：</p>
<ul>
<li><p>那么 edgesForExtendedLayout 是为了解决 UIViewController 与 UINavigationController 的对齐问题，它会影响 UIViewController 的实际大小，例如 edgesForExtendedLayout 的值为 UIRectEdgeAll 时，UIViewController 会占据整个屏幕的大小。</p>
</li>
<li><p>当 UIView 是一个 UIScrollView 类或者子类时，automaticallyAdjustsScrollViewInsets 是为了调整这个 UIScrollView 与 UINavigationController 的对齐问题，这个属性并不会调整  UIViewController 的大小。</p>
</li>
<li><p>对于 UIView 是一个 UIScrollView 类或者子类且导航栏的背景色是不透明的状态时，我们会发现使用 edgesForExtendedLayout 来调整 UIViewController 的大小是无效的，这时候你必须使用 extendedLayoutIncludesOpaqueBars 来调整 UIViewController 的大小，可以认为 extendedLayoutIncludesOpaqueBars 是基于 automaticallyAdjustsScrollViewInsets 诞生的，这也是为什么经常会看到这两个 API 会同时使用。</p>
</li>
</ul>
<p>这些调整布局的 API 背后是一套基于 topLayoutGuide 和 bottomLayoutGuide 的计算而已，在 iOS 11 后，Apple<br>提出了 Safe Area 的概念，将原先分裂开来的 topLayoutGuide 和 bottomLayoutGuide 整合到一个统一的<br>LayoutGuide 中，也就是所谓的 Safe Area，这个改变看起来似乎不是很大，但它的出现确实方便了开发者。</p>
<p>如果想对 Safe Area 带来的改变有更全面的认识，十分推荐阅读 Rosberry 的工程师 Evgeny Mikhaylov 在 Medium<br>上的文章 <a href="https://medium.com/rosberryapps/ios-safe-area-
ca10e919526f" target="_blank" rel="external">iOS Safe Area</a>，这篇文章基本涵盖了 iOS 11 中所有与 Safe Area 相关的 API 并给出了真正合理的解释。</p>
<p>这里只说一下 contentInsetAdjustmentBehavior 和 additionalSafeAreaInsets 两个 API。</p>
<p>对于 contentInsetAdjustmentBehavior 属性而言，它的诞生也意味着<br>automaticallyAdjustsScrollViewInsets 属性的失效，所以我们在那些已经适配了 iOS 11 的工程里能看到如下类似的代码：</p>
<pre><code>if (@available(iOS 11.0, *)) {  
    self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;  
} else {  
    self.automaticallyAdjustsScrollViewInsets = NO;  
}  
</code></pre><p>此处的代码片段只是一个示例，并不适用所有的业务场景，这里需要着重说明几个问题：</p>
<ol>
<li><p>关于 contentInsetAdjustmentBehavior 中的 UIScrollViewContentInsetAdjustmentAutomatic 的说明一直很“模糊”，通过 Evgeny Mikhaylov 的文章，我们可以了解到它在大多数情况下会与 UIScrollViewContentInsetAdjustmentScrollableAxes 一致，当且仅当满足以下所有条件时才会与 UIScrollViewContentInsetAdjustmentAlways 相似：</p>
<ul>
<li><p>UIScroller 类型的视图在水平轴方向是可滚动的，垂直轴是不可滚动的。</p>
</li>
<li><p>ViewController 视图里的第一个子控件是 UIScrollView 类型的视图。</p>
</li>
<li><p>ViewController 是 navigation 或者 tab 类型控制器的子视图控制器。</p>
</li>
<li><p>启用 automaticallyAdjustsScrollViewInsets。 </p>
</li>
</ul>
</li>
<li><p>iOS 11 后，通过 contentInset 属性获取的偏移量与 iOS 10 之前的表现形式并不一致，需要获取 adjustedContentInset 属性才能保证与之前的 contentInset 属性一致，这样的改变需要我们在代码里对不同的版本进行适配。</p>
</li>
</ol>
<p>对于 additionalSafeAreaInsets 而言，如果系统提供的这几种行为并不能满足我们的布局要求，开发者还可以考虑使用<br>additionalSafeAreaInsets 属性做调整，这样的设定使得开发者可以更加灵活，更加自由的调整视图的布局。</p>
<h4 id="backIndicator-上的动画"><a href="#backIndicator-上的动画" class="headerlink" title="backIndicator 上的动画"></a>backIndicator 上的动画</h4><p>苹果提供了许多修改导航栏组件样式的 API，有关于布局的，有关于样式的，也有关于动画的。backIndicatorImage 和<br>backIndicatorTransitionMaskImage 就是其中的两个 API。</p>
<p>backIndicatorImage 和 backIndicatorTransitionMaskImage 操作的是 NavigationBar<br>里返回按钮的图片，也就是下图红色圆圈所标注的区域。</p>
<p>想要成功的自定义返回按钮的图标样式，我们需要同时设置这两个 API ，从字面上来看，它们一个是返回图片本身，另一个是返回图片在转场时用到的 mask<br>图片，看起来不怎么难，我们写一段代码试试效果：</p>
<pre><code>self.navigationController.navigationBar.backIndicatorImage = [UIImage imageNamed:@&quot;backArrow&quot;];  
self.navigationController.navigationBar.backIndicatorTransitionMaskImage = [UIImage imageNamed:@&quot;backArrowMask&quot;];  
</code></pre><p>代码里的图片如下所示：</p>
<p>也许大多数人在这里会都认为，mask 图片会遮挡住文字使其在遇到返回按钮右边缘的时候就消失。但实际的运行效果是怎么样子的呢？我们来看一下：</p>
<p>在上面的图片中，我们可以看到返回按钮的文字从返回按钮的图片下面穿过并且文字被图片所遮挡，这种动画看起来十分奇怪，这是无法接受的。我们需要做点修改：</p>
<pre><code>self.navigationController.navigationBar.backIndicatorImage = [UIImage imageNamed:@&quot;backArrow&quot;];  
self.navigationController.navigationBar.backIndicatorTransitionMaskImage = [UIImage imageNamed:@&quot;backArrow&quot;];  
</code></pre><p>这一次我们将 backIndicatorTransitionMaskImage 改为 indicatorImage 所用的图片。</p>
<p>到这里，可能大多数人都会好奇，这代码也能行？让我们看下它实际的效果：</p>
<p>在上面的图中，我们看到文字在到达图片的右边缘时就从下方穿过并被完全遮盖住了，这种动画效果虽然比上面好一些，但仍然有改进的空间，不过这里我们先不继续优化了，我们先来讨论一下它们背后的运作原理。</p>
<p>iOS 系统会将 indicatorImage 中不透明的颜色绘制成返回按钮的图标， indicatorTransitionMaskImage 与<br>indicatorImage 的作用不同。indicatorTransitionMaskImage 将自身不透明的区域像 mask 一样作用在<br>indicatorImage 上，这样就保证了返回按钮中的文字像左移动时，文字只出现在被 mask 的区域，也就是<br>indicatorTransitionMaskImage 中不透明的区域。</p>
<p>掌握了原理，我们来解释下刚才的两种现象：</p>
<p>在第一种实现中，我们提供的 indicatorTransitionMaskImage<br>覆盖了整个返回按钮的图标，所以我们在转场过程中可以清晰的看到返回按钮的文字。</p>
<p>在第二种实现中，我们使用 indicatorImage 作为 indicatorTransitionMaskImage，记住文字是只能出现在<br>indicatorTransitionMaskImage 里不透明的区域，所以显然返回按钮中的文字会在图标的最右边就已经被遮挡住了，因为那片区域是透明的。</p>
<p>那么前面提到的进一步优化指的是什么呢？</p>
<p>让我们来看一下下面这个示例图，为了更好的区分，我们将 indicatorTransitionMaskImage 用红色进行标注。黑色仍然是<br>indicatorImage。</p>
<p>按照刚才介绍的原理，我们应该可以理解，现在文字只会出现在红色区域，那么它的实际效果是什么样子的呢，我们可以看下图：</p>
<p>现在，一个完美的返回动画，诞生啦！</p>
<blockquote>
<p>此节所用的部分效果图出自 Ray Wenderlich 的文章 <a href="https://www.raywenderlich.com/1625-uiappearance-tutorial-getting-
started" target="_blank" rel="external">UIAppearance Tutorial: Getting<br>Started</a></p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="导航栏的跳转或许可以这么玩儿……"><a href="#导航栏的跳转或许可以这么玩儿……" class="headerlink" title="导航栏的跳转或许可以这么玩儿……"></a><strong>导航栏的跳转或许可以这么玩儿……</strong></h2><p>前两章的铺垫就是为了这一章的内容，所以现在让我们开始今天的大餐吧。</p>
<h3 id="这样真的好么？"><a href="#这样真的好么？" class="headerlink" title="这样真的好么？"></a><strong>这样真的好么？</strong></h3><p>刚才我们说了两个页面间 NavigationBar 的样式变化需要在各自的 <code>viewWillAppear:</code> 和 <code>viewWillDisappear:</code><br>中进行设置。那么问题就来了：这样的设置会带来什么问题呢？</p>
<p>试想一下，当我们的页面会跳到不同的地方时，我们是不是要在 <code>viewWillAppear:</code> 和 <code>viewWillDisappear:</code><br>方法里面写上一堆的判断呢？如果应用里还有 router 系统的话，那么页面间的跳转将变得更加不可预知，这时候又该如何在 <code>viewWillAppear:</code><br>和 <code>viewWillDisappear:</code> 里做判断呢？</p>
<p>现在我们的问题就来了，如何让导航栏的转场更加灵活且相互独立呢？</p>
<p>常见的解决方案如下所示：</p>
<p>重新实现一个类似 UINavigationController 的容器类视图管理器，这个容器类视图管理器做好不同 ViewController<br>间的导航栏样式转换工作，而每个 ViewController 只需要关心自身的样式即可。</p>
<p>将系统原有导航栏的背景设置为透明色，同时在每个 ViewController 上添加一个 View 或者 NavigationBar<br>来充当我们实际看到的导航栏，每个 ViewController 同样只需要关心自身的样式即可。</p>
<p>在转场的过程中隐藏原有的导航栏并添加假的 NavigationBar，当转场结束后删除假的 NavigationBar 并恢复原有的导航栏，这一过程可以通过<br>Swizzle 的方式完成，而每个 ViewController 只需要关心自身的样式即可。</p>
<p>这三种方案各有优劣，我们在网上也可以看到很多关于它们的讨论。</p>
<p>例如方案一，虽然看起来工作量大且难度高，但是这个工作一旦完成，我们就会将处理导航栏转场的主动权牢牢抓在手里。但这个方案的一个弊端就是，如果苹果修改了导航栏的整体风格，就好比<br>iOS 11 的大标题特效，那么工作量就来了。</p>
<p>对于方案二而言，虽然看起来简单易用，但这需要一个良好的继承关系，如果整个工程里的继承关系混乱或者是历史包袱比较重，后续的维护就像“打补丁”一样，另外这个方案也需要良好的团队代码规范和完善的技术文档来做辅助。</p>
<p>对于方案三而言，它不需要所谓的继承关系，使用起来也相对简单，这对于那些继承关系和历史包袱比较重的工程而言，这一个不错的解决方案，但在解决 Bug<br>的时候，Swizzle 这种方式无疑会增加解决问题的时间成本和学习成本。</p>
<h3 id="我们的解决方案"><a href="#我们的解决方案" class="headerlink" title="我们的解决方案"></a><strong>我们的解决方案</strong></h3><p>在美团 App<br>的早期，各个业务方都想充分利用导航栏的能力，但对于导航栏的状态维护缺乏理解与关注，随着业务方的增加和代码量的上升，与导航栏相关的问题逐渐暴露出来，此时我们才意识到这个问题的严重性。</p>
<p>大型 App<br>的导航栏问题就像一个典型的“公地悲剧”问题。在软件行业，公用代码的所有权可以被视作“公地”，因为不注重长期需求而容易遭到消耗。如果开发人员倾向于交付“价值”，而以可维护性和可理解性为代价，那么这个问题就特别普遍了。如果是这种情况，每次代码修改将大大减少其总体质量，最终导致软件的不可维护。</p>
<p>所以解决这个问题的核心在于：明确公用代码的所有权，并在开发期施加约束。</p>
<p>明确公用代码的所有权，可以理解为将导航栏相关的组件抽离成一个单独的组件，并交由特定的团队维护。而在开发期施加约束，则意味着我们要提供一套完整的解决方案让各个业务方遵守。</p>
<p>这一节我们会以美团内部的解决方案为例，讲解如何实现一个流畅的导航栏跳转过程和相关使用方法。</p>
<h4 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h4><p>使用者只用关心当前 ViewController 的 NavigationBar 样式，而不用在 push 或者 pop 的时候去处理<br>NavigationBar 样式。</p>
<p>举个例子来说，当从 A 页面 push 到 B 页面的时候，转场库会保存 A 页面的导航栏样式，当 pop 回去后就会还原成以前的样式，因此我们不用考虑<br>pop 后导航栏样式会改变的情况，同时我们也不必考虑 push 后的情况，因为这个是页面 B 本身需要考虑的。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>转场库的使用十分简单，我们不需要 import 任何头文件，因为它在底层通过 Method Swizzling 进行了处理，只需要在使用的时候遵循下面 4<br>点即可：</p>
<ul>
<li><p>当需要改变导航栏样式的时候，在视图控制器的 <code>viewDidLoad</code> 或者 <code>viewWillAppear:</code> 方法里去设置导航栏样式。</p>
</li>
<li><p>用 <code>setBackgroundImage:forBarMetrics:</code> 方法和 shadowImage 属性去修改导航栏的背景样式。</p>
</li>
<li><p>不要在 <code>viewWillDisappear:</code> 里添加针对导航栏样式修改的代码。</p>
</li>
<li><p>不要随意修改 translucent 属性，包括隐式的修改和显示的修改。</p>
</li>
</ul>
<blockquote>
<p>隐式修改是指使用 <code>setBackgroundImage:forBarMetrics:</code> 方法时，如果 image 里的像素点没有 alpha 通道或者<br>alpha 全部等于 1 会使得 translucent 变为 NO 或者 nil。</p>
</blockquote>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a><strong>基本原理</strong></h3><p>以上，我们讲完了设计理念和使用方法，那么我们来看看美团的转场库到底做了什么？</p>
<p>从大方向上来看，美团使用的是前面所说的第三种方案，不过它也有一些自己独特的地方，为了更好的让大家理解整个过程，我们设计这样一个场景，从页面 A push<br>到页面 B，结合之前探讨过的方法调用顺序，我们可以知道几个核心方法的调用顺序大致如下：</p>
<ol>
<li><p>页面 A 的 <code>pushViewController:animated:</code></p>
</li>
<li><p>页面 B 的 <code>viewDidLoad</code> or <code>viewWillAppear:</code></p>
</li>
<li><p>页面 B 的 <code>viewWillLayoutSubviews</code></p>
</li>
<li><p>页面 B 的 <code>viewDidAppear:</code></p>
</li>
</ol>
<p>在 push 过程的开始，转场库会在页面 A 自身的 view 上添加一个与导航栏一模一样的 NavigationBar<br>并将真的导航栏隐藏。之后这个假的导航栏会一直存在页面 A 上，用于保留 A 离开时的导航栏样式。</p>
<p>等到页面 B 调用 <code>viewDidLoad</code> 或者 <code>viewWillAppear:</code><br>的时候，开发者在这里自行设置真的导航栏样式。转场库在这里会对页面布局做一些修正和辅助操作，但不会影响导航栏的样式。</p>
<p>等到页面 B 调用 <code>viewWillLayoutSubviews</code> 的时候，转场库会在页面 B 自身的 view 上添加一个与真的导航栏一模一样的<br>NavigationBar，同时将真的导航栏隐藏。此时不论真的导航栏，还是假的导航栏都已经与 <code>viewDidLoad</code> 或者<br><code>viewWillAppear:</code> 里设置的一样的。</p>
<blockquote>
<p>当然，这一步也可以放在 <code>viewWillDisappear:</code> 里并在 dispatch main queue 的下一个 runloop 中处理。</p>
</blockquote>
<p>等到页面 B 调用 <code>viewDidAppear:</code><br>的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。</p>
<p>为了让大家更好地理解上面的内容，请参考下图：</p>
<p>说完了 push 过程，我们再来说一下从页面 B pop 回页面 A 的过程，几个核心方法的调用顺序如下：</p>
<ol>
<li><p>页面 B 的 <code>popViewControllerAnimated:</code></p>
</li>
<li><p>页面 A 的 <code>viewWillAppear:</code></p>
</li>
<li><p>页面 A 的 <code>viewDidAppear:</code></p>
</li>
</ol>
<p>在 pop 过程的开始，转场库会在页面 B 自身的 view 上添加一个与导航栏一模一样的 NavigationBar<br>并将真的导航栏隐藏，虽然这个假的导航栏会一直存在于页面 B 上，但它自身会随着页面 B 的 dealloc 而消亡。</p>
<p>等到页面 A 调用 <code>viewWillAppear:</code> 的时候，开发者在这里自行设置真的导航栏样式。当然我们也可以不设置，因为这时候页面 A<br>还持有一个假的导航栏，这里还保留着我们之前在 <code>viewDidLoad</code> 里写的导航栏样式。</p>
<p>等到页面 A 调用 <code>viewDidAppear:</code><br>的时候，转场库会将假的导航栏样式设置到真的导航栏中，并将假的导航栏从视图层级中移除，最终将真的导航栏显示出来。</p>
<p>同样，我们可以参考下面的图来理解上面所说的内容：</p>
<p>现在，大家应该对我们美团的解决方案有了一定的认识，但在实际开发过程中，还需要考虑一些布局和适配的问题。</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h2><p>在维护这套转场方案的时间里，我们总结了一些此类方案的最佳实践。</p>
<h3 id="判断导航栏问题的基本准则"><a href="#判断导航栏问题的基本准则" class="headerlink" title="判断导航栏问题的基本准则"></a><strong>判断导航栏问题的基本准则</strong></h3><p>如果发现导航栏在转场过程中出现了样式错乱，可以遵循以下几点基本原则：</p>
<ul>
<li><p>检查相应 ViewController 里是否有修改其他 ViewController 导航栏样式的行为，如果有，请做调整。</p>
</li>
<li><p>保证所有对导航栏样式变化的操作出现在 <code>viewDidLoad</code> 和 <code>viewWillAppear:</code> 中，如果在 <code>viewWillDisappear:</code> 等方法里出现了对导航栏的样式修改的操作，如果有，请做调整。</p>
</li>
<li><p>检查是否有改动 translucent 属性，包括显示修改和隐式修改，如果有，请做调整。</p>
</li>
</ul>
<h3 id="只关心当前页面的样式"><a href="#只关心当前页面的样式" class="headerlink" title="只关心当前页面的样式"></a><strong>只关心当前页面的样式</strong></h3><p>永远记住每个 ViewController 只用关心自己的样式，设置的时机点在 <code>viewWillAppear:</code> 或者 <code>viewDidLoad 里</code>。</p>
<h3 id="透明样式导航栏的正确设置方法"><a href="#透明样式导航栏的正确设置方法" class="headerlink" title="透明样式导航栏的正确设置方法"></a><strong>透明样式导航栏的正确设置方法</strong></h3><p>如果需要一个透明效果的导航栏，可以使用如下代码实现：</p>
<pre><code>[self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];  
self.navigationController.navigationBar.shadowImage = [UIImage new];   
</code></pre><h3 id="导航栏的颜色渐变效果"><a href="#导航栏的颜色渐变效果" class="headerlink" title="导航栏的颜色渐变效果"></a><strong>导航栏的颜色渐变效果</strong></h3><p>如果需要导航栏实现随滚动改变整体 alpha 值的效果，可以通过改变 <code>setBackgroundImage:forBarMetrics:</code> 方法里<br>image 的 alpha 值来达到目标，这里一般是使用监听 <code>scrollView.contentOffset</code> 的手段来做。请避免直接修改<br>NavigationBar 的 alpha 值。</p>
<p>如果发现这种方式会引起严重的性能问题，可以尝试使用如下的方式进行修改，但不推荐，主要原因是通过读取数组内容的方式来获取视图实例既不优雅，也不安全。</p>
<pre><code>UIView *background = self.navigationController.navigationBar.subviews.firstObject;  
background.alpha = MIN(self.contentOffsetY / 100.0, 1);  
</code></pre><p>还有一点需要注意的是，在页面转场的过程中，也会触发 contentOffset 的变化，所以请尽量在 disappear<br>的时候取消监听。否则会容易出现导航栏透明度的变化。</p>
<h3 id="导航栏背景图片的规范"><a href="#导航栏背景图片的规范" class="headerlink" title="导航栏背景图片的规范"></a><strong>导航栏背景图片的规范</strong></h3><p>请避免背景图里的像素点没有 alpha 通道或者 alpha 全部等于 1，容易触发 translucent 的隐式改变。</p>
<h3 id="如果真的要隐藏导航栏"><a href="#如果真的要隐藏导航栏" class="headerlink" title="如果真的要隐藏导航栏"></a><strong>如果真的要隐藏导航栏</strong></h3><p>如果我们需要隐藏导航栏，请保证所有的 ViewController 能坚持如下原则：</p>
<ol>
<li><p>每个 ViewController 只需要关心当前页面下的导航栏是否被隐藏。</p>
</li>
<li><p>在 <code>viewWillAppear:</code> 中，统一设置导航栏的隐藏状态。</p>
</li>
<li><p>使用 <code>setNavigationBarHidden:animated:</code> 方法，而不是 <code>setNavigationBarHidden:</code>。</p>
</li>
</ol>
<h3 id="转场动画与导航栏隐藏动画的一致性"><a href="#转场动画与导航栏隐藏动画的一致性" class="headerlink" title="转场动画与导航栏隐藏动画的一致性"></a><strong>转场动画与导航栏隐藏动画的一致性</strong></h3><p>如果在转场的过程中还会显示或者隐藏导航栏的话，请保证两个方法的动画参数一致。</p>
<pre><code>- (void)viewWillAppear:(BOOL)animated{  
    [self.navigationController setNavigationBarHidden:YES animated:animated];  
}  
</code></pre><blockquote>
<p><code>viewWillAppear:</code> 里的 animated 参数是受 push 和 pop 方法里 animated 参数影响。</p>
</blockquote>
<h3 id="导航栏固有的系统问题"><a href="#导航栏固有的系统问题" class="headerlink" title="导航栏固有的系统问题"></a><strong>导航栏固有的系统问题</strong></h3><p>目前已知的有两个系统问题如下：</p>
<ol>
<li><p>当前后两个 ViewController 的导航栏都处于隐藏状态，然后在后一个 ViewController 中使用返回手势 pop 到一半时取消，再连续 push 多个页面时会造成导航栏的 Stack 混乱或者 Crash。</p>
</li>
<li><p>当页面的层级结构大体如下所示时，在红色导航栏的 Stack 中，返回手势会大概率的出现跨层级的跳转，多次后会导致整个导航栏的 Stack 错乱或者 Crash。</p>
</li>
</ol>
<h3 id="导航栏内置组件的布局规范"><a href="#导航栏内置组件的布局规范" class="headerlink" title="导航栏内置组件的布局规范"></a><strong>导航栏内置组件的布局规范</strong></h3><p>导航栏里的组件布局在 iOS 11 后发生了改变，原有的一些解决方案已经失效，这些内容不在本篇文章的讨论范围之内，推荐阅读<a href="http://sketchk.xyz/2018/02/23/How-to-make-your-
UIBarButtonItem-perfect-match-in-iOS/" target="_blank" rel="external">UIBarButtonItem<br>在 iOS 11 上的改变及应对方案</a>，这篇文章详细的解释了 iOS 11 里的变化和可行的应对方案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>本文涉及内容较多，从 iOS 系统下的导航栏概念到大型应用里的最佳实践，这里我们总结一下整篇文章的核心内容：</p>
<ul>
<li><p>理解导航栏组件的结构和相关方法的生命周期。</p>
<ul>
<li><p>导航栏组件的结构留有 MVC 架构的影子，在解决问题时，要去相应的层级处理。</p>
</li>
<li><p>转场问题的关键点是方法的调用顺序，所以了解生命周期是解决此类问题的基础。</p>
</li>
</ul>
</li>
<li><p>状态管理，转换时机和样式变化是导航栏里常见问题的三种表现形式，遇到实际问题时需要区分清楚。</p>
<ul>
<li><p>状态管理要坚持“谁修改，谁复原”的原则。</p>
</li>
<li><p>转换时机的设定要做到连续可执行。</p>
</li>
<li><p>样式变化的核心点是导航栏的显示与否与颜色变化。</p>
</li>
</ul>
</li>
<li><p>为了更好的配合大型应用里的路由系统，导航栏转场的常见解决方案有三种，各有利弊，需要根据自身的业务场景和历史包袱做取舍。</p>
<ul>
<li><p>解决方案1：自定义导航栏组件。</p>
</li>
<li><p>解决方案2：在原有导航栏组件里添加 Fake Bar。</p>
</li>
<li><p>解决方案3：在导航栏转场过程中添加 Fake Bar。</p>
</li>
</ul>
</li>
<li><p>美团在实际开发过程中采用了第三种方案，并给出了适合美团 App 的最佳实践。</p>
</li>
</ul>

                    
                        
                    
                    
                        <p>
                            <a href="/2018/10/27/【转】iOS系统中导航栏的转场解决方案与最佳实践/#post-footer" class="postShorten-excerpt_link link">
                                阅读全文
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/10/16/【转】iOS-Memory-Deep-Dive/">
                            【转】iOS Memory Deep Dive
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-10-16T13:06:45+08:00">
	
		    10月 16, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>仅以此文解答自己大学以来多年对内存管理的疑惑。</p>
<h2 id="经典操作系统的虚拟内存"><a href="#经典操作系统的虚拟内存" class="headerlink" title="经典操作系统的虚拟内存"></a>经典操作系统的虚拟内存</h2><h3 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h3><p>随着计算机的发展，我们的计算机处理的任务也变得越来越繁多，但是对于某台固定的计算机，CPU 和 Memory<br>都是固定的，如果有些直接使用物理内存地址的话会带来很多问题。首先编译器不能以一种抽象的角度来描绘内存，在执行的过程中如果某个进程占据的内存过大，这个进程可能就无法运行，即便运行了，内存相对来说是非常不安全的，一个不小心操作到了别的进程的内存，可能导致进程的崩溃，如果写入了内核使用的内存可能导致操作系统的崩溃。</p>
<p>现代操作系统的内存管理是非常多计算机科学家智慧的结晶，这种管理方式就是  <strong>虚拟内存 (Virtual Memory/VM)</strong> 。VM<br>是一系列技术的总称，包括硬件异常，物理地址，主存，磁盘文件，操作系统内核软件的内存管理。</p>
<p>虚拟内存提供了三大重要的特性：</p>
<ol>
<li><p>它将主存看做在存储在磁盘上的地址空间的高速缓存，利用程序的局部性原理，只将活跃的内存加载到主存中，提高了主存的利用率；</p>
</li>
<li><p>为每个进程提供了一个抽象的统一的连续的私有的地址空间。简化了内存管理方式；</p>
</li>
<li><p>对内存进行分段（segment）提供权限能力，保护每个进程的地址空间不会被其他进程影响；</p>
</li>
</ol>
                    
                        <a href="/2018/10/16/【转】iOS-Memory-Deep-Dive/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/07/22/AVFoundation之AVAudioRecorder/">
                            AVFoundation之AVAudioRecorder
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-07-22T14:44:25+08:00">
	
		    7月 22, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p><code>AVAudioRecorder</code>是一个功能强大且代码简单易用的<code>iOS</code>、<code>Mac</code>平台下的音频录制类。它即可从内置的麦克风录制音频，也可从外部音频设备进行录制，比如外接麦克风等。</p>
                    
                        <a href="/2018/07/22/AVFoundation之AVAudioRecorder/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/07/21/AVFoundation之AVAudioPlayer/">
                            AVFoundation之AVAudioPlayer
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-07-21T13:16:11+08:00">
	
		    7月 21, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>目前公司主要做<code>Voip</code>方面的应用，作为<code>iOS</code>开发者，当然需要对<code>AVFoundation</code>有个全面的了解。接下来将开启一个系列，记录学习<code>AVFoundation</code>的过程。</p>
                    
                        <a href="/2018/07/21/AVFoundation之AVAudioPlayer/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/12/09/Socks5代理分析/">
                            Socks5代理分析
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-12-09T14:56:26+08:00">
	
		    12月 09, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/网络/">网络</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>项目中遇到了socks5代理环境下UDP不通的问题，在解决问题的过程中，也学习了socks5到底是如何通信的，下面就原理、客户端、服务器三个方面来详细说一下。</p>
                    
                        <a href="/2017/12/09/Socks5代理分析/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/10/16/WebSocket-WebRTC-Scoket的理解/">
                            WebSocket WebRTC Scoket的理解
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-10-16T14:59:44+08:00">
	
		    10月 16, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/网络/">网络</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>一直搞不明白<code>Socket</code>、<code>WebSocket</code>、<code>WebRTC</code>的关系，最近有时间，就来研究一下。</p>
                    
                        <a href="/2017/10/16/WebSocket-WebRTC-Scoket的理解/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/09/15/iOS强大的泛型/">
                            iOS强大的泛型
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-09-15T17:19:31+08:00">
	
		    9月 15, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>在学习安卓的过程中，发现<code>java</code>的泛型机制特别的好用，<code>Objective-C</code>是一门动态性弱类型语言，例如毫无关系的两个类<code>A</code>和<code>B</code>，<code>A *a = [[B alloc] init]</code>在<code>Objective-C</code>编译和运行中都不会出错。但是<code>A a = new B()</code>在<code>java</code>中编译失败。这样，可以强制编程人员注意类型转换。</p>
<p>在不了解<code>Objective-C</code>的泛型之前，我一直以为<code>Objective-C</code>的泛型是鸡肋，例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *times;</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.times addObject:[[<span class="built_in">NSObject</span> alloc] init]];</div></pre></td></tr></table></figure>
<p>我声明一个<code>NSString</code>类型的泛型数组，但是我往数组中添加的是一个<code>NSObject</code>类型的对象，虽然编译器会警告，但并不会报错(大部分程序猿也会忽略这个警告)。所以，我认为<code>Objective-C</code>的泛型是鸡肋。当然，这只是我之前的自以为(还是自己学的不深入)。但是今天看过一篇介绍<code>Objective-C</code>的泛型以后，才发现<code>Objective-C</code>也能做到编译时报错。</p>
                    
                        <a href="/2017/09/15/iOS强大的泛型/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/09/13/深入理解Block/">
                            深入理解Block
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-09-13T15:40:30+08:00">
	
		    9月 13, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>在<code>iOS</code>开发中，经常会使用到<code>Block</code>，那<code>Block</code>到底是什么？它的实现方式是什么？通过阅读《Objective-C高级编程：iOS与OS X多线程和内存管理》，会对<code>Block</code>有个更深的了解。</p>
                    
                        <a href="/2017/09/13/深入理解Block/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/08/31/深入理解KVC、KVO/">
                            深入理解KVC、KVO
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-08-31T11:11:40+08:00">
	
		    8月 31, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <p>网上关于KVC和KVO的介绍一大片，基本用法这里就不介绍了，这篇主要聊聊KVC和KVO的实现，以及我们自己动手实现一套KVO。</p>
                    
                        <a href="/2017/08/31/深入理解KVC、KVO/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2017/07/14/load-方法全程跟踪/">
                            load 方法全程跟踪
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2017-07-14T12:00:41+08:00">
	
		    7月 14, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt" itemprop="articleBody">
                    <h3 id="load方法的调用时机"><a href="#load方法的调用时机" class="headerlink" title="load方法的调用时机"></a>load方法的调用时机</h3><p>我们都知道，每个类都有两个初始化方法，其中一个就是<code>load</code>方法，对于每一个<code>Class</code>和<code>Category</code>来说，必定会调用此方法，而且仅调用一次。当包含<code>Class</code>和<code>Category</code>的程序被库载入系统时，就会执行此方法，并且此过程通常是在程序启动的时候执行。</p>
<p>不同的是，现在<code>iOS</code>系统中已经加入了动态加载特性，这是从<code>macOS</code>应用程序中迁移而来的特性，等应用程序启动好之后再去加载程序库。如果<code>Class</code>和其<code>Category</code>中都重写了<code>load</code>方法，则先调用<code>Class</code>中的。那么为什么会先调用<code>Class</code>的<code>load</code>方法呢？通过这篇文章想必你会有个答案。</p>
                    
                        <a href="/2017/07/14/load-方法全程跟踪/" class="postShorten-excerpt_link link">
                            阅读全文
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/page/2/">
                    <span>下一页</span>
                <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
        </li>
        
        <li class="pagination-number">第 1 页 共 7 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 贵永冬. All Rights Reserved.
    </span>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/header.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">贵永冬</h4>
        
            <div id="about-card-bio"><p>iOS开发者<br> 会一点RN和android,  十足的海贼迷</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>河南信悦通网络科技有限公司</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                河南 郑州
            </div>
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/08/11/初识ReactiveCocoa/">
                            <h3 class="media-heading">初识ReactiveCocoa</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年8月11日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>(简称为RAC), 是由Github开源的一个应用于iOS和OS开发的新框架, RAC具有函数式编程和响应式编程的特性, 通过这篇文章对RAC有一个简单的了解。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/08/12/深入ReactiveCocoa/">
                            <h3 class="media-heading">深入ReactiveCocoa</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年8月12日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>(简称为RAC),上一篇文章，我们简单的对RAC有个初步的了解，在开发中，我们实际用到的基本都是上一篇所介绍的知识，这篇文章我们对RAC有个深入的了解。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/06/ReactiveCocoa和RXSwift速查表/">
                            <h3 class="media-heading">ReactiveCocoa和RXSwift速查表</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>在接触了RAC以后,对RAC有了一个基本的了解，这里整理了一下RAC脑图，方便日后查看。ps(<a href="https://github.com/aiqiuqiu/FRPCheatSheeta">转载</a>)</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/06/关于RAC的一些资料/">
                            <h3 class="media-heading">关于RAC的一些资料</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>看了这么多RAC资料，在这里我整理了一下，以备学习。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/08/RunLoop总结/">
                            <h3 class="media-heading">RunLoop总结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月8日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>最近研究了一下RunLoop，在这里对RunLoop做一个总结，主要是对<code>&lt;CoreFoundation/CFRunLoop.h&gt;</code>的头文件函数总结。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/13/聊一聊GCD的那些事/">
                            <h3 class="media-heading">聊一聊GCD的那些事</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月13日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/18/聊一聊NSOperation的那些事/">
                            <h3 class="media-heading">聊一聊NSOperation的那些事</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月18日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>在iOS开发中，多线程技术用到最多的就是GCD和NSOperation，上一篇文章已经对GCD有了全面的了解，这篇文章简单的聊一聊NSOperation。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/21/iOS动画篇-transfrom/">
                            <h3 class="media-heading">iOS动画篇之UIView动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月21日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/22/iOS动画篇之CoreAnimation动画/">
                            <h3 class="media-heading">iOS动画篇之CoreAnimation动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>App如果想被大众喜欢，漂亮的UI和精美的动画都是必不可少的，苹果虽然为UIView提供了一些常用动画，但是大部分看起来比较不错的效果都是通过操作Layer层实现的，因此了解核心动画是必要的.CoreAnimation是直接作用在CALayer上的(并非UIView上)非常强大的跨Mac OS X和iOS平台的动画处理API，Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://guiyongdong.github.io/2016/09/22/iOS动画之CATransition动画/">
                            <h3 class="media-heading">iOS动画之CATransition动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>今天主要用到的动画类是CALayer下的CATransition至于各种动画类中如何继承的在这也不做赘述，网上的资料是一抓一大把。好废话少说切入今天的正题。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 61 篇文章
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-rt08quwts7iav5x0cfd2ym0gb5qkd1lvrsmwrakxtkhefmaaes4ywkmnjnwf.min.js"></script>
<script src="/assets/js/prism.js"></script>
<!--SCRIPTS END-->



    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script>
    <script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
    <script>
        var algoliaClient = algoliasearch('DWKE0MOOLY', '141d50cf933ece6dd635747973c4fe00');
        var algoliaIndex = algoliaClient.initIndex('blog');
    </script>

    </body>
</html>
