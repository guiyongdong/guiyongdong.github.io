<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>贵大头的博客</title>
  <subtitle>贵大头的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.guiyongdong.com/"/>
  <updated>2016-11-19T11:46:25.000Z</updated>
  <id>http://www.guiyongdong.com/</id>
  
  <author>
    <name>贵永冬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NSURLSession与NSURLConnection区别</title>
    <link href="http://www.guiyongdong.com/2016/11/18/NSURLSession%E4%B8%8ENSURLConnection%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.guiyongdong.com/2016/11/18/NSURLSession与NSURLConnection区别/</id>
    <published>2016-11-18T06:09:19.000Z</published>
    <updated>2016-11-19T11:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去面试，被问了一道AFNetworking2.0和3.0有什么区别，当时心想，这谁不知道啊，随口答到：2.0使用的NSURLConnection,3.0使用的是NSURLSession,人家又问NSURLSesstion和NSURLConnection有什么区别，瞬间傻眼了，支支吾吾只是说出了缓存策略的不同。亡羊补牢，为时未晚，这篇博客就讲解一下它们两者到底有什么区别。</p>
<a id="more"></a>
<h4 id="使用现状"><a href="#使用现状" class="headerlink" title="使用现状"></a>使用现状</h4><p>NSURLSession是NSURLConnection的替代者，在2013年苹果全球开发者大会上（WWDC2013）随iOS7一起发布的，是对NSURLConnection进行了重构优化后的新的网络接口。从iOS9开始，NSURLConnection中发送请求的两个方法已经过期（同步请求，异步请求）,初始化网络连接的方法也被设置为过期，系统不再推荐使用，建议使用NSURLSession发送网络请求。NSURLConnection被废弃的主要接口：</p>
<pre><code>- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate startImmediately:(BOOL)startImmediately NS_DEPRECATED(10_5, 10_11, 2_0, 9_0, &quot;Use NSURLSession (see NSURLSession.h)&quot;) __WATCHOS_PROHIBITED;

- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate NS_DEPRECATED(10_3, 10_11, 2_0, 9_0, &quot;Use NSURLSession (see NSURLSession.h)&quot;) __WATCHOS_PROHIBITED;
+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate NS_DEPRECATED(10_3, 10_11, 2_0, 9_0, &quot;Use NSURLSession (see NSURLSession.h)&quot;) __WATCHOS_PROHIBITED;
//异步请求
+ (void)sendAsynchronousRequest:(NSURLRequest*) request
                          queue:(NSOperationQueue*) queue
              completionHandler:(void (^)(NSURLResponse* __nullable response, NSData* __nullable data, NSError* __nullable connectionError)) handler NS_DEPRECATED(10_7, 10_11, 5_0, 9_0, &quot;Use [NSURLSession dataTaskWithRequest:completionHandler:] (see NSURLSession.h&quot;) __WATCHOS_PROHIBITED;
//同步请求             
+ (nullable NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse * __nullable * __nullable)response error:(NSError **)error NS_DEPRECATED(10_3, 10_11, 2_0, 9_0, &quot;Use [NSURLSession dataTaskWithRequest:completionHandler:] (see NSURLSession.h&quot;) __WATCHOS_PROHIBITED;
</code></pre><h4 id="普通任务和上传"><a href="#普通任务和上传" class="headerlink" title="普通任务和上传"></a>普通任务和上传</h4><p>NSURLSession针对下载/上传等复杂的网络操作提供了专门的解决方案，针对普通、上传和下载分别对应三种不同的网络请求任务：NSURLSessionDataTask,NSURLSessionUploadTask和NSURLSessionDownloadTask。创建的task都是挂起状态，需要resume才能启动。</p>
<p>当服务器返回的数据较小时,NSURLSession与NSURLConnection执行普通任务的操作步骤没有区别。<br>执行上传任务时，NSURLSession与NSURLConnection一样需要设置POST请求的请求体进行上传。</p>
<h4 id="下载任务方式"><a href="#下载任务方式" class="headerlink" title="下载任务方式"></a>下载任务方式</h4><p>NSURLConnection下载文件时，先是将整个文件下载到内存，然后再写入到沙盒，如果文件比较大，就会出现内存暴涨的情况。</p>
<p>而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件中，不会出现内存暴涨的情况，但是在下载完成后会把tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。（后面会详细说）</p>
<h4 id="请求方法的控制"><a href="#请求方法的控制" class="headerlink" title="请求方法的控制"></a>请求方法的控制</h4><p>NSURLConnection实例化对象，实例化开始，默认请求就发送(同步发送),不需要调用start方法。而cancel可以停止请求的发送，停止后不能继续访问，需要创建新的请求。</p>
<p>NSURLSession有三个控制方法，取消(cancel)、暂停(suspend)、继续(resume)，暂停以后可以通过继续恢复当前的请求任务。</p>
<h4 id="断点续传的方式"><a href="#断点续传的方式" class="headerlink" title="断点续传的方式"></a>断点续传的方式</h4><p>NSURLConnection进行断点下载，通过设置访问请求的HTTPHeaderField的Range属性，开启运行循环，NSURLConnection的代理方法作为运行循环的事件源，接收到下载数据时代理方法就会持续调用，并使用NSOutputStream管道流进行数据保存。</p>
<p>NSURLSession进行断点下载，当暂停下载任务后，如果downloadTask（下载任务）为非空，调用<code>cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler</code>这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个NSData参数resumeData，如果resumeData非空，我们就保存这个对象到视图控制器的resumeData属性中，在点击再次下载时，通过调用<code>[ [self.session downloadTaskWithResumeData:self.resumeData]resume]</code>方法进行继续下载操作</p>
<p>经过以上比较可以发现，使用NSURLSession进行断点下载更加便捷.</p>
<h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>NSURLSession的构造方法<code>（sessionWithConfiguration:delegate:delegateQueue）</code>中有一个NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比较与NSURLConnection依赖与一个全局的配置对象，缺乏灵活性而言，NSURLSession有很大的改进了。(关于配置信息，后面会讲解到)</p>
<p>通过以上几点，大概知道了NSURLSession和NSURLConnection的区别，想必下载再遇到这样的问题不会支支吾吾了。下面来点NSURLSession的干货。</p>
<hr>
<p><strong><p align="center">干货开始</p></strong></p>
<hr>
<h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h3><p>NSURLSession 为 HTTP 数据传输提供一系列的接口，而使用 NSURLSession 总共只需要三步：</p>
<ol>
<li>创建NSURLSession对象</li>
<li>通过 NSURLSession 的实例创建 Task</li>
<li>执行 Task</li>
</ol>
<h5 id="如何获取Session对象"><a href="#如何获取Session对象" class="headerlink" title="如何获取Session对象"></a>如何获取Session对象</h5><p> 1.获取默认的 Session 对象</p>
<pre><code>/*
 * 用于基本的网络请求，可以几行代码就获取 URL 的内容，使用简单
 * 无法不断的获取服务器返回的数据
 * 无法修改默认的连接行为
 * 身份验证的能力有限
 * 任务在后台时无法上传和下载
 */
+ (NSURLSession *)sharedSession;
</code></pre><p> 2.自定义 Session 对象</p>
<pre><code> // 不用代理
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;
// 用代理
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration
                                  delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate
                             delegateQueue:(nullable NSOperationQueue *)queue;
</code></pre><p>在使用自定义方式创建NSURLSession对像时，都需要传入一个NSURLSessionConfiguration参数，这个参数是对Session的网络请求的基本配置。那这个NSURLSessionConfiguration都有哪些配置呢？接着往下看</p>
<h3 id="NSURLSessionConfiguration"><a href="#NSURLSessionConfiguration" class="headerlink" title="NSURLSessionConfiguration"></a>NSURLSessionConfiguration</h3><p>有三个方法来创建NSURLSessionConfiguration:</p>
<ul>
<li><strong>defaultSessionConfiguration</strong> 使用全局的cache，cookie,使用硬盘来缓存数据。</li>
<li><strong>ephemeralSessionConfiguration</strong> 临时session配置，与默认配置相比，这个配置不会将缓存、cookie等存在本地，只会存在内存里，所以当程序退出时，所有的数据都会消失</li>
<li><strong>backgroundSessionConfiguration</strong> 后台session配置，与默认配置类似，不同的是会在后台开启另一个线程来处理网络数据。</li>
</ul>
<p>一旦创建了NSURLSessionConfiguration就可以给它设置各种属性</p>
<p><strong>看NSURLSessionConfiguration的头文件:</strong></p>
<pre><code>@interface NSURLSessionConfiguration : NSObject &lt;NSCopying&gt;

/* 三种创建方式 */

+ (NSURLSessionConfiguration *)defaultSessionConfiguration;
+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;
+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0);

/* 当使用上述第三种方式创建后台sessionConfiguration时可以读到初始化时传入的唯一标识，其他创建方式都为空 */
@property (nullable, readonly, copy) NSString *identifier;

/* 
缓存策略，默认值是NSURLRequestUseProtocolCachePolicy
 */
@property NSURLRequestCachePolicy requestCachePolicy;

/* 给request指定每次接收数据超时间隔，如果下一次接受新数据用时超过该值，则发送一个请求超时给该request。默认为60s */
@property NSTimeInterval timeoutIntervalForRequest;

/* 给指定resource设定一个超时时间，resource需要在时间到达之前完成。默认是7天。 */
@property NSTimeInterval timeoutIntervalForResource;

/* 指定网络传输类型。精切指出传输类型，可以让系统快速响应，提高传输质量，延长电池寿命等。
typedef NS_ENUM(NSUInteger, NSURLRequestNetworkServiceType)
{
    NSURLNetworkServiceTypeDefault = 0,    // 普通网络传输，默认使用这个
    NSURLNetworkServiceTypeVoIP = 1,    // 网络语音通信传输，只能在VoIP使用
    NSURLNetworkServiceTypeVideo = 2,    // 影像传输
    NSURLNetworkServiceTypeBackground = 3, // 网络后台传输，优先级不高时可使用。对用户不需要的网络操作可使用
    NSURLNetworkServiceTypeVoice = 4       // 语音传输
};
 */
@property NSURLRequestNetworkServiceType networkServiceType;

/* 是否使用蜂窝网络，默认是yes. */
@property BOOL allowsCellularAccess;

/* 是否由系统根据性能自动裁量后台任务。默认值是NO。同sessionSendsLaunchEvent一样，只对后台configuration有效。 */
@property (getter=isDiscretionary) BOOL discretionary NS_AVAILABLE(10_10, 7_0);

/* 
如果要为app的插件提供session，需要给这个值赋值
 */
@property (nullable, copy) NSString *sharedContainerIdentifier NS_AVAILABLE(10_10, 8_0);

/* 
 表示当后台传输结束时，是否启动app.这个属性只对 后台sessionConfiguration 生效，其他configuration类型会自动忽略该值。默认值是YES。
 */
@property BOOL sessionSendsLaunchEvents NS_AVAILABLE(NA, 7_0);

/* 
指定了会话连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性,默认为NULL
*/
@property (nullable, copy) NSDictionary *connectionProxyDictionary;

/* 确定是否支持SSLProtocol版本的会话
 */
@property SSLProtocol TLSMinimumSupportedProtocol;

/* 
确定是否支持SSLProtocol版本的会话
*/
@property SSLProtocol TLSMaximumSupportedProtocol;

/* 
它可以被用于开启HTTP管道，这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的
 */
@property BOOL HTTPShouldUsePipelining;

/* 
默认为yes,是否提供来自shareCookieStorge的cookie，如果想要自己提供cookie，可以使用HTTPAdditionalHeaders来提供。
 */
@property BOOL HTTPShouldSetCookies;

/* Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage. */
@property NSHTTPCookieAcceptPolicy HTTPCookieAcceptPolicy;

/* 
指定了一组默认的可以设置出站请求的数据头。这对于跨会话共享信息，如内容类型，语言，用户代理，身份认证，是很有用的。
例如：
    @{@&quot;Accept&quot;: @&quot;application/json&quot;,
     @&quot;Accept-Language&quot;: @&quot;en&quot;,
     @&quot;Authorization&quot;: authString,
     @&quot;User-Agent&quot;: userAgentString
   }
 */
@property (nullable, copy) NSDictionary *HTTPAdditionalHeaders;

/* 
同时连接一个host的最大数。iOS默认是4.APP是作为一个整体来看的
 */
@property NSInteger HTTPMaximumConnectionsPerHost;

/* 
存储cookie，清除存储，直接set为nil即可。
对于默认和后台的session，使用sharedHTTPCookieStorage。
对于短暂的session，cookie仅仅储存到内存，session失效时会自动清除。
 */
@property (nullable, retain) NSHTTPCookieStorage *HTTPCookieStorage;

/* 
证书存储，如果不使用，可set为nil.
默认和后台session，默认使用的sharedCredentialStorage.
短暂的session使用一个私有存储在内存中。session失效会自动清除。
 */
@property (nullable, retain) NSURLCredentialStorage *URLCredentialStorage;

/* 
缓存NSURLRequest的response。
默认的configuration，默认值的是sharedURLCache。
后台的configuration，默认值是nil
短暂的configuration，默认一个私有的cache于内存，session失效，cache自动清除。
*/
@property (nullable, retain) NSURLCache *URLCache;

/* Enable extended background idle mode for any tcp sockets created.    Enabling this mode asks the system to keep the socket open
 *  and delay reclaiming it when the process moves to the background (see https://developer.apple.com/library/ios/technotes/tn2277/_index.html) 
 */
@property BOOL shouldUseExtendedBackgroundIdleMode NS_AVAILABLE(10_11, 9_0);

/* 
处理NSURLRequest的NSURLProtocol的子类。
重要:对后台Session失效。
 */
@property (nullable, copy) NSArray&lt;Class&gt; *protocolClasses;

@end
</code></pre><p>现在，我们知道如何来创建一个Session对象了，创建完Session对象，根据一个Request对象我们就可以发送网络请求了。下面看一下NSURLSession的头文件中的这些方法，如图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/NSURLSession1.png?raw=true"><br></div>

<p>从这些方法中得知，分别返回了<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>，<code>NSURLSessionStreamTask</code> 这四个类的对象，那么这四个类是干什么呢？我们接着往下看。</p>
<h3 id="URLSessionTask"><a href="#URLSessionTask" class="headerlink" title="URLSessionTask"></a>URLSessionTask</h3><p>NSURLSessionTask是一个抽象类，其下有4个实体子类可以直接使用：<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>、<code>NSURLSessionStreamTask</code>。这四个子类封装了现代程序四个最基本的网络任务：获取数据，比如JSON或者XML，上传文件和下载文件还有数据流的获取。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/NSURLSessionTask.png?raw=true"><br></div>

<p>NSURLSession比NSURLConnection最方便的地方就是任务可以暂停，继续。在网络请求中，真正去执行下载或者上传任务的就是URLSessionTask，我们来看一下它常用的方法：</p>
<p><code>- (void)resume;</code> 当使用NSURLSession创建一个NSURLSessionTask任务时，要手动调用此方法，任务才会开启，而NSURLConnection默认开启。</p>
<p><code>- (void)suspend;</code> 暂停任务方法，手动调用会暂停当前任务，再次开启此任务时，会从紧接上次任务开始，会面会说到如何暂停任务再开启任务。</p>
<p><code>- (void)cancel;</code> 取消任务。</p>
<p>NSURLSessionTask还有个属性，<code>@property (readonly) NSURLSessionTaskState state;</code> 此属性标识当前任务的状态，枚举类型</p>
<pre><code>typedef NS_ENUM(NSInteger, NSURLSessionTaskState) {
    NSURLSessionTaskStateRunning = 0,                     /* 正在执行 */
    NSURLSessionTaskStateSuspended = 1,                   /* 暂停状态 */
    NSURLSessionTaskStateCanceling = 2,                   /* 取消状态*/
    NSURLSessionTaskStateCompleted = 3,                   /* 任务完成状态 */
}
</code></pre><p>上面说到的四个类，都直接或间接继承NSURLSessionTask，所有NSURLSessionTask的方法或者属性这四个类都有，那么，简单说一下这四个类都是干什么的。</p>
<h4 id="NSURLSessionDataTask"><a href="#NSURLSessionDataTask" class="headerlink" title="NSURLSessionDataTask"></a>NSURLSessionDataTask</h4><p>NSURLSessionDataTask是开发中使用频率最高的，我们平常使用的GET和POST请求都是通过它来实现的，如果请求的数据简单并且不需要对获取的数据进行复杂操作，我们使用 Block 解析返回的数据即可。具体代码如下：</p>
<h5 id="简单-Get-请求"><a href="#简单-Get-请求" class="headerlink" title="简单 Get 请求"></a>简单 Get 请求</h5><pre><code>/**
 *  简单 GET 请求
  */
- (void)getWithsharedSession
{
  // 获取默认 Session
  NSURLSession *session = [NSURLSession sharedSession];
  // 创建 URL
  NSURL *url = [NSURL URLWithString:@&quot;https://www.baidu.com/s?wd=test&quot;];
  // 创建任务 task
  NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
    // 获取数据后解析并输出
     NSString *dataStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    NSLog(@&quot;%@&quot;,dataStr);
  }];
  // 启动任务
  [task resume];
}
</code></pre><h5 id="简单-POST-请求"><a href="#简单-POST-请求" class="headerlink" title="简单 POST 请求"></a>简单 POST 请求</h5><pre><code>/**
 *  简单 Post 请求，POST 和 GET 请求在于对 request 的处理不同，其余和 GET 相同
 */
- (void)postWithSharedSession
{
  // 获取默认 Session
  NSURLSession *session = [NSURLSession sharedSession];
  // 创建 URL
  NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login&quot;];
  // 创建 request
  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
  // 请求方法
  request.HTTPMethod = @&quot;POST&quot;;
  // 请求体
  request.HTTPBody = [@&quot;username=1234&amp;pwd=4321&quot; dataUsingEncoding:NSUTF8StringEncoding];
  // 创建任务 task
  NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
          // 获取数据后解析并输出
          NSLog(@&quot;%@&quot;,[NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);
  }];
  // 启动任务
  [task resume];
}
</code></pre><p>另外我们也可以设置session的代理来实时的监听数据，我们可以使用NSURLSession的<code>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;</code>和<code>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue;</code>这两个方法来设置代理，具体的协议为<code>NSURLSessionDelegate</code>，它有四个直接或间接子协议<code>NSURLSessionTaskDelegate</code>，<code>NSURLSessionDownloadDelegate</code>和 <code>NSURLSessionStreamDelegate</code>、<code>NSURLSessionDataDelegate</code>。具体代理方法如下：</p>
<pre><code>//创建有代理的session
- (void)sessionDataDelegate
{
    // 创建带有代理方法的自定义 session
    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];

    // 创建任务
    NSURLSessionDataTask *task = [session dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=1234&amp;pwd=4321&quot;]]];

    // 启动任务
    [task resume];
}

#pragma mark -
#pragma mark - NSURLSessionDelegate

// 1. 接收到服务器的响应
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler
{
    NSLog(@&quot;接收到服务器的响应&quot;);
    // 必须设置对响应进行允许处理才会执行后面两个操作。
    completionHandler(NSURLSessionResponseAllow);
}

// 2. 接收到服务器的数据（可能调用多次）
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {
    // 处理每次接收的数据
    NSLog(@&quot;接受到服务器的数据%s&quot;,__func__);
}

// 3. 请求成功或者失败（如果失败，error有值）
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {
    // 请求完成,成功或者失败的处理
    NSLog(@&quot;SessionTask %s&quot;,__func__);
}
</code></pre><h4 id="NSURLSessionDownloadTask"><a href="#NSURLSessionDownloadTask" class="headerlink" title="NSURLSessionDownloadTask"></a>NSURLSessionDownloadTask</h4><p>NSURLSessionDownloadTask在下载文件的时候，是将数据一点点地写入本地的临时文件。所以在 completionHandler 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：</p>
<pre><code>/**
 *  NSURLSessionDownloadTask 下载任务
 */
- (void)downLoad
{
    NSURLSession *session = [NSURLSession sharedSession];
    NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/images/minion_01.png&quot;] ;
    NSURLSessionDownloadTask *task = [session downloadTaskWithURL:url completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) {
        // location 是沙盒中 tmp 文件夹下的一个临时 url，文件下载后会存到这个位置，由于 tmp 中的文件随时可能被删除，所以我们需要自己需要把下载的文件挪到 Caches 文件夹中
        NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename];
        // 剪切文件
        [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:path] error:nil];
        NSLog(@&quot;%@&quot;,[NSThread currentThread]);
        //切记当前为子线程，
        dispatch_async(dispatch_get_main_queue(), ^{
            self.imageView.image = [UIImage imageNamed:path];
        });

    }];
    // 启动任务
    [task resume];
}
</code></pre><p>代理方法下载</p>
<pre><code>/**
 *  NSURLSessionDownloadTask 代理
 */
- (void)sessionDownloadTaskDelegate
{
  // 创建带有代理方法的自定义 session
  NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];

  // 创建任务
  NSURLSessionDownloadTask *task = [session downloadTaskWithURL:[NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/images/minion_02.png&quot;]];

  // 启动任务
  [task resume];
}
#pragma mark -
#pragma mark -NSURLSessionDownloadDelegate
/**
 *  写入临时文件时调用
 *  @param bytesWritten              本次写入大小
 *  @param totalBytesWritten         已写入文件大小
 *  @param totalBytesExpectedToWrite 请求的总文件的大小
 */
- (void)URLSession:(NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
{
    //可以监听下载的进度
  CGFloat progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
  NSLog(@&quot;downloadTask %f&quot;,progress);
}

// 2. 下载完成调用
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location
{
  // location 还是一个临时路径,需要自己挪到需要的路径（caches 文件夹）
  NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];
  [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:filePath] error:nil];
  NSLog(@&quot;downloadTask 移动文件路径&quot;);
}
</code></pre><h5 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h5><p>说一下开发中经常用到的断点续传。在开发中，我们经常由于某种原因，在下载或上传的时候往往不能一次性下载或上传完，有可能下载或上传了一半就终止了，这时候当条件满足继续下载或上传时，我们不希望从头开始，这时候就可以使用断点续传。它的大概思路是：</p>
<ul>
<li>某种限制，续传暂停</li>
<li>将暂停后数据（当前数据）保存起来–_resumeData = resumeData;</li>
<li>条件允许续传时，使用resumeData创建新的NSURLSessionTask</li>
</ul>
<p>代码：</p>
<pre><code>- (IBAction)startDowning:(id)sender {


    if (_resumeData) {
        _downloadTask = [_session downloadTaskWithResumeData:_resumeData];
    }else {
        _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil];
        _request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:@&quot;http://image.baidu.com/search/down?tn=download&amp;ipn=dwnl&amp;word=download&amp;ie=utf8&amp;fr=result&amp;url=http%3A%2F%2Fb.zol-img.com.cn%2Fdesk%2Fbizhi%2Fimage%2F6%2F960x600%2F1427787678554.jpg&amp;thumburl=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D1996019669%2C1779575266%26fm%3D21%26gp%3D0.jpg&quot;]];
        _downloadTask = [_session downloadTaskWithRequest:_request];
    }
    [_downloadTask resume];
}

- (IBAction)stopDowning:(id)sender {
    if (_downloadTask) {
        __weak typeof (self)weakSelf = self;
        [_downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) {
            NSLog(@&quot;%@&quot;,resumeData);
            weakSelf.resumeData = resumeData;
            weakSelf.downloadTask = nil;
        }];
    }
}

#pragma mark -
#pragma mark - NSURLSessionDownloadDelegate

- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location {
    NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];
    // 剪切文件
    [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:path] error:nil];

    dispatch_async(dispatch_get_main_queue(), ^{
        self.imageView.image = [UIImage imageNamed:path];
    });
}
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
    CGFloat progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
    NSLog(@&quot;downloadTask %f&quot;,progress);
    dispatch_async(dispatch_get_main_queue(), ^{
        self.progressView.progress = progress;
    });

}
</code></pre><p><strong>注意：</strong>上面的代码是不会断点续传的，原因是这个图片的url不支持断点续传，在断点续传时，要和服务器配合好。</p>
<h4 id="NSURLSessionUploadTask"><a href="#NSURLSessionUploadTask" class="headerlink" title="NSURLSessionUploadTask"></a>NSURLSessionUploadTask</h4><p>在 NSURLSession 中，文件上传主要使用两种方式：</p>
<pre><code>- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;
</code></pre><p>我们这里使用第二个方法，表单的形式上传数据</p>
<pre><code>- (void)upload {
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://api.weibo.com/2/statuses/public_timeline.json&quot;]];
    //设置HTTP请求方式  GET / POST
    [request setHTTPMethod:@&quot;POST&quot;];
    //设置请求头
    NSString *boundary = @&quot;hwg&quot;;
    [request setValue:[NSString stringWithFormat: @&quot;multipart/form-data;%@&quot;, boundary]forHTTPHeaderField:@&quot;Content-type&quot;];
    //设置请求体
    //获取上传的图片的data
    NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;xiaoxin&quot; ofType:@&quot;jpeg&quot;]];
    //此处添加需要看清楚内容
    NSData *body =  [self httpFormDataBodyWithBoundary:boundary params:@{@&quot;access_token&quot;:@&quot;2.00cYYKWF6EKpiB3883361b1dJiZ4eD&quot;,@&quot;status&quot;:@&quot;哈哈，这是我测试NSURLSession上传文件的微博&quot;} fieldName:@&quot;pic&quot; fileName:@&quot;pic.png&quot; fileContentType:@&quot;image/png&quot; data:data];
    NSURLSession *session = [NSURLSession sharedSession];
    NSURLSessionUploadTask *upload_task = [session uploadTaskWithRequest:request fromData:body completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        NSLog(@&quot;upload  success&quot;);
    }];
    //必须要 resume
    [upload_task resume];
}

#pragma mark-拼接请求体
- (NSData *)httpFormDataBodyWithBoundary:(NSString *)boundary
                                 params:(NSDictionary *)params
                              fieldName:(NSString *)fieldName
                               fileName:(NSString *)fileName
                        fileContentType:(NSString *)fileContentType
                                   data:(NSData *)fileData {

    NSString *preBoundary = [NSString stringWithFormat:@&quot;--%@&quot;,boundary];
    NSString *endBoundary = [NSString stringWithFormat:@&quot;--%@--&quot;,boundary];
    NSMutableString *body = [[NSMutableString alloc] init];
    //遍历
    for (NSString *key in params) {
        //得到当前的key
        //如果key不是当前的pic，说明value是字符类型，比如name：Boris
        //添加分界线，换行，必须使用\r\n
        [body appendFormat:@&quot;%@\r\n&quot;,preBoundary];
        //添加字段名称换2行
        [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;\r\n\r\n&quot;,key];
        //添加字段值
        [body appendFormat:@&quot;%@\r\n&quot;,[params objectForKey:key]];

    }
    //添加分界线，换行
    [body appendFormat:@&quot;%@\r\n&quot;,preBoundary];
    //声明pic字段，文件名为boris.png
    [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;; filename=\&quot;%@\&quot;\r\n&quot;,fieldName,fileName];
    //声明上传文件的格式
    [body appendFormat:@&quot;Content-Type: %@\r\n\r\n&quot;,fileContentType];
    //声明结束符
    NSString *endStr = [NSString stringWithFormat:@&quot;\r\n%@&quot;,endBoundary];
    //声明myRequestData，用来放入http  body
    NSMutableData *myRequestData = [NSMutableData data];
    //将body字符串转化为UTF8格式的二进制
    [myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];
    //将image的data加入
    [myRequestData appendData:fileData];
    //加入结束符--hwg--
    [myRequestData appendData:[endStr dataUsingEncoding:NSUTF8StringEncoding]];
    return myRequestData;
}
</code></pre><p>这里我们需要拼接一个表单数据，才能够上传数据。 当然，我们也可以用代理方法来监听上传的进度</p>
<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task
   didSendBodyData:(int64_t)bytesSent
    totalBytesSent:(int64_t)totalBytesSent
totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
    CGFloat progress = 1.0 * totalBytesSent / bytesSent;
    NSLog(@&quot;downloadTask %f&quot;,progress);
}
</code></pre><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>以上就是我今天总结的，哪里有问题还希望大家提出意见。其实在开发中，我们很少使用到这些，因为总是有一些牛人为我们封装了各种功能的强大库，比如网络类，最常用的就是AFNetworking。人家的库为什么好用，说白了就是各种情况都考虑到了。所有我们要学的还是人家的编程思想。接下来，我会做一个专题，研究一下各大平常使用到的库，它们到底牛在哪里，敬请阅读！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天去面试，被问了一道AFNetworking2.0和3.0有什么区别，当时心想，这谁不知道啊，随口答到：2.0使用的NSURLConnection,3.0使用的是NSURLSession,人家又问NSURLSesstion和NSURLConnection有什么区别，瞬间傻眼了，支支吾吾只是说出了缓存策略的不同。亡羊补牢，为时未晚，这篇博客就讲解一下它们两者到底有什么区别。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://www.guiyongdong.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="NSURLSession" scheme="http://www.guiyongdong.com/tags/NSURLSession/"/>
    
  </entry>
  
  <entry>
    <title>2016-11-18-随想</title>
    <link href="http://www.guiyongdong.com/2016/11/18/2016-11-18-%E9%9A%8F%E6%83%B3/"/>
    <id>http://www.guiyongdong.com/2016/11/18/2016-11-18-随想/</id>
    <published>2016-11-18T04:36:10.000Z</published>
    <updated>2016-11-18T06:06:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天我生日，可是却不是那么的开心，最主要的还是工作上的事。今天上午还去了中移在线面试，可能是我太自信了，在面试前没有做任何的准备，可想而知，今天被虐了，瞬间打击了自己的自信心。造成这种情况很大一部分还是自己的基础没打牢固，怪谁呢？只能怪自己。</p>
<p>说一下最近的经历吧。</p>
<p>本身在大学就是学的计算机编程，还是那句话，当有充足的时间让我来学习的时候，我却在荒废。好了，等到毕业的时候才发现，自己什么都不会，什么都做不成。那时iOS大热，自己就决定投入到这个大热的行业中。来到了酒运达，当时来面试的时候，第一感觉就是公司人很多，这个公司不错。而且公司项目也很多，在这段时候我也很快的充实自己，并且还得到了领导的赏识，工资也提高了，感觉自己都快进入人生的小巅峰了。那个时候感觉自己特牛逼，iOS开发就这样，领导给的任务很快就做完，自我感觉非常良好。其实现在想想，到不如好好的把基础打实。怪自己吧。好景不长，今年7月份公司开始进入危险期，资金不足，裁了好多人，当时还庆幸自己没被裁。可到现在呢？已经将近4个月没有口粮了，哎，惨啊。</p>
<p>趁现在时间充足，好好的恶补一下基础知识吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我生日，可是却不是那么的开心，最主要的还是工作上的事。今天上午还去了中移在线面试，可能是我太自信了，在面试前没有做任何的准备，可想而知，今天被虐了，瞬间打击了自己的自信心。造成这种情况很大一部分还是自己的基础没打牢固，怪谁呢？只能怪自己。&lt;/p&gt;
&lt;p&gt;说一下最近的经历
    
    </summary>
    
      <category term="随想" scheme="http://www.guiyongdong.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="随想" scheme="http://www.guiyongdong.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://www.guiyongdong.com/2016/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.guiyongdong.com/2016/11/15/排序算法总结/</id>
    <published>2016-11-15T03:40:05.000Z</published>
    <updated>2016-11-16T08:26:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十大排序算法比较图"><a href="#十大排序算法比较图" class="headerlink" title="十大排序算法比较图"></a>十大排序算法比较图</h3><hr>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/15.png?raw=true"><br></div>



<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<p><strong>算法描述</strong><br><strong>冒冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</strong></p>
<p><strong>算法实现</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortBubble:(NSMutableArray *)targetArray {
    BOOL flag = true;  //flag 用来做标记
    NSInteger num = 0; //标记总比较次数
    for (NSInteger i = 0; i &lt; targetArray.count&amp;&amp;flag; i++) { //若flag为true  则退出循环
        flag = false;   //初始是false
        for (NSInteger j = 0; j &lt; targetArray.count - i-1; j++) {
            num++;
            NSLog(@&quot;---%ld&quot;,num);
            if ([targetArray[j] integerValue] &gt; [targetArray[j+1] integerValue]) {
                id temp = targetArray[j];
                targetArray[j] = targetArray[j+1];
                targetArray[j+1] = temp;
                flag = true;
            }
        }
    }
    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><a id="more"></a>
<p><strong>时间复杂度:</strong><br>分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据上面的代码可以推断就是n-1次的比较。没有数据交换，时间复杂度是O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较:1+2+3+…+(n-1)=n(n-1)/2次，因此总的时间复杂度是O(n<sup>2</sup>)。</p>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/16.gif?raw=true"><br></div>



<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><hr>
<p><strong>算法描述</strong><br><strong>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</strong></p>
<p><strong>算法实现</strong></p>
<ol>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortSimple:(NSMutableArray *)targetArray {
    NSInteger min;
    for (NSInteger i = 0; i &lt; targetArray.count - 1; i++) {
        min = i; //将当前下标定义为最小值下标
        for (NSInteger j = i + 1; j &lt; targetArray.count; j++) {
            if (targetArray[min] &gt; targetArray[j]) { //如果有小于当前最小值得关键字
                min = j; //将此关键字的下标赋值给min
            }
        }
        if (i != min) {  //如果min和i不相等  说明找到最小值，交换
            id temp = targetArray[i];
            targetArray[i] = targetArray[min];
            targetArray[min] = temp;
        }
    }
    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><p><strong>时间复杂度：</strong><br>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较n-1+n-2+…+1=n(n-1)/2次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就是初始降序时2，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n<sup>2</sup>)。</p>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/17.gif?raw=true"><br></div>


<p>应该说，尽管与冒泡排序的时间复杂度同为O(n<sup>2</sup>)，但简单选择排序的性能上还是要略优于冒泡排序。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><hr>
<p><strong>算法描述</strong></p>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p><strong>算法实现</strong></p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortInsertion:(NSMutableArray *)targetArray {
    for (NSInteger i = 1; i &lt; targetArray.count; i++) {
        id key = targetArray[i];
        NSInteger j = i - 1;
        while (j &gt;= 0 &amp;&amp; targetArray[j] &gt; key) {
            targetArray[j+1] = targetArray[j];
            j--;
        }
        targetArray[j+1]=key;
    }
    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/18.gif?raw=true"><br></div>


<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr>
<p><strong>算法描述</strong><br>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p>
<p><strong>算法实现</strong><br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortShell:(NSMutableArray *)targetArray {
    NSInteger increment = targetArray.count;
    NSInteger i,j;
    do {
        increment = increment/3+1;//增量序列
        for (i=increment; i&lt;targetArray.count; i++) {
            if ([targetArray[i] integerValue] &lt; [targetArray[i-increment] integerValue]) {
                id temp = targetArray[i];
                for (j=i-increment; j&gt;=0&amp;&amp;[targetArray[j] integerValue] &gt; [temp integerValue]; j-=increment) {
                    targetArray[j+increment] = targetArray[j];
                }
                targetArray[j+increment] = temp;
            }
        }

    } while (increment &gt; 1);

    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/19.jpg?raw=true"><br></div>


<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<p><strong>算法描述</strong><br>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>算法实现</strong></p>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortHeap:(NSMutableArray *)targetArray {
    NSInteger heapSize = targetArray.count;
    id temp;
    //建堆
    for (NSInteger i = heapSize/2-1; i&gt;=0; i--) {
        [self heapify:targetArray index:i lenght:heapSize];
    }
    //堆排序
    for (NSInteger j = heapSize-1; j &gt;= 1; j--) {
        temp = targetArray[0];
        targetArray[0] = targetArray[j];
        targetArray[j] = temp;
        [self heapify:targetArray index:0 lenght:--heapSize];
    }
    NSLog(@&quot;%@&quot;,targetArray);
}

- (void)heapify:(NSMutableArray *)targetArray index:(NSInteger)x lenght:(NSInteger)len {
    NSInteger l=2*x+1,r=2*x+2,largest=x;
    id temp;
    if (l &lt; len &amp;&amp; [targetArray[l] integerValue] &gt; [targetArray[largest] integerValue]) {
        largest = l;
    }
    if (r &lt; len &amp;&amp; [targetArray[r] integerValue] &gt; [targetArray[largest] integerValue]) {
        largest = r;
    }
    if (largest != x) {
        temp = targetArray[x];
        targetArray[x] = targetArray[largest];
        targetArray[largest] = temp;
        [self heapify:targetArray index:largest lenght:len];
    }
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/20.gif?raw=true"><br></div>


<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<p><strong>算法描述</strong><br>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p><strong>算法实现</strong></p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>- (NSMutableArray *)sortMerge:(NSMutableArray *)targetArray {
    NSInteger len = targetArray.count;
    NSInteger middle = len/2;
    if (len &lt; 2) {
        return targetArray;
    }
    NSMutableArray *leftArray = [NSMutableArray arrayWithArray:[targetArray subarrayWithRange:NSMakeRange(0, middle)]];
    NSMutableArray *rightArray = [NSMutableArray arrayWithArray:[targetArray subarrayWithRange:NSMakeRange(middle, len-middle)]];
    NSMutableArray *array = [self merge:[self sortMerge:leftArray] right:[self sortMerge:rightArray]];
    NSLog(@&quot;%@&quot;,array);
    return array;

}

- (NSMutableArray *)merge:(NSMutableArray *)leftArray right:(NSMutableArray *)rightArray {
    NSMutableArray *resultArray = [NSMutableArray array];
    while (leftArray.count &amp;&amp; rightArray.count) {
        if ([leftArray[0] integerValue] &lt;= [rightArray[0] integerValue]) {
            [resultArray addObject:leftArray[0]];
            [leftArray removeObjectAtIndex:0];
        }else {
            [resultArray addObject:rightArray[0]];
            [rightArray removeObjectAtIndex:0];
        }
    }
    while (leftArray.count) {
        [resultArray addObject:leftArray[0]];
        [leftArray removeObjectAtIndex:0];
    }
    while (rightArray.count) {
        [resultArray addObject:rightArray[0]];
        [rightArray removeObjectAtIndex:0];
    }

    return resultArray;
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/21.gif?raw=true"><br></div>


<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr>
<p><strong>算法描述</strong><br>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><strong>算法实现</strong><br>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortQuick:(NSMutableArray *)targetArray {
    [self quick:targetArray left:0 right:targetArray.count-1];
    NSLog(@&quot;%@&quot;,targetArray);
}

- (void)quick:(NSMutableArray *)targetArray left:(NSInteger)left right:(NSInteger)right {
    NSInteger pivot;
    if (left &lt; right) {
        pivot = [self partition:targetArray left:left right:right];
        [self quick:targetArray left:left right:pivot-1];
        [self quick:targetArray left:pivot+1 right:right];
    }
}

- (NSInteger)partition:(NSMutableArray *)targetArray left:(NSInteger)left right:(NSInteger)right {
    id pivotKey = targetArray[left];
    id temp;
    while (left &lt; right) {
        while (left &lt; right &amp;&amp; [targetArray[right] integerValue] &gt; [pivotKey integerValue]) {
            right--;
        }
        temp = targetArray[left];
        targetArray[left] = targetArray[right];
        targetArray[right] = temp;
        while (left &lt; right &amp;&amp; [targetArray[left] integerValue] &lt;= [pivotKey integerValue]) {
            left++;
        }
        temp = targetArray[left];
        targetArray[left] = targetArray[right];
        targetArray[right] = temp;
    }

    return left;
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/22.gif?raw=true"><br></div>














]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;十大排序算法比较图&quot;&gt;&lt;a href=&quot;#十大排序算法比较图&quot; class=&quot;headerlink&quot; title=&quot;十大排序算法比较图&quot;&gt;&lt;/a&gt;十大排序算法比较图&lt;/h3&gt;&lt;hr&gt;
&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/15.png?raw=true&quot; /&gt;&lt;br&gt;&lt;/div&gt;



&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;算法描述&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;冒冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法实现&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换它们两个；&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个；&lt;/li&gt;
&lt;li&gt;重复步骤1~3，直到排序完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)sortBubble:(NSMutableArray *)targetArray {
    BOOL flag = true;  //flag 用来做标记
    NSInteger num = 0; //标记总比较次数
    for (NSInteger i = 0; i &amp;lt; targetArray.count&amp;amp;&amp;amp;flag; i++) { //若flag为true  则退出循环
        flag = false;   //初始是false
        for (NSInteger j = 0; j &amp;lt; targetArray.count - i-1; j++) {
            num++;
            NSLog(@&amp;quot;---%ld&amp;quot;,num);
            if ([targetArray[j] integerValue] &amp;gt; [targetArray[j+1] integerValue]) {
                id temp = targetArray[j];
                targetArray[j] = targetArray[j+1];
                targetArray[j+1] = temp;
                flag = true;
            }
        }
    }
    NSLog(@&amp;quot;%@&amp;quot;,targetArray);
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://www.guiyongdong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>查找算法之线性索引查找法</title>
    <link href="http://www.guiyongdong.com/2016/11/14/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>http://www.guiyongdong.com/2016/11/14/查找算法之线性索引查找法/</id>
    <published>2016-11-14T07:28:07.000Z</published>
    <updated>2016-11-15T03:42:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构，<strong>索引就是把一个关键字与它对应的记录相关联的过程，</strong>一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</p>
<p>索引按照结构可以分为线性索引、树形索引和多级索引。这里只介绍线性索引技术。<strong>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。</strong>这里介绍三种线性索引：<strong>稠密索引、分块索引、倒排索引。</strong></p>
<a id="more"></a>
<h3 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h3><hr>
<p><strong>稠密索引是指在线性索引中，将数据集中的每一个记录对应一个索引项。</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/11.png?raw=true"><br></div>

<p><strong>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列</strong></p>
<p>索引项也有序也就意味着，我们要查找关键字时，可以用到折半，插值，斐波那契等有序查找算法，大大提高了效率。比如上图，我要查找关键字是18的记录，如果直接从右侧的数据表中查找，那只能顺序查找，需要查找6次才可以查到结果。而如果是从左侧的索引表中查找，只需两侧折半查找就可以得到18对应的指针，最终查找到结果。</p>
<p>这显然是稠密索引优点，到时如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说 ，可能就需要反复去访问磁盘，查找性能反而大大下降了。</p>
<h3 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h3><hr>
<p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立索引项，从而减少索引项的个数。</p>
<p><strong>分块有序，是把数据集的记录分成了若干块，并且这些快需要满足两个条件：</strong></p>
<ul>
<li><strong>块内无序，</strong>即每一块内的记录不要求有序，当然，如果块内记录有序更理想，不过块内有序需要大量时间和空间的代价，通常要求快内无序。</li>
<li><strong>块间有序,</strong>例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。</li>
</ul>
<p><strong>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引</strong></p>
<p>如图所示，定义的分块索引的索引项结构分三个数据项：</p>
<ul>
<li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块的最大关键字要大;</li>
<li>存储了块中的记录个数，以便于循环时使用;</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li>
</ul>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/12.png?raw=true"><br></div>

<p>在分块索引表中查找，就是分两步进行：</p>
<ol>
<li>在分块索引表中查找关键字所在的块。由于分块索引表是快间有序的，因此很容易利用折半，插值等算法得到结果。</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找。</li>
</ol>
<p>分块索引的时间复杂度：<br>设n个记录的数据集被平分成m块，每块中有t条记录，显然n=m×t,或者说m=n/t。再假设L<sub>b</sub>为查找索引表的平均查找长度，因最好与最差的等概率原则，所以L<sub>b</sub>的平均长度为(m+1)/2。L<sub>w</sub>为块中查找记录的平均查找长度，同理可知它的平均查找长度为(t+1)/2。这样分块索引查找的平均查找长度为:</p>
<div align="center"><br>ASL<sub>w</sub>=L<sub>b</sub>+L<sub>w</sub>=(m+1)/2+(t+1)/2=(1/2)*((n/t)+t)+1<br></div>

<p>注意上面这个式子的推导是为了让整个分块索引查找长度依赖n和t两个变量。从这里我们得到，平均长度不仅仅取决于数据集的总记录数n，还和每一个块的记录数t有关，最佳的情况就是分的块数m和块中的记录数t相同，此时意味着n=m×t=t<sup>2</sup>,即ASL<sub>w</sub>=(1/2)*((n/t)+t)+1=&radic;n+1</p>
<p>可见，分块索引的效率比之顺序查找的O(n)是高了不少。不过显然它与折半查找的O(logn)相比还是有不小的差距，因此在确定所在块的过程中，由于块间有序，所以可以应用折半，插值等手段来提高效率。</p>
<p>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据表查找等技术的应用中。</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><hr>
<p>在我们使用百度或者谷歌搜索的时候，当我们输入某个信息，搜索引擎都会在短时间内给我们一些结果，如图，它是用到什么算法技术实现的高效查找呢？</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/13.png?raw=true"><br></div>

<p>这里简单介绍，也算是最基础的搜索技术——倒排索引。<br>当然，搜索引擎所使用到的算法绝对比这复杂的多。<br>例如我们看如下两句话：</p>
<ol>
<li>Books and friends should be few but good</li>
<li>A good book is a good friend</li>
</ol>
<p>如图所示，我们将单词做了排序，也就是表格显示了每个不同的单词分别出现在哪篇文章中。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/14.png?raw=true"><br></div>

<p>有了这张表，我们在查每个单词时都能很快的查找到这个单词在哪篇文章。<br>在这里这张单词表就是索引表，索引项的通用结构是：</p>
<ul>
<li>次关键码，例如上表中的“英文单词”</li>
<li>记录号表，例如上表中的“文章编号”</li>
</ul>
<p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构，&lt;strong&gt;索引就是把一个关键字与它对应的记录相关联的过程，&lt;/strong&gt;一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。&lt;/p&gt;
&lt;p&gt;索引按照结构可以分为线性索引、树形索引和多级索引。这里只介绍线性索引技术。&lt;strong&gt;所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。&lt;/strong&gt;这里介绍三种线性索引：&lt;strong&gt;稠密索引、分块索引、倒排索引。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="http://www.guiyongdong.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找算法之有序表查找</title>
    <link href="http://www.guiyongdong.com/2016/11/10/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE/"/>
    <id>http://www.guiyongdong.com/2016/11/10/查找算法之有序表查找/</id>
    <published>2016-11-10T08:46:24.000Z</published>
    <updated>2016-11-15T03:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="折半查找法"><a href="#折半查找法" class="headerlink" title="折半查找法"></a>折半查找法</h3><p><strong>折半查找(Binary Search)技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序(通常从小到大)，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找，不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</strong></p>
<a id="more"></a>
<p>假设现在有这样一个有序数组{0,1,16,24,35,47,59,62,73,88,99}，对它进行查找是否存在62这个数，我们来看折半查找的算法是如何工作的。</p>
<pre><code>/* 折半查找 **/
- (NSInteger)binary_search:(NSArray *)targetArray key:(NSInteger)key {
    NSInteger low,high,mid;
    low = 0;  /*定义最低下标为记录首位*/
    high = targetArray.count-1;  /*记录最高下标为记录末位*/
    while (low &lt;= high) {
        mid = (low + high)/2;   /*折半*/
        if (key &lt; [targetArray[mid] integerValue]) { /*若查找值比中值小*/
            high = mid-1;  /*最高下标调整到中位下标小一位*/
        }else if (key &gt; [targetArray[mid] integerValue]) {  /*若查找值比中值大*/
            low = mid+1;  /*最低下标调整到中位下标大一位*/
        }else {
            return mid;   /*若相等则说明mid即为查找到的位置*/
        }
    }
    return -1;
}
</code></pre><p>具体执行步骤为：</p>
<p>1.程序开始运行，参数targetArray={0,1,16,24,35,47,59,62,73,88,99}, key=62,初始化时，此时low=1,high=10,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/1.png?raw=true"><br></div>

<p>2.开始循环，进行查找。<br>3.开始折半，mid计算得5，由于[targetArray[5] integerValue]=47&lt;key,所以执行了low = mid+1，low=6,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/2.png?raw=true"><br></div>

<p>4.再次循环， mid=(6+10)/2=8,此时[targetArray[8] integerValue]=73&gt;key,所以执行high = mid-1，high=7,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/3.png?raw=true"><br></div>

<p>5.再次循环，mid=(6+7)/2=6,此时[targetArray[6] integerValue]=59&lt;key,所以执行了low = mid+1，low=7,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/4.png?raw=true"><br></div>

<p>6.再次循环，mid=(7+7)/2=7, 此时[targetArray[7] integerValue]=62=key,查找成功，返回7.</p>
<p>该算法还是比较容易理解的，同时它的效率也是非常的高，但到底有多高，我们来计算此算法的时间复杂度。</p>
<p>首先， 将这个数组的查找过程绘制成一棵二叉树，如图所示，从图中可以理解，如果查找的关键字不是中间记录47的话，折半查找等于是把静态有序查找表分成了两棵子树，即查找结果只需要找其中的一半数据即可，等于工作量减少了一半，然后继续折半查找，效率当然是非常高了。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/5.png?raw=true"><br></div>

<p>由<strong>“具有n个结点的完全二叉树的深度为「log2n」+1”</strong> 可以看出，查找关键字的最坏为「log2n」+1  最好情况为1 所以折半算法的时间复杂度为0(logn),它显然好于顺序查找的O(n)时间复杂度了。</p>
<p>不过由于折半查找的前提条件是需要有序顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了，但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>如果对折半查找的第8句代码进行改造，得到如下公式mid=(low+high)/2=low+(high-low)/2;<br>也就是mid等于最低下标low加上最高下标high与low的差的一半，再进一步的改进得到如下方案：mid=low+(high-low)*(key-targetArray[low])/(targetArray[high]-targetArray[low]);<br>这就是插值查找的算法。</p>
<p><strong>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字做比较后的查找方法，其核心就在于插值的计算公式：<br>（key-targetArray[low]）/(targetArray[high]-targetArray[low])。</strong> 应该说从时间复杂度来看，它也是O(logn),但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多，反之，数组中如果分布类似{0,1,2,2000,200,…..,999998,999999}这种极端不均匀的数据，用插值查找未必是最合适的选择。</p>
<h3 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h3><p><strong>斐波那契查找(Fibonacci Search)，它是利用了黄金分割原理来实现的。斐波那契数列：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/6.png?raw=true"><br></div>

<p>上代码：</p>
<pre><code>/* 斐波那契查找 */
1  - (NSInteger)fibonacci_Search:(NSMutableArray *)targetArray key:(NSInteger)key {
2     NSArray *F = @[@0,@1,@1,@2,@3,@5,@8,@13,@21,@34];  /*斐波那契数列*/
3     NSInteger low,high,mid,i,k,n;
4     low = 0;  /*定义最低下标为记录首位*/
5     high = targetArray.count-1;  /*定义最高下标为记录末位*/
6     k = 0;
7     n = targetArray.count-1;
8     while (n &gt; [F[k] integerValue] - 1) {
9         k++;
10    }
11    for (i = n; i&lt;[F[k] integerValue]-1; i++) {  /*将不满的数值补齐*/
12        targetArray[i]=targetArray[n];
13    }

14    while (low &lt;= high) {
15        mid = low + [F[k-1] integerValue] - 1;  /*计算当前分割的下标*/
16        if (key &lt; [targetArray[mid] integerValue]) {  /*若查找记录小于当前分割记录*/
17            high = mid - 1;   /*最高下标调整到分割下标mid-1处*/
18            k = k - 1;  /*斐波那契数列下标减一位*/
19        }else if (key &gt; [targetArray[mid] integerValue]) {  /*若查找记录大于当前分割记录*/
20            low = mid + 1;   /*最低下标调整到分割下标mid+1处*/
21            k = k - 2;   /*斐波那契数列下标减两位*/
22        }else {
23            if (mid &lt;= n) {
24                return mid;  /*若相等则说明mid即为查找到的位置*/
25            }else {
26                return n;   /*若mid&gt;n说明是补全数值，返回n*/
27            }
28        }
29    }
30    return -1;
31  }
</code></pre><p>1.程序开始运行，参数targetArray={0,1,16,24,35,47,59,62,73,88,99},要查找的关键字key=59。注意此时我们已经有了事先计算好的全局变量数值F的具体数据，它的斐波那契数列，F={0,1,1,2,3,5,8,13,21,…..}。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/7.png?raw=true"><br></div>

<p>2.第6~10行是计算当前的n处于斐波那契数列的位置，现在n=10，F[6]&lt;n&lt;F[7],所以计算得出k=7。</p>
<p>3.第11~13行，由于k=7,计算时是以F[7]=13<br>为基础，而a中最大的仅是a[10],后面的a[11],a[12]均为赋值，这不能构成有序数列，因此将它们都赋值为最大的数值值，所以此时a[11]=a[12]=a[10]=99。</p>
<p>4.第14~29行查找正式开始。</p>
<p>5.第15行，mid=0+F[7-1]-1=7,也就是说，我们第一个要对比的数值是从下标为7开始的。</p>
<p>6.由于此时key=59 而targetArray[7]=62,因此执行第17~18行，得到high=6,k=6,</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/8.png?raw=true"><br></div>

<p>7.再次循环，mid=0+F[6-1]-1=4。此时targetArray[4]=35&lt;key,因此执行20~21行，得到low=4+1=5,k=6-2=4,注意此时k下调2个单位。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/9.png?raw=true"><br></div>

<p>8.再次循环，mid=5+F[4-1]-1=6。此时targetArray[6]=59=key,因此执行第24行，返回mid=6。程序结束运行。</p>
<p>斐波那契查找算法的核心在于：</p>
<ol>
<li>当key=targetArray[mid]时，查找就成功；</li>
<li>当key=targetArray[mid]时,新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个；</li>
<li>当key&gt;targetArray[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个。</li>
</ol>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/10.png?raw=true"><br></div>

<p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些，所以尽管斐波那契查找的时间复杂度也为O(logn)，但就平均性能来说，斐波那契查找要优于折半查找。可惜如果最坏情况，比如这里key=1,那么始终都处于左侧长半区在查找，则查找效率要低折半查找。</p>
<p>还有比较关键的一点，折半查找是进行加法与除法运算(mid=(low+high)/2)，插值查找进行复杂的四则运算(mid=low+(high-low)*(key-targetArray[high]-targetArray[low])),而斐波那契查找只是最简单加减法运算(mid=low+F[k-1]-1),在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。</p>
<p>以上三种有序表的查找本质上是分割点的选择不同，各有各的优劣，实际开发中，可以根据数据的特点综合考虑再做出选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;折半查找法&quot;&gt;&lt;a href=&quot;#折半查找法&quot; class=&quot;headerlink&quot; title=&quot;折半查找法&quot;&gt;&lt;/a&gt;折半查找法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;折半查找(Binary Search)技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序(通常从小到大)，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找，不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="http://www.guiyongdong.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找算法之顺序表查找</title>
    <link href="http://www.guiyongdong.com/2016/11/10/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>http://www.guiyongdong.com/2016/11/10/查找算法之顺序表查找法/</id>
    <published>2016-11-10T07:45:23.000Z</published>
    <updated>2016-11-15T03:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h3><p><strong>顺序查找法（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或者最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，查找成功，找到查找的记录；如果知道最后一个（或第一个）记录，其关键字和给定值比较都不相等时，则表中没有所查的记录，查找不成功。</strong></p>
<p>顺序查找的算法实现如下：</p>
<pre><code>- (NSInteger)sequential_search:(NSArray *)targetArray key:(id)key {
    NSInteger n = targetArray.count;
    for (int i = 0; i &lt; n; i++) {
        if (targetArray[i] == key) {
            return i;
        }
    }
    return -1;
}
</code></pre><p>这段代码非常简单，就是在数组targetArray中查看有没有关键字（key），当你需要查找复杂表结构的记录时，只需要把数组targetArray和关键字key定义成你需要的表结构和数据类型即可。</p>
<p>对于这种顺序查找算法来说，查找成功最好的情况就是在第一个位置就找到了，算法的时间复杂度为O(1)，最坏的情况是在最后一个位置才找到，需要比较n次，时间复杂度为O(n)，由于关键字在任何一位置的概率相同，所以平均查找次数为(n+1)/2，所以最终时间复杂度还是O(n)。</p>
<p>很显然，顺序查找技术是由很大缺点的，n很大时，查找效率极为地下，不过优点也是有的，这个算法非常简单，对静态查找表的记录没有任何的要求，在一些小型数据的查找时，是可以使用的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;顺序查找法&quot;&gt;&lt;a href=&quot;#顺序查找法&quot; class=&quot;headerlink&quot; title=&quot;顺序查找法&quot;&gt;&lt;/a&gt;顺序查找法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;顺序查找法（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="http://www.guiyongdong.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>iOS触摸事件处理详解</title>
    <link href="http://www.guiyongdong.com/2016/11/09/iOS%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.guiyongdong.com/2016/11/09/iOS触摸事件处理详解/</id>
    <published>2016-11-09T06:39:39.000Z</published>
    <updated>2016-11-09T11:08:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你设计一个app的时候，可能会有这样的场景，你想动态的去响应一个事件。例如，在屏幕上的一个触摸事件可能在不同的对象中都发生，并且你不得不决定由哪一个对象来响应这个事件并且尝试去理解怎么样的一个对象接收了到这个事件。</p>
<p>当一个常见的用户事件发生的时候，UIKit会创建一个事件对象Event Object,该对象包含了事件处理所必须得一些信息。然后它会将事件对象置于激活的app事件队列。例如触摸事件，该触摸时事件对象是一系列触摸信息包装集。例如手势事件，该事件是一个动态的变量它取决于你使用了什么框架以及你感兴趣的手势事件类型。</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>iOS 事件分为三大类</p>
<ul>
<li>触摸事件</li>
<li>加速器事件</li>
<li>远程控制事件</li>
</ul>
<p>这篇博客主要讲解触摸事件<br>触摸事件是我们平时遇到最多的事件，例如单击、长按、滑动等等。当用户点击按钮，到按钮处理回调。整个过程是如何发生，需要什么样的原则，这些都是问题。为了使系统能更加鲜明符合用户的操作逻辑，iOS系统将事件相应过程拆分成两部分：</p>
<ol>
<li>寻找响应链；</li>
<li>事件响应，先将事件通过某种规则来分发，找到处理事件的控件，其次是将事件传递分发，响应。</li>
</ol>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><p><strong>UIEvent</strong><br>iOS将触摸事件定义为第一个手指开始触摸屏幕到最后一个手指离开屏幕定义为一个触摸事件。用类UIEvent表示。</p>
<p><strong>UITouch</strong><br>一个手指第一次点击屏，会形成一个UITouch对象，直到离开销毁。表示触碰。UITouch对象能表明了当前手指触碰的屏幕位置，状态。状态分为开始触碰、移动、离开。</p>
<p>根据定义，UIEvent实际包括了多个UITouch对象。有几个手指触碰，就会有几个UITouch对象。<br>定义代码如下:</p>
<pre><code>@interface UIEvent : NSObject
@property(nonatomic,readonly) UIEventType     type NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly) UIEventSubtype  subtype NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly) NSTimeInterval  timestamp;
#if UIKIT_DEFINE_AS_PROPERTIES
//UITouch SET
@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;
//省略部分代码
@end
</code></pre><p>UIEventType表明了事件类型，UIEvent表示了三大事件。allTouches是该事件的所有UITouch对象的集合。</p>
<pre><code>//UITouch
@interface UITouch : NSObject
@property(nonatomic,readonly) NSTimeInterval      timestamp;
@property(nonatomic,readonly) UITouchPhase        phase;
@property(nonatomic,readonly) NSUInteger          tapCount;   // touch down within a certain point within a certain amount of time
@property(nonatomic,readonly) UITouchType         type NS_AVAILABLE_IOS(9_0);

@property(ullable,nonatomic,readonly,strong) UIWindow                        *window;
@property(nullable,nonatomic,readonly,strong) UIView                          *view;
@property(nullable,nonatomic,readonly,copy)   NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers 
NS_AVAILABLE_IOS(3_2);
//省略部分代码
@end
//Touch 状态枚举
typedef NS_ENUM(NSInteger, UITouchPhase) {
    UITouchPhaseBegan,             // whenever a finger touches the surface.
    UITouchPhaseMoved,             // whenever a finger moves on the surface.
    UITouchPhaseStationary,        // whenever a finger is touching the surface but hasn&apos;t moved since the previous event.
    UITouchPhaseEnded,             // whenever a finger leaves the surface.
    UITouchPhaseCancelled,         // whenever a touch doesn&apos;t end but we need to stop tracking (e.g. putting device to face)
};
</code></pre><p>UITouch中phase表明了手指移动的状态，包括1.开始点击；2.移动；3.保持; 4.离开；5.被取消（手指没有离开屏幕，但是系统不再跟踪它了）</p>
<p>综上，UIEvent就是一组UITouch。每当该组中任何一个UITouch对象的phase发生变化，系统都会产生一条TouchMessage。也就是说每次用户手指的移动和变化，UITouch都会形成状态改变，系统变回会形成Touch message进行传递和派发。那么 一次触摸事件是由一组UITouch对象状态变化引起的一组Touch message的转发和派送。那么事件派发的原则是什么？</p>
<h3 id="响应者"><a href="#响应者" class="headerlink" title="响应者"></a>响应者</h3><p>我们先来了解一下什么是响应者。<br>只要继承了UIResponder的对象就可以作为事件的响应者，下面看一下 UIResponder及其子类的继承关系：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Responder/Responder1.png?raw=true"><br></div>

<p>平常开发中所使用到的控件例如：UIButton,UiView,UIViController,APPDelegate，UIApplication等都能响应事件。与用户交互的控件就是第一响应者，它将作为响应者链的开始，事件首先发送给第一响应者，然后再依次传递下去，直到该事件被某个响应者处理。</p>
<h3 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h3><p>响应链是“事件派发”的原则和规定，那么响应链是什么？顾名思义事件链是一个链条，详细的定义如下:</p>
<ul>
<li>每条链是一个 链表状结构，整个是一棵树</li>
<li>链表的每一个node是一个 UIResponser对象</li>
</ul>
<p>UIResponser,响应链中的响应者，用来接收和处理事件的类，先抛开iOS中的具体传递细节，系统发送UIEvent的Touch message给UIResponser类。UIResponser提供了一下几个函数来做事件处理</p>
<pre><code>//触摸事件
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);

//物理按钮，遥控器上面的按钮在按压状态等状态下的回调
- (void)pressesBegan:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesChanged:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesEnded:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesCancelled:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);

//设备的陀螺仪和加速传感器使用
- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
</code></pre><p>UIResponser包括了各种Touch message 的处理，比如开始，移动，停止等等。</p>
<p>回到响应链，响应链是由UIResponser组成的，那么是按照哪种规则形成的。</p>
<ol>
<li>程序启动<ul>
<li>UIApplication会生成一个单例，并会关联一个APPDelegate。APPDelegate作为整个响应链的根建立起来，而UIApplication会将自己与这个单例链接，即UIApplication的nextResponser(下一个事件处理者)为APPDelegate。</li>
</ul>
</li>
<li>创建UIWindow<ul>
<li>程序启动后，任何的UIWindow被创建时，UIWindow内部都会把nextResponser设置为UIApplication单例。</li>
<li>UIWindow初始化rootViewController, rootViewController的nextResponser会设置为UIWindow</li>
</ul>
</li>
<li>UIViewController初始化<ul>
<li>loadView, VC的view的nextResponser会被设置为VC。</li>
</ul>
</li>
<li>addSubView<ul>
<li>addSubView操作过程中，如果子subView不是VC的View,那么subView的nextResponser会被设置为superView。如果是VC的View,那就是 subView -&gt; subView.VC -&gt;superView</li>
<li>如果在中途，subView.VC被释放，就会变成subView.nextResponser = superView</li>
</ul>
</li>
</ol>
<p>最终形成类似这样一张图</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Responder/Responser2.png?raw=true"><br></div>

<p>其中应该是由箭头的，箭头的方向是朝上，也就是subView指向superView.</p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>有了响应网为基础，事件的传递就比较简单，只需要选择其中一条响应链，但是选择那一条响应链来传递呢？为了弄清真个过程，我们先来查看一下从触摸硬件事件转化为UIEvent消息。</p>
<ol>
<li>首先用户触摸屏幕，系统的硬件进程会获取到这个点击事件，将事件简单处理封装后存到系统中，由于硬件检测进程和当前运行的APP是两个进程，所以进程两者之间传递事件用的是端口通信。硬件检测进程会将事件放入到APP检测的那个端口。</li>
<li>其次，APP启动主线程RunLoop会注册一个端口事件，来检测触摸事件的发生。当时事件到达，系统会唤起当前APP主线程的Runloop。唤起原因就是端口触摸事件，主线程会分析这个事件。</li>
<li>最后，系统判断该次触摸是否导致了一个新的事件, 也就是说是否是第一个手指开始触碰，如果是，系统会先从响应网中 寻找响应链。如果不是，说明该事件是当前正在进行中的事件产生的一个Touch message， 也就是说已经有保存好的响应链。</li>
</ol>
<p>如果是新事件，系统会寻找响应链，为了符合用户的操作习惯，系统会根据用户的点击位置，在当前的整个APP的显示层级中寻找。过程如下：</p>
<ol>
<li>将所有的显示在屏幕上的 “合格的”UIWindow对象 按照层级结构从上到下排列成一个数组。</li>
<li>从第一个UIWindow对象开始，先判断UIWindow是否合格，其次判断 点击位置在不在这个Window内，如果不在 ，返回nil, 就换下一个UIWindow;如果在的话，并且UIWindow没有subView就返回自己，整个过程结束。如果UIWindow有subViews,就从后往前遍历整个subViews,做和UIWindow类似的事情，直到找到一个View。如果没有找到到就不做传递。</li>
<li><strong>合格的UIWindow，UIView。意思是控件被允许接受事件。符合三个条件：1.不能被隐藏；2.alpha值大于0.01(不是backgroundColor为clearColor)；3.isUserInteractionEnabled为YES，打开状态。一般UILabel,UIImageView纯显示的控件默认是关闭状态，也就是不处理事件。</strong></li>
</ol>
<p>显示控件有了两个方法来做上面这件事，就是常说的hitTest</p>
<pre><code> // 先判断点是否在View内部，然后遍历subViews
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  
//判断点是否在这个View内部
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   // default returns YES if point is in bounds
</code></pre><p>整个过程的系统实现大致如下</p>
<pre><code>- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event {
  //判断是否合格
    if (!self.hidden &amp;&amp; self.alpha &gt; 0.01 &amp;&amp; self.isUserInteractionEnabled) {
        //判断点击位置是否在自己区域内部
        if ([self pointInside: point withEvent:event]) {
            UIView *attachedView;
            for (int i = self.subviews.count - 1; i &gt;= 0; i--) {
                UIView *view  = self.subviews[i];
                //对子view进行hitTest
                attachedView =  [view hitTest:point withEvent:event];
                if (attachedView)
                    break;
            }
            if (attachedView)  {
                return attachedView;
            } else {
                return self;
            }
        }
    }
    return nil;
}
</code></pre><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>以上可知默认情况下，用户点击哪个View,系统就会在寻找过程中返回哪个view，但是我们可以重载上面两个方法做如下事情：</p>
<ul>
<li>将控件外部点规整到控件内部。 例如控件较小，点击位置在控件边缘外部，可以重载- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 将外部的点也判断为内部点，这样hitTest就会遍历自己。</li>
<li>重载HitTest更改默认行为。 有时候点击subView的某些特殊位置需要superView处理，我们可以在superView的hitTest，返回superView。这样superView变成首部响应者</li>
</ul>
<blockquote>
<p>hitTest的逻辑代码中会把隐藏，透明（alpha&lt;0.01,不是backgroundColor为clearColor），不交互的view滤过，但不代表hitTest不会被调用，我们可以重载hitTest去让 已经隐藏、透明、不交互的view响应事件。不过最正规的方法是打开控件交互属性。</p>
</blockquote>
<p>以上过程返回的View被称作hitTestView，顺着hitTestView的nextResponser,可以形成一个链，即响应链。 最后指向appDelegate. 并且返回hitTestView之后，系统会持有hitTestView。事件不结束，这个hitTestView不会发生变化，即使用户点击之后将手指移动到其他控件上面，该点击都会绑定开始的hitTestView。当所有手指离开屏幕，事件结束。再次点击，事件重新开始。以上过程再来一次。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>形成响应链之后，UIWindow会把事件目标锁定为hitTestView(响应链头的控件)，当手指状态发生变化， 会不停的发送UITouch Message 给这个hitTestView。 下面这几个方法会被调用。<br>然后控件的以下方法会陆续被调用</p>
<pre><code>//点击刚开始，回调这个方法
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
//点击之后移动，回调这个方法
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
//手指移开，点击结束
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
//点击过程中，事件被手势识别，会回调这个方法，关于手势后面会讲解
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);
</code></pre><h4 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h4><p>由于系统只会把事件发送给 hitTestView，如果你想让hitTestView之后的其他响应者处理该Touch Mesage ，需要自己实现以上几个方法做派发，例如</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event
{
    //do someThiing
  [self.nextResponser touchesBegan: touches withEvent:event];
}
</code></pre><p>事件转发可以做很多事情。大家可以尽可能的想象</p>
<h3 id="手势处理"><a href="#手势处理" class="headerlink" title="手势处理"></a>手势处理</h3><p>以上看来所有的事情都很平稳，无非就是寻找响应链，传递事件等等。但是接下来大家可能需要蒙圈。先来道题目</p>
<ul>
<li>AView 有子view BView，AView上面有一个<strong>单击手势</strong>，这个时候点击BView。默认情况下，Bview的四个Touch方法中，那些方法会被调用？</li>
</ul>
<p>可能很多人会说没有任何影响，基本都会调用，答案是整个过程会调用这两个方法。</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
</code></pre><p>touchEnd不会被调用。<br>为什么？因为有手势的存在，我们先看一下手势。</p>
<h4 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h4><p>手势是苹果为处理常用的用户交互所推出了一个优先级更高的处理技术。为了让用户完成对多种控件的基本操作，苹果实现了以下几个手势</p>
<blockquote>
<p><strong>UITapGestureRecognizer</strong><br><strong>UIPinchGestureRecognizer</strong><br><strong>UIRotationGestureRecognizer</strong><br><strong>UISwipeGestureRecognizer</strong><br><strong>UIPanGestureRecognizer</strong><br><strong>UIScreenEdgePanGestureRecognizer</strong><br><strong>UILongPressGestureRecognizer</strong></p>
</blockquote>
<p>上面包括点击，长按，旋转，滑动等等手势。这样开发者就可以随便将其关联到某个控件上完成交互。<br>先抛开刚才的问题，先看单纯的手势如何识别用户操作。</p>
<p>系统会将用户触摸屏幕的点事件 发送给手势，手势会根据具体的点击位置和序列，判断是否是某种特定行为。具体的判断方法如下</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
</code></pre><p>和UIResponser一样，手势也有这几个方法，点击的每个阶段手势都会响应不同的方法，手势会在以上四个方法中去对手势的State做更改，手势的State表明当前手势是识别还是失败等等。比如单击手势会在touchesBegan 时记录点击位置，然后在touchesEnded判断点击次数、时间、是否移动过，最后得出是否识别该手势。这几个方法一般在自定义手势里面使用。</p>
<h4 id="手势状态"><a href="#手势状态" class="headerlink" title="手势状态"></a>手势状态</h4><pre><code>typedef NS_ENUM(NSInteger, UIGestureRecognizerState) {
    //未知状态
    UIGestureRecognizerStatePossible,   // the recognizer has not yet recognized its gesture, but may be evaluating touch events. this is the default state
    //首次识别状态，对于连续手势，例如长按，有这种状态
    UIGestureRecognizerStateBegan,      // the recognizer has received touches recognized as the gesture. the action method will be called at the next turn of the run loop
    //再次识别，当手连续手势识别之后，再次受到touch事件
    UIGestureRecognizerStateChanged,    // the recognizer has received touches recognized as a change to the gesture. the action method will be called at the next turn of the run loop
    //识别完成，受到touchend 消息之后
    UIGestureRecognizerStateEnded,      // the recognizer has received touches recognized as the end of the gesture. the action method will be called at the next turn of the run loop and the recognizer will be reset to UIGestureRecognizerStatePossible
    //取消识别
    UIGestureRecognizerStateCancelled,  // the recognizer has received touches resulting in the cancellation of the gesture. the action method will be called at the next turn of the run loop. the recognizer will be reset to UIGestureRecognizerStatePossible
    //识别失败
    UIGestureRecognizerStateFailed,     // the recognizer has received a touch sequence that can not be recognized as the gesture. the action method will not be called and the recognizer will be reset to UIGestureRecognizerStatePossible
    // Discrete Gestures – gesture recognizers that recognize a discrete event but do not report changes (for example, a tap) do not transition through the Began and Changed states and can not fail or be cancelled
    //识别状态，与识别结束一个意思
    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded // the recognizer has received touches recognized as the gesture. the action method will be called at the next turn of the run loop and the recognizer will be reset to UIGestureRecognizerStatePossible
};
</code></pre><p>手势的状态有以上几种,我们来看手势的整个迁移过程，先明确几个信息</p>
<ol>
<li>手势的状态迁移只有在它们收到Touch message的时候，才能做状态变化处理代码。</li>
<li>手势分为连续状态手势和不连续状态手势。连续手势有长按，慢滑等。不连续手势有单击，双击等等。</li>
<li>当用户没有点击屏幕，所有手势都处于Possiable状态。</li>
</ol>
<p>当用户点击屏幕，手势会收到Touch Began Message， 手势的touchBegan方法会被调用。手势开始记录点击位置和时间。仍处于Possiable状态。如果用户按住不放，间隔超过一定时间，单击手势会变化为失败状态，并在下个一runloop变为possiable。如果时间大于长按手势设定时间，长按手势就会变化为Began状态，当用户移动手指，长按手势的touch move方法被调用，长按手势将自己状态设置为Change，并且也会回调处理方法。最后手指离开，系统调用长按手势touchEnd方法，手势状态回归为Recognized状态。</p>
<h4 id="手势混合处理"><a href="#手势混合处理" class="headerlink" title="手势混合处理"></a>手势混合处理</h4><p>如果一个View上既有单击，又有双击，用户点击该view两次， 默认情况下，单击被处理，双击不管用。因为默认情况下，一旦事件被某个手势处理，第二个手势会识别失败 幸运的是苹果提供了方法让我们修改这种默认行为，具体的方法如下</p>
<pre><code>@protocol UIGestureRecognizerDelegate &lt;NSObject&gt;
@optional
// called when a gesture recognizer attempts to transition out of UIGestureRecognizerStatePossible. returning NO causes it to transition to UIGestureRecognizerStateFailed
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;

// called when the recognition of one of gestureRecognizer or otherGestureRecognizer would be blocked by the other
// return YES to allow both to recognize simultaneously. the default implementation returns NO (by default no two gestures can be recognized simultaneously)
//
// note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture&apos;s delegate may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;

// called once per attempt to recognize, so failure requirements can be determined lazily and may be set up between recognizers across view hierarchies
// return YES to set up a dynamic failure requirement between gestureRecognizer and otherGestureRecognizer
//
// note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture&apos;s counterpart delegate or subclass methods may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);

// called before touchesBegan:withEvent: is called on the gesture recognizer for a new touch. return NO to prevent the gesture recognizer from seeing this touch
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;

// called before pressesBegan:withEvent: is called on the gesture recognizer for a new press. return NO to prevent the gesture recognizer from seeing this press
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceivePress:(UIPress *)press;

@end
</code></pre><p>上面是手势的代理方法，你可以实现手势的这几个代理方法，更改默认行为。</p>
<ul>
<li>(BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;<br>手势已经应分析出该事件可以响应，再对自己的状态进行更改之前，会询问代理的这个方法是否允许更改。默认为YES，如果你实现并设置为NO,那么手势会变为失败状态，这个可以用在手势只识别View的某几个区域的相应。</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer;<br>当两个手势都对该事件进行识别，但只有一个能响应，另外一个会失败。比如一个View上绑定两个单击事件。为了让两个手势都响应，我们可以实现此方法，让两个手势都响应。</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer NS_AVAILABLE_IOS(7_0);</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer NS_AVAILABLE_IOS(7_0);<br>这两个方法是iOS 7引入的，目的是让两个手势之间增加依赖，比如单击和双击，如果需要单击在双击失败的情况下识别，那么可以实现这两个方法。</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldReceiveTouch:(UITouch )touch;</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldReceivePress:(UIPress )press;<br>这两个方法是判断手势在新的Touch和Press Began阶段是否关注该UITouch和UIPress对象，默认为YES，如果设置为NO,手势不会关注该Touch的任何状态变化。</li>
</ul>
<h4 id="手势与事件响应"><a href="#手势与事件响应" class="headerlink" title="手势与事件响应"></a>手势与事件响应</h4><p>回到我们上面问过的问题，BView只有touchBegan， touchesCancelle 的原因是什么？答案在于整个触摸事件全过程</p>
<ol>
<li>系统会通过hitTest的方法寻找响应链，完成之后会形成下图模型。</li>
</ol>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Responder/Responser3.png?raw=true"><br></div>

<blockquote>
<p>图中最右边是响应链，中间是关联在相应链在视图上的手势</p>
</blockquote>
<ol>
<li>有了模型之后就会发生图上的三个步骤</li>
</ol>
<p>第一步：系统会将所有的 Touch message 优先发送给 关联在响应链上的全部手势。手势根据Touch序列消息和手势基本规则更改自己的状态（有的可能失败，有的可能识别等等）。如果没有一个手势对Touch message 进行拦截（拦截:系统不会将Touch message 发送给响应链顶部响应者)，系统会进入第二步</p>
<p>第二步：系统将Touch message 发送给响应链 顶部的 视图控件，顶部视图控件这个时候就会调用Touch相关的四个方法中的某一个。之后进入自定义Touch message转发</p>
<p>第三步：自定义Touch message转发可以继承UIResponser的四个Touch函数做转发。</p>
<p>解释一下第一步中说的拦截，手势会表明是否拦截该Touch Message,主要由下面三个属性控制。</p>
<p>再回到那道题目，如果我们想hitTestView的toucheEnd函数依然能得到调用，怎么办？其实UIGestureRecognizer有三个属性</p>
<pre><code>@property(nonatomic) BOOL cancelsTouchesInView;       // default is YES. causes touchesCancelled:withEvent: or pressesCancelled:withEvent: to be sent to the view for all touches or presses recognized as part of this gesture immediately before the action method is called.
@property(nonatomic) BOOL delaysTouchesBegan;         // default is NO.  causes all touch or press events to be delivered to the target view only after this gesture has failed recognition. set to YES to prevent views from processing any touches or presses that may be recognized as part of this gesture
@property(nonatomic) BOOL delaysTouchesEnded;         // default is YES. causes touchesEnded or pressesEnded events to be delivered to the target view only after this gesture has failed recognition. this ensures that a touch or press that is part of the gesture can be cancelled if the gesture is recognized
</code></pre><ul>
<li>cancelsTouchesInView<br>  默认为YES,表明当手势识别了该事件，系统会将Touch cancel消息发送给hitTestView ，并调用hitTestView的TouchCancel。设置为NO，不会再收到TouchCancel</li>
<li>delaysTouchesBegan<br>  默认为NO, 表明无论什么情况下，不会拦截Touch began消息。如果设置为YES，只要有一个手势不识别失败，都不会发送Touch began到响应链的第一响应者。</li>
<li>delaysTouchesEnded<br>  默认为NO, 和delaysTouchesBegan类似，不过它是用来控制TouchEnd message的拦截</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>iOS整个事件处理的过程就是这样，系统为完成整个交互做了很多东西，核心点如下：</p>
<ul>
<li>事件分发过程分为：1.寻找响应链；2.事件消息分发</li>
<li>响应网是事件响应的基础，响应链是事件响应的具体路径。</li>
<li>事件消息分发优先发送给手势集合，手势内部会做冲突处理，过滤消息。不被过滤的消息会传递给响应链对象。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你设计一个app的时候，可能会有这样的场景，你想动态的去响应一个事件。例如，在屏幕上的一个触摸事件可能在不同的对象中都发生，并且你不得不决定由哪一个对象来响应这个事件并且尝试去理解怎么样的一个对象接收了到这个事件。&lt;/p&gt;
&lt;p&gt;当一个常见的用户事件发生的时候，UIKit会创建一个事件对象Event Object,该对象包含了事件处理所必须得一些信息。然后它会将事件对象置于激活的app事件队列。例如触摸事件，该触摸时事件对象是一系列触摸信息包装集。例如手势事件，该事件是一个动态的变量它取决于你使用了什么框架以及你感兴趣的手势事件类型。&lt;/p&gt;
    
    </summary>
    
      <category term="杂类" scheme="http://www.guiyongdong.com/categories/%E6%9D%82%E7%B1%BB/"/>
    
    
      <category term="响应者链" scheme="http://www.guiyongdong.com/tags/%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>iOS照片开发之PhotoKit</title>
    <link href="http://www.guiyongdong.com/2016/10/22/iOS%E7%85%A7%E7%89%87%E5%BC%80%E5%8F%91%E4%B9%8BPhotoKit/"/>
    <id>http://www.guiyongdong.com/2016/10/22/iOS照片开发之PhotoKit/</id>
    <published>2016-10-22T08:44:37.000Z</published>
    <updated>2016-11-08T02:32:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>PhotoKit 是一套比 AssetsLibrary 更完整也更高效的库，对资源的处理跟 AssetsLibrary 也有很大的不同。它是iOS8之后出现的框架，在使用框架之前需要导入<code>#import &lt;Photos/Photos.h&gt;</code>库</p>
<a id="more"></a>
<p>首先简单介绍几个概念：</p>
<ul>
<li><strong>PHAsset</strong>: 代表照片库中的一个资源，跟 ALAsset 类似，通过 PHAsset 可以获取和保存资源</li>
<li><strong>PHFetchOptions</strong>: 获取资源时的参数，可以传 nil，即使用系统默认值</li>
<li><strong>PHFetchResult</strong>: 表示一系列的资源集合，也可以是相册的集合</li>
<li><strong>PHAssetCollection</strong>: 表示一个相册或者一个时刻，或者是一个「智能相册（系统提供的特定的一系列相册，例如：最近删除，视频列表，收藏等等，如下图所示）</li>
<li><strong>PHImageManager</strong>: 用于处理资源的加载，加载图片的过程带有缓存处理，可以通过传入一个 PHImageRequestOptions 控制资源的输出尺寸等规格</li>
<li><strong>PHImageRequestOptions</strong>: 如上面所说，控制加载图片时的一系列参数</li>
</ul>
<p>这里还有一个额外的概念PHCollectionList，表示一组PHCollection，它本身也是一个PHCollection，因此PHCollection 作为一个集合，可以包含其他集合，这使到 PhotoKit 的组成比 ALAssetLibrary 要复杂一些。另外与 ALAssetLibrary 相似，一个 PHAsset 可以同时属于多个不同的 PHAssetCollection，最常见的例子就是刚刚拍摄的照片，至少同时属于“最近添加”、“相机胶卷”以及“照片 - 精选”这三个 PHAssetCollection。关于这几个概念的关系如下图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/PhotoKit_1.png?raw=true"><br></div>

<h3 id="PhotoKit-的机制"><a href="#PhotoKit-的机制" class="headerlink" title="PhotoKit 的机制"></a>PhotoKit 的机制</h3><h5 id="1-获取资源"><a href="#1-获取资源" class="headerlink" title="1. 获取资源"></a>1. 获取资源</h5><p>在 ALAssetLibrary 中获取数据，无论是相册，还是资源，本质上都是使用枚举的方式，遍历照片库取得相应的数据，并且数据是从 ALAssetLibrary（照片库） - ALAssetGroup（相册）- ALAsset（资源）这一路径逐层获取，即使有直接从 ALAssetLibrary 这一层获取 ALAsset 的接口，本质上也是枚举 ALAssetLibrary 所得，并不是直接获取，这样的好处很明显，就是非常符合实际应用中资源的显示路径：照片库 - 相册 - 图片或视频，但由于采用枚举的方式获取资源，效率低而且不灵活。</p>
<p>而在 PhotoKit 中，则是采用“获取”的方式拉取资源，这些获取的手段，都是一系列形如 class func fetchXXX(…, options: PHFetchOptions) -&gt; PHFetchResult 的类方法，具体使用哪个类方法，则视乎需要获取的是相册、时刻还是资源，这类方法中的 option 充当了过滤器的作用，可以过滤相册的类型，日期，名称等，从而直接获取对应的资源而不需要枚举。</p>
<p><strong>获取相册-PHAssetCollection:</strong></p>
<pre><code>- (IBAction)getAllSmartAlbums:(id)sender {
    // 列出所有相册智能相册
    PHFetchResult *smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:nil];
    //列出用户创建的相册.
    PHFetchResult *topLevelUserCollections = [PHCollectionList fetchTopLevelUserCollectionsWithOptions:nil];

    for (NSInteger i = 0; i &lt; smartAlbums.count; i++) {
        PHCollection *collection = smartAlbums[i];
        if ([collection isKindOfClass:[PHAssetCollection class]]) {
            PHAssetCollection *assetCollection = (PHAssetCollection *)collection;
            NSLog(@&quot;%@&quot;,assetCollection);
        }else {
            NSAssert(NO, @&quot;Fetch collection not PHCollection: %@&quot;, collection);
        }
    }
}
</code></pre><p>以上方法第一种需要指定两个参数：</p>
<pre><code>typedef NS_ENUM(NSInteger, PHAssetCollectionType) {
    PHAssetCollectionTypeAlbum      = 1,//从 iTunes 同步来的相册，以及用户在 Photos 中自己建立的相册
    PHAssetCollectionTypeSmartAlbum = 2,//经由相机得来的相册
    PHAssetCollectionTypeMoment     = 3,//Photos 为我们自动生成的时间分组的相册
} NS_ENUM_AVAILABLE_IOS(8_0);

typedef NS_ENUM(NSInteger, PHAssetCollectionSubtype) {

    // PHAssetCollectionTypeAlbum regular subtypes  
    PHAssetCollectionSubtypeAlbumRegular         = 2, //用户在 Photos 中创建的相册，也就是我所谓的逻辑相册
    PHAssetCollectionSubtypeAlbumSyncedEvent     = 3, //使用 iTunes 从 Photos 照片库或者 iPhoto 照片库同步过来的事件。然而，在iTunes 12 以及iOS 9.0 beta4上，选用该类型没法获取同步的事件相册，而必须使用AlbumSyncedAlbum。
    PHAssetCollectionSubtypeAlbumSyncedFaces     = 4,//使用 iTunes 从 Photos 照片库或者 iPhoto 照片库同步的人物相册。
    PHAssetCollectionSubtypeAlbumSyncedAlbum     = 5,//做了 AlbumSyncedEvent 应该做的事
    PHAssetCollectionSubtypeAlbumImported        = 6,//从相机或是外部存储导入的相册，完全没有这方面的使用经验，没法验证。

    // PHAssetCollectionTypeAlbum shared subtypes
    PHAssetCollectionSubtypeAlbumMyPhotoStream   = 100,//用户的 iCloud 照片流
    PHAssetCollectionSubtypeAlbumCloudShared     = 101,//用户使用 iCloud 共享的相册

    // PHAssetCollectionTypeSmartAlbum subtypes
    PHAssetCollectionSubtypeSmartAlbumGeneric    = 200,//文档解释为非特殊类型的相册，主要包括从 iPhoto 同步过来的相册。由于本人的 iPhoto 已被 Photos 替代，无法验证。不过，在我的 iPad mini 上是无法获取的，而下面类型的相册，尽管没有包含照片或视频，但能够获取到。
    PHAssetCollectionSubtypeSmartAlbumPanoramas  = 201, //相机拍摄的全景照片
    PHAssetCollectionSubtypeSmartAlbumVideos     = 202,//相机拍摄的视频
    PHAssetCollectionSubtypeSmartAlbumFavorites  = 203,//收藏文件夹
    PHAssetCollectionSubtypeSmartAlbumTimelapses = 204,//延时视频文件夹，同时也会出现在视频文件夹中
    PHAssetCollectionSubtypeSmartAlbumAllHidden  = 205,//包含隐藏照片或视频的文件夹
    PHAssetCollectionSubtypeSmartAlbumRecentlyAdded = 206,//相机近期拍摄的照片或视频
    PHAssetCollectionSubtypeSmartAlbumBursts     = 207,//连拍模式拍摄的照片，在 iPad mini 上按住快门不放就可以了，但是照片依然没有存放在这个文件夹下，而是在相机相册里。
    PHAssetCollectionSubtypeSmartAlbumSlomoVideos = 208,//Slomo 是 slow motion 的缩写，高速摄影慢动作解析，在该模式下，iOS 设备以120帧拍摄。不过我的 iPad mini 不支持，没法验证。
    PHAssetCollectionSubtypeSmartAlbumUserLibrary = 209,//这个命名最神奇了，就是相机相册，所有相机拍摄的照片或视频都会出现在该相册中，而且使用其他应用保存的照片也会出现在这里。
    PHAssetCollectionSubtypeSmartAlbumSelfPortraits NS_AVAILABLE_IOS(9_0) = 210,
    PHAssetCollectionSubtypeSmartAlbumScreenshots NS_AVAILABLE_IOS(9_0) = 211,

    // Used for fetching, if you don&apos;t care about the exact subtype
    PHAssetCollectionSubtypeAny = NSIntegerMax //包含所有类型
} NS_ENUM_AVAILABLE_IOS(8_0);
</code></pre><p><strong>注意</strong>：获取指定类型的相册时，主类型和子类型要匹配，不要串台。如果不匹配，系统会按照 Any 子类型来处理。对于 Moment 类型，子类型使用 Any。</p>
<p>如前面提到过的那样，从PHAssetCollection 获取中获取到的可以是相册也可以是资源，但无论是哪种内容，都统一使用PHFetchResult 对象封装起来，因此虽然 PHAssetCollection 获取到的结果可能是多样的，但通过PHFetchResult 就可以使用统一的方法去处理这些内容（即遍历 PHFetchResult）。</p>
<p><strong>获取资源-PHAsset</strong></p>
<pre><code>//方式一
// 列出所有相册智能相册
PHFetchResult *smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:nil];
// 这时 smartAlbums 中保存的应该是各个智能相册对应的 PHAssetCollection
for (NSInteger i = 0; i &lt; fetchResult.count; i++) {
    // 获取一个相册（PHAssetCollection）
    PHCollection *collection = fetchResult[i];
    if ([collection isKindOfClass:[PHAssetCollection class]]) {
        PHAssetCollection *assetCollection = (PHAssetCollection *)collection;
        // 从每一个智能相册中获取到的 PHFetchResult 中包含的才是真正的资源（PHAsset）
        PHFetchResult *fetchResult = [PHAsset fetchAssetsInAssetCollection:assetCollection options:fetchOptions];
        for (NSInteger i = 0; i &lt; fetchResult.count; i++) {
            // 获取一个资源（PHAsset）
            PHAsset *asset = fetchResult[i];
            NSLog(@&quot;%@&quot;,asset);
        }
    else {
        NSAssert(NO, @&quot;Fetch collection not PHCollection: %@&quot;, collection);
    }
}

//方式二  
// 获取所有资源的集合，并按资源的创建时间排序
PHFetchOptions *options = [[PHFetchOptions alloc] init];
options.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@&quot;creationDate&quot; ascending:YES]];
PHFetchResult *assetsFetchResults = [PHAsset fetchAssetsWithOptions:options];
// 这时 assetsFetchResults 中包含的，应该就是各个资源（PHAsset）
for (NSInteger i = 0; i &lt; fetchResult.count; i++) {
    // 获取一个资源（PHAsset）
    PHAsset *asset = fetchResult[i];
}
</code></pre><h5 id="获取图像的方式与坑点"><a href="#获取图像的方式与坑点" class="headerlink" title="获取图像的方式与坑点"></a>获取图像的方式与坑点</h5><p>经过了上面的步骤，已经可以了解到如何在 PhotoKit 中获取到代表资源的 PHAsset 了，但与 ALAssetLibrary 中从 ALAsset 中直接获取图像的方式不同，PhotoKit 无法直接从 PHAsset 的实例中获取图像，而是引入了一个管理器?PHImageManager 获取图像。PHImageManager 是通过请求的方式拉取图像，并可以控制请求得到的图像的尺寸、剪裁方式、质量，缓存以及请求本身的管理（发出请求、取消请求）等。而请求图像的方法是PHImageManager 的一个实例方法：</p>
<pre><code>- (PHImageRequestID)requestImageForAsset:(PHAsset *)asset 
                              targetSize:(CGSize)targetSize 
                               contentMode:(PHImageContentMode)contentMode 
                                options:(nullable PHImageRequestOptions *)options 
                          resultHandler:(void (^)(UIImage *__nullable result, NSDictionary *__nullable info))resultHandler;
</code></pre><p>这个方法中的参数坑点不少，下面逐个参数列举一下其作用及坑点：</p>
<ul>
<li><strong>asset</strong>:图像对应的 PHAsset。</li>
<li><strong>targetSize</strong>:需要获取的图像的尺寸，如果输入的尺寸大于资源原图的尺寸，则只返回原图。需要注意在 PHImageManager 中，所有的尺寸都是用 Pixel 作为单位（Note that all sizes are in pixels），因此这里想要获得正确大小的图像，需要把输入的尺寸转换为 Pixel。如果需要返回原图尺寸，可以传入 PhotoKit 中预先定义好的常量PHImageManagerMaximumSize，表示返回可选范围内的最大的尺寸，即原图尺寸。</li>
<li><strong>contentMode</strong>:图像的剪裁方式，与UIView 的 contentMode 参数相似，控制照片应该以按比例缩放还是按比例填充的方式放到最终展示的容器内。注意如果 targetSize 传入PHImageManagerMaximumSize，则 contentMode 无论传入什么值都会被视为?PHImageContentModeDefault。</li>
<li><strong>options</strong>:一个PHImageRequestOptions 的实例，可以控制的内容相当丰富，包括图像的质量、版本，也会有参数控制图像的剪裁，下面再展开说明。</li>
<li><strong>resultHandler</strong>:请求结束后被调用的 block，返回一个包含资源对于图像的 UIImage 和包含图像信息的一个 NSDictionary，在整个请求的周期中，这个 block 可能会被多次调用，关于这点连同 options 参数在下面展开说明。</li>
</ul>
<h6 id="PHImageRequestOptions-与-iCloud-照片库"><a href="#PHImageRequestOptions-与-iCloud-照片库" class="headerlink" title="PHImageRequestOptions 与 iCloud 照片库"></a>PHImageRequestOptions 与 iCloud 照片库</h6><p>PHImageRequestOptions 中包含了一系列控制请求图像的属性。</p>
<p>resizeMode 属性控制图像的剪裁，不知道为什么 PhotoKit 会在请求图像方法（requestImageForAsset）中已经有控制图像剪裁的参数后（contentMode），还在 options 中加入控制剪裁的属性，但如果两个地方所控制的剪裁结果有所冲突，PhotoKit 会以 resizeMode 的结果为准。另外，resizeMode 也有控制图像质量的作用。如resizeMode设置为PHImageRequestOptionsResizeModeExact 则返回图像必须和目标大小相匹配，并且图像质量也为高质量图像，而设置为 PHImageRequestOptionsResizeModeFast 则请求的效率更高，但返回的图像可能和目标大小不一样并且质量较低。</p>
<p>在 PhotoKit 中，对 iCloud 照片库有很好的支持，如果用户开启了 iCloud 照片库，并且选择了“优化 iPhone/iPad 储存空间”，或者选择了“下载并保留原件”但原件还没有加载好的时候，PhotoKit 也会预先拿到这些非本地图像的 PHAsset，但是由于本地并没有原图，所以如果产生了请求高清图的请求，PHotoKit 会尝试从 iCloud 下载图片，而这个行为最终的表现，会被PHImageRequestOptions 中的值所影响。PHImageRequestOptions 中常常会用的几个属性如下：</p>
<p>networkAccessAllowed 参数控制是否允许网络请求，默认为 NO，如果不允许网络请求，那么就没有然后了，当然也拉取不到 iCloud 的图像原件。deliveryMode 则用于控制请求的图片质量。synchronous 控制是否为同步请求，默认为 NO，如果?synchronous 为 YES，即同步请求时，deliveryMode 会被视为 PHImageRequestOptionsDeliveryModeHighQualityFormat，即自动返回高质量的图片，因此不建议使用同步请求，否则如果界面需要等待返回的图像才能进一步作出反应，则反应时长会很长。</p>
<p>还有一个与 iCloud 密切相关的属性progressHandler，当图像需要从 iCloud 下载时，这个 block 会被自动调用，block 中会返回图像下载的进度，图像的信息，出错信息。开发者可以利用这些信息反馈给用户当前图像的下载进度以及状况，但需要注意progressHandler 不在主线程上执行，因此在其中需要操作 UI，则需要手工放到主线程执行。</p>
<p>上面有提到，requestImageForAsset 中的参数resultHandler 可能会被多次调用，这种情况就是图像需要从 iCloud 中下载的情况。在requestImageForAsset 返回的内容中，一开始的那一次请求中会返回一个小尺寸的图像版本，当高清图像还在下载时，开发者可以首先给用户展示这个低清的图像版本，然后 block 在多次调用后，最终会返回高清的原图。至于当前返回的图像是哪个版本的图像，可以通过 block 返回的 NSDictionary info 中获知，PHImageResultIsDegradedKey 表示当前返回的 UIImage 是低清图。如果需要判断是否已经获得高清图，可以这样判断：</p>
<pre><code>// 排除取消，错误，低清图三种情况，即已经获取到了高清图
BOOL downloadFinined = ![[info objectForKey:PHImageCancelledKey] boolValue] &amp;&amp; ![info objectForKey:PHImageErrorKey] &amp;&amp; ![[info objectForKey:PHImageResultIsDegradedKey] boolValue];
</code></pre><p>另外，当我们使用requestImageForAsset 发出对图像的请求时，如果在同一个 PHImageManager 中同时对同一个资源发出图像请求，请求的进度是可以共享的，因此我们可以利用这个特性，把 PHImageManager 以单例的形式使用，这样在切换界面时也不用担心无法传递图像的下载进度。例如，在图像的列表页面触发了下载图像，当我们离开列表页面进入预览大图界面时，并不用担心会重新图像会重新下载，只要没有手工取消图像下载，进入预览大图界面下载图像会自动继续从上次的进度下载图像。</p>
<p>如果希望取消下载图像，则可以使用PHImageManager 的 cancelImageRequest 方法，它传入的是请求图像的请求 ID，这个 ID 可以从requestImageForAsset 的返回值中获得，也可以从前面提到的包含图像信息的NSDictionary info 中获得，当然前提是这个这个接收取消请求的 PHImageManager 与刚刚发出请求的 PHImageManager 是同一个实例，如上面所述使用单例是最为简单有效的方式。</p>
<p>最后，还要介绍一个PHImageRequestOptions 的属性 versions，这个属性是指获取的图像是否需要包含系统相册“编辑”功能处理过的信息（如滤镜，旋转等），这一点比 ALAssetLibrary 要灵活很多，ALAssetLibrary 中并不能灵活地控制获取的图像是否带有“编辑”处理过的效果，例如在 ALAsset 中获取原图的接口 fullResolutionImage 获取到的是不带“编辑”效果的图像，要想获取带有“编辑”效果的图像，只能自行处理获取这些滤镜效果，并手工叠加上去。在我们的 UI 框架 QMUI 中就有对获取原图作出这样的封装，整个过程也较为繁琐，而框架中处理 PhotoKit 的部分则灵活很多，这也体现了 PhotoKit 相比 ALAssetLibrary 的最主要特点——复杂但灵活。文章的第三部分也会详细列出如何处理这个问题。</p>
<h6 id="获取图像的优化"><a href="#获取图像的优化" class="headerlink" title="获取图像的优化"></a>获取图像的优化</h6><p>PHImageManager 提供了一个子类PHImageCachingManager 用于处理图像的缓存，但是这个子类并不只是图像本身的缓存，而是更加实用——处理图像的整个加载过程的缓存。例如要在一个collectionView 上展示图像列表这类大量的资源图像的缩略图时，可以利用 PHImageCachingManager预先将一些图像加载到内存中，这对优化 collectionView 滚动时的表现很有帮助。然而，这只是官方说法，实际上由于加载图像的过程并不确定，每个业务加载图像的实际需求都可能不一样，因此PHImageCachingManager 也采用比较松散的方法去控制这些缓存，其中的关键方法：</p>
<pre><code>- (void)startCachingImagesForAssets:(NSArray&lt;PHAsset *&gt; *)assets targetSize:(CGSize)targetSize contentMode:(PHImageContentMode)contentMode options:(nullable PHImageRequestOptions *)options;
</code></pre><p>需要传入一组 PHAsset，以及 targetSize，contentMode，以及一个PHImageRequestOptions，如上面所述，这些参数之间的有着互相影响的作用，因此实际上不同的场景对于每个参数要求都不一样，而这些参数的最佳取值也只能通过实际在场景中测试所得。因此，比起使用PHImageCachingManager，我总结了一些更为简易可行的缓存方法：</p>
<ul>
<li>获取图片时尽量获取预览图，不要直接显示原件，建议获取与设备屏幕同样大小的图像即可，实际上系统相册预览大图时使用的也是预览图，这也是系统相册加载速度快的原因。</li>
<li>获取图片使用异步请求，如上面所述，当请求为异步时返回图像的 block 会被多次调用，先返回低清图，再返回高清图，这样一来可以大大减少 UI 的等待时间。</li>
<li>获取到高清图后可以缓存下来，简单地使用变量缓存即可，尽量在获取到高清图后避免再次发起请求获取图像。因为即使图像原件已经下载下来，重新请求高清图时因为图片的尺寸比较大，因此系统生成图像和剪裁图像也会花费一些时间。</li>
<li>预先加载图像，如像预览大图这类情景中，用户同时只会看到一张大图，因此在观看某一张图片时，预先请求其邻近两张图片，对于加快 UI 的响应很有帮助。</li>
</ul>
<p>经过实际测试，如果请求的是缩略图（即尺寸小的图像），那么即使请求的图像很多，仍不会产生任何不流畅的表现，但如果请求的是高清大图，那么即使只是同时请求几张图都会产生不流畅的状况。如上面提到过的那样，这些的状况的出现很可能是请求大图时由图片元数据产生图像，以及剪裁图像的过程耗时较多。所以按实际表现来看，即使 PhotoKit 有自己的缓存策略，仍然很难避免这部分耗时。因此上面几点优化获取图像的策略重点也是放在减少图像大小，异步请求以及做缓存几个方面。</p>
<p>由于AssetsLibrary在ios9以后被苹果废弃，所有我基于AssetsLibrary和PhotoKit封装了一个简单的相册获取库，能够快速的获取相册、图片。欢迎大家访问。<a href="https://github.com/guiyongdong/PhotoManager" target="_blank" rel="external">传送门:GGPhotoManager</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PhotoKit 是一套比 AssetsLibrary 更完整也更高效的库，对资源的处理跟 AssetsLibrary 也有很大的不同。它是iOS8之后出现的框架，在使用框架之前需要导入&lt;code&gt;#import &amp;lt;Photos/Photos.h&amp;gt;&lt;/code&gt;库&lt;/p&gt;
    
    </summary>
    
      <category term="iOS照片" scheme="http://www.guiyongdong.com/categories/iOS%E7%85%A7%E7%89%87/"/>
    
    
      <category term="iOS照片" scheme="http://www.guiyongdong.com/tags/iOS%E7%85%A7%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS照片开发之AssetsLibrary</title>
    <link href="http://www.guiyongdong.com/2016/10/15/iOS%E7%85%A7%E7%89%87%E5%BC%80%E5%8F%91%E4%B9%8BAssetsLibrary/"/>
    <id>http://www.guiyongdong.com/2016/10/15/iOS照片开发之AssetsLibrary/</id>
    <published>2016-10-15T03:25:30.000Z</published>
    <updated>2016-11-15T06:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客讲解了UIImagePickerController的使用，这篇博客简单说一下AssetsLibrary。在 iOS 8 出现之前，开发者只能使用 AssetsLibrary 框架来访问设备的照片库，而在 iOS8 出现之后，苹果提供了一个名为 PhotoKit 的框架。这里主要说AssetsLibrary。</p>
<p>另外值得强调的是，在 iOS 中，照片库并不只是照片的集合，同时也包含了视频。在 AssetsLibrary 中两者都有相同类型的对象去描述，只是类型不同而已。文中为了方便，大部分时候会使用「资源」代表 iOS 中的「照片和视频」。</p>
<a id="more"></a>
<h3 id="AssetsLibrary-组成介绍"><a href="#AssetsLibrary-组成介绍" class="headerlink" title="AssetsLibrary 组成介绍"></a>AssetsLibrary 组成介绍</h3><p>AssetsLibrary 的组成比较符合照片库本身的组成，照片库中的完整照片库对象、相册、相片都能在 AssetsLibrary 中找到一一对应的组成，这使到 AssetsLibrary 的使用变得直观而方便。</p>
<ul>
<li><strong>AssetsLibrary</strong>: 代表整个设备中的资源库（照片库），通过 AssetsLibrary 可以获取和包括设备中的照片和视频</li>
<li><strong>ALAssetsGroup</strong>: 映射照片库中的一个相册，通过 ALAssetsGroup 可以获取某个相册的信息，相册下的资源，同时也可以对某个相册添加资源。</li>
<li><strong>ALAsset</strong>: 映射照片库中的一个照片或视频，通过 ALAsset 可以获取某个照片或视频的详细信息，或者保存照片和视频。</li>
<li><strong>ALAssetRepresentation</strong>: ALAssetRepresentation 是对 ALAsset 的封装（但不是其子类），可以更方便地获取 ALAsset 中的资源信息，每个 ALAsset 都有至少有一个 ALAssetRepresentation 对象，可以通过 defaultRepresentation 获取。而例如使用系统相机应用拍摄的 RAW + JPEG 照片，则会有两个 ALAssetRepresentation，一个封装了照片的 RAW 信息，另一个则封装了照片的 JPEG 信息。</li>
</ul>
<h3 id="AssetsLibrary-的基本使用"><a href="#AssetsLibrary-的基本使用" class="headerlink" title="AssetsLibrary 的基本使用"></a>AssetsLibrary 的基本使用</h3><p>AssetsLibrary 的功能很多，基本可以分为对资源的获取/保存两个部分，保存的部分相对简单，API 也比较少，因此这里不作详细介绍。获取资源的 API 则比较丰富了，一个常见的使用大量 AssetsLibrary API 的例子就是图片选择器（ALAsset Picker）。要制作一个图片选择器，思路应该是获取照片库-列出所有相册-展示相册中的所有图片-预览图片大图。</p>
<p>首先是要检查 App 是否有照片操作授权：</p>
<pre><code>NSString *tipTextWhenNoPhotosAuthorization; // 提示语
// 获取当前应用对照片的访问授权状态
ALAuthorizationStatus authorizationStatus = [ALAssetsLibrary authorizationStatus];
// 如果没有获取访问授权，或者访问授权状态已经被明确禁止，则显示提示语，引导用户开启授权
if (authorizationStatus == ALAuthorizationStatusRestricted || authorizationStatus == ALAuthorizationStatusDenied) {
    NSDictionary *mainInfoDictionary = [[NSBundle mainBundle] infoDictionary];
    NSString *appName = [mainInfoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];
    tipTextWhenNoPhotosAuthorization = [NSString stringWithFormat:@&quot;请在设备的\&quot;设置-隐私-照片\&quot;选项中，允许%@访问你的手机相册&quot;, appName];
    // 展示提示语
}
</code></pre><p>照片操作权限枚举类型:</p>
<pre><code>typedef NS_ENUM(NSInteger, ALAuthorizationStatus) {
ALAuthorizationStatusNotDetermined = 0, 用户尚未做出了选择这个应用程序的问候
ALAuthorizationStatusRestricted,        此应用程序没有被授权访问的照片数据。可能是家长控制权限。
ALAuthorizationStatusDenied,            用户已经明确否认了这一照片数据的应用程序访问.
ALAuthorizationStatusAuthorized         用户已授权应用访问照片数据.
}
</code></pre><p>如果已经获取授权，则可以获取相册列表：</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    _assetLibrary = [[ALAssetsLibrary alloc] init];
    _albumsArray = [NSMutableArray array];
    [_assetLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
        NSLog(@&quot;%@&quot;,group);
        //查看相册的名字
        NSLog(@&quot;ALAssetsGroupPropertyName:%@&quot;,[group valueForProperty:ALAssetsGroupPropertyName]);
        //查看相册的类型
        NSLog(@&quot;ALAssetsGroupPropertyType:%@&quot;,[group valueForProperty:ALAssetsGroupPropertyType]);
        //查看相册的存储id
        NSLog(@&quot;ALAssetsGroupPropertyPersistentID:%@&quot;,[group valueForProperty:ALAssetsGroupPropertyPersistentID]);
        //查看相册存储的位置地址
        NSLog(@&quot;ALAssetsGroupPropertyURL:%@&quot;,[group valueForProperty:ALAssetsGroupPropertyURL]);
        //获取相册中一共的资源数量
        int count = [group numberOfAssets];
        //过滤器 设置相册组的筛选条件，ALAssetsFilter类表示筛选条件，allPhotos代表相册只包含相片，allVideos代表只包含视频，allAssets代表包含所有资源
        [group setAssetsFilter:[ALAssetsFilter allPhotos]];

        NSLog(@&quot;count:%d&quot;,count);
        //获取封面图片
        CGImageRef poster = [group posterImage];
        NSLog(@&quot;%@的封面照片是：%@&quot;,[group valueForProperty:ALAssetsGroupPropertyName],[UIImage imageWithCGImage:poster]);
        NSLog(@&quot;====================&quot;);
        if (group) {
            if (group.numberOfAssets &gt; 0) {
                [_albumsArray addObject:group];
            }
        }else {
            if ([_albumsArray count] &gt; 0) {
                // 把所有的相册储存完毕，可以展示相册列表
            } else {
                // 没有任何有资源的相册，输出提示
            }
        }
    } failureBlock:^(NSError *error) {
        NSLog(@&quot;读取失败&quot;);
    }];

}
</code></pre><p>通过上面的代码 我们可以获取到所有的相册组 <strong>ALAssetGroup</strong> 对象，打印所有的ALAssetGroup对象，得到以下信息:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/AssetsLibrary_cons.png?raw=true"><br></div>

<p>首先看一下本地模拟器我创建的相册:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/AssetsLibrary_photo.png?raw=true" width="375" height="667/"><br></div>

<p>通过对比可以知道 ALAssetsLibrary 在遍历的时候会返回所有的ALAssetGroup对象，一些ALAssetGroup对象下其实并没有照片，所有，在这里会判断一下count是否为0。我们再来看看通过ALAssetsLibrary我们可以获取到相册的哪些信息。通多打印，可以知道，我们能获取相册组的<strong>组名</strong>,<strong>Type</strong>,<strong>count</strong>,<strong>PersistentID</strong>,<strong>URL</strong>,<strong>封面照片</strong><br>这些信息足够在我们开发中使用了。</p>
<p>上面的代码中，遍历出所有的相册列表，并把相册中资源数不为空的相册 ALAssetGroup 对象的引用储存到一个数组中。总结成一下几点：</p>
<ul>
<li>iOS 中允许相册为空，即相册中没有任何资源，如果不希望获取空相册，则需要像上面的代码中那样手动过滤</li>
<li>ALAssetsGroup 有一个 setAssetsFilter 的方法，可以传入一个过滤器，控制只获取相册中的照片或只获取视频。一旦设置过滤，ALAssetsGroup 中资源列表和资源数量的获取也会被自动更新。</li>
<li>整个 AssetsLibrary 中对相册、资源的获取和保存都是使用异步处理（Asynchronous），这是考虑到资源文件体积相当比较大（还可能很大）。例如上面的遍历相册操作，相册的结果使用 block 输出，如果相册遍历完毕，则最后一次输出的 block 中的 group 参数值为 nil。而 stop 参数则是用于手工停止遍历，只要把 *stop 置 YES，则会停止下一次的遍历。关于这一点常常会引起误会，所以需要注意。</li>
</ul>
<h3 id="ALAsset介绍"><a href="#ALAsset介绍" class="headerlink" title="ALAsset介绍"></a>ALAsset介绍</h3><p>现在，已经可以获取相册了，接下来是获取相册中的资源</p>
<pre><code>_imagesAssetArray = [[NSMutableArray alloc] init];
[assetsGroup enumerateAssetsWithOptions:NSEnumerationReverse usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
    if (result) {
        //资源的类型
        NSLog(@&quot;资源的类型:%@&quot;,[result valueForProperty:ALAssetPropertyType]);
        //资源地理位置（无位置信息返回null）
        NSLog(@&quot;资源地理位置:%@&quot;,[result valueForProperty:ALAssetPropertyLocation]);
        //播放时长（照片返回ALErorInvalidProperty)
        NSLog(@&quot;播放时长:%@&quot;,[result valueForProperty:ALAssetPropertyDuration]);
        //方向 共有8个方向，参见：ALAssetOrientation
        NSLog(@&quot;方向:%@&quot;,[result valueForProperty:ALAssetPropertyOrientation]);
        //拍摄时间 包含了年与日时分秒
        NSLog(@&quot;拍摄时间:%@&quot;,[result valueForProperty:ALAssetPropertyDate]);
        //描述（打印看了下，只有带后缀的名称）
        NSLog(@&quot;描述:%@&quot;,[result valueForProperty:ALAssetPropertyRepresentations]);
        //返回一个字典，键值分别是文件名和文件的url
        NSLog(@&quot;urlinfo:%@&quot;,[result valueForProperty:ALAssetPropertyURLs]);
        //文件的url
        NSLog(@&quot;url:%@&quot;,[result valueForProperty:ALAssetPropertyAssetURL]);

        //原始资源。若没有保存修改后资源，则原始资源为nil
        NSLog(@&quot;原始资源:%@&quot;,result.originalAsset);
        //指示资源是否可以编辑，只读属性
        NSLog(@&quot;原始资源:%@&quot;,result.editable);
        //获取小正方形的缩略图
        NSLog(@&quot;小正方形的缩略图:%@&quot;,[result thumbnail]);
        //按原始资源长宽比例的缩略图
        NSLog(@&quot;按原始资源长宽比例的缩略图:%@&quot;,[result aspectRatioThumbnail]);
        NSLog(@&quot;=========================&quot;);
        NSLog(@&quot; &quot;);


        [_imagesAssetArray addObject:result];
    } else {
        // result 为 nil，即遍历相片或视频完毕，可以展示资源列表
    }
}];
</code></pre><p>控制台输出信息：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/AssetsLibrary_cons1.png?raw=true"><br></div>

<p>跟遍历相册的过程类似，遍历相片也是使用一系列的异步方法，其中上面的方法所输出的 block 中，除了 result 参数表示资源信息，stop 用于手工停止遍历外，还提供了一个 index 参数，这个参数表示资源的索引。一般来说，展示资源列表都会使用缩略图（result.thumbnail），因此即使资源很多，遍历资源的速度也会相当快。但如果确实需要加载资源的高清图或者其他耗时的处理，则可以利用上面的 index 参数和 stop 参数做一个分段拉取资源。例如：</p>
<pre><code>NSUInteger _targetIndex; // index 目标值，拉取资源直到这个值就手工停止拉取
NSUInteger _currentIndex; // 当前 index，每次拉取资源时从这个值开始

_targetIndex = 50;
_currentIndex = 0;

- (void)loadAssetWithAssetsGroup:(assetsGroup *)assetsGroup {
    [assetsGroup enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:_currentIndex] options:NSEnumerationReverse usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
        _currentIndex = index;
        if (index &gt; _targetIndex) {
            // 拉取资源的索引如果比目标值大，则停止拉取
            *stop = YES;
        } else {
            if (result) {
                [_imagesAssetArray addObject:result];
            } else {
                // result 为 nil，即遍历相片或视频完毕
            }
        }
    }];
}

// 之前拉取的数据已经显示完毕，需要展示新数据，重新调用 loadAssetWithAssetsGroup 方法，并根据需要更新 _targetIndex 的值
</code></pre><p>以上两种方法都能获取到ALAssetsGroup中的ALAsset，ALAsset代表一个资源对象 通多ALAsset就可以获取到资源的详细信息。</p>
<h3 id="ALAssetRepresentation介绍"><a href="#ALAssetRepresentation介绍" class="headerlink" title="ALAssetRepresentation介绍"></a>ALAssetRepresentation介绍</h3><p>最后一步是获取图片详细信息，例如：</p>
<pre><code>- (UIImage *)getImageWithAsset:(ALAsset *)asset {
    // 获取资源图片的详细资源信息，其中 imageAsset 是某个资源的 ALAsset 对象
    ALAssetRepresentation *representation = [asset defaultRepresentation];
    // 获取资源图片的 fullScreenImage
    UIImage *contentImage = [UIImage imageWithCGImage:[representation fullScreenImage]];

    return contentImage;
}
</code></pre><p>对于一个 ALAssetRepresentation，里面包含了图片的多个版本。最常用的是 fullResolutionImage 和 fullScreenImage。fullResolutionImage 是图片的原图，通过 fullResolutionImage 获取的图片没有任何处理，包括通过系统相册中“编辑”功能处理后的信息也没有被包含其中，因此需要展示“编辑”功能处理后的信息，使用 fullResolutionImage 就比较不方便，另外 fullResolutionImage 的拉取也会比较慢，在多张 fullResolutionImage 中切换时能明显感觉到图片的加载过程。因此这里建议获取图片的 fullScreenImage，它是图片的全屏图版本，这个版本包含了通过系统相册中“编辑”功能处理后的信息，同时也是一张缩略图，但图片的失真很少，缺点是图片的尺寸是一个适应屏幕大小的版本，因此展示图片时需要作出额外处理，但考虑到加载速度非常快的原因（在多张图片之间切换感受不到图片加载耗时），仍建议使用 fullScreenImage。另外ALAssetRepresentation还包含的其他的资源属性，例如：acale(长宽比例),filename(文件名字)等。</p>
<p>系统相册的处理过程大概也是如上，可以看出，在整个过程中并没有使用到图片的 fullResolutionImage，从相册列表展示到最终查看资源，都是使用缩略图，这也是 iOS 相册加载快的一个重要原因。</p>
<h3 id="AssetsLibrary的写"><a href="#AssetsLibrary的写" class="headerlink" title="AssetsLibrary的写"></a>AssetsLibrary的写</h3><p><strong>创建相册组：</strong></p>
<pre><code>- (IBAction)createFileName:(id)sender {
    [self.assetLibrary addAssetsGroupAlbumWithName:@&quot;rrrrr&quot; resultBlock:^(ALAssetsGroup *group) {
        if (group) {
            //表明本地没有这个相册组
            NSLog(@&quot;本地没有这个相册组&quot;);
        }else {
            //表明本地有这个相册组
            NSLog(@&quot;本地有这个相册组&quot;);
        }
        NSLog(@&quot;%@&quot;,group);
    } failureBlock:^(NSError *error) {

    }];
}
</code></pre><p><strong>保存图片到指定相册组</strong></p>
<pre><code>- (IBAction)addImage:(id)sender {
    UIImage *image = [UIImage imageNamed:@&quot;aaa&quot;];
    //保存到系统照片 并保存到指定相册组
    __weak typeof (self)weakSelf = self;
    [self.assetLibrary writeImageToSavedPhotosAlbum:[image CGImage] orientation:ALAssetOrientationUp completionBlock:^(NSURL *assetURL, NSError *error) {

        [weakSelf.assetLibrary addAssetsGroupAlbumWithName:@&quot;Www&quot; resultBlock:^(ALAssetsGroup *group) {
            if (group) {
                //如果group不为空 表明新创建一个 ALAssetsGroup


                [weakSelf.assetLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
                    //添加资源
                    [group addAsset:asset];
                } failureBlock:^(NSError *error) {
                    NSLog(@&quot;查询照片失败&quot;);
                }];
            }else {
                //如果group为空 表明系统内已经有一个 ALAssetsGroup
                [weakSelf.assetLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
                    NSString *groupName = [group valueForProperty:ALAssetsGroupPropertyName];
                    if ([groupName isEqualToString:@&quot;Www&quot;]) {
                        [weakSelf.assetLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
                            [group addAsset:asset];
                        } failureBlock:^(NSError *error) {
                            NSLog(@&quot;查询照片失败&quot;);
                        }];
                    }
                } failureBlock:^(NSError *error) {

                }];
            }
            NSLog(@&quot;%@&quot;,group);
        } failureBlock:^(NSError *error) {

        }];   
    }];
}
</code></pre><h3 id="AssetsLibrary-的坑点"><a href="#AssetsLibrary-的坑点" class="headerlink" title="AssetsLibrary 的坑点"></a>AssetsLibrary 的坑点</h3><p>作为一套老框架，AssetsLibrary 不但有坑，而且还不少，除了上面提到的资源异步拉取时需要注意的事项，下面几点也是值得注意的：</p>
<h5 id="1-AssetsLibrary-实例需要强引用"><a href="#1-AssetsLibrary-实例需要强引用" class="headerlink" title="1. AssetsLibrary 实例需要强引用"></a>1. AssetsLibrary 实例需要强引用</h5><p>实例一个 AssetsLibrary 后，如上面所示，我们可以通过一系列枚举方法获取到需要的相册和资源，并把其储存到数组中，方便用于展示。但是，当我们把这些获取到的相册和资源储存到数组时，实际上只是在数组中储存了这些相册和资源在 AssetsLibrary 中的引用（指针），因而无论把相册和资源储存数组后如何利用这些数据，都首先需要确保 AssetsLibrary 没有被 ARC 释放，否则把数据从数组中取出来时，会发现对应的引用数据已经丢失（参见下图）。这一点较为容易被忽略，因此建议在使用 AssetsLibrary 的 viewController 中，把 AssetsLibrary 作为一个强持有的 property 或私有变量，避免在枚举出 AssetsLibrary 中所需要的数据后，AssetsLibrary 就被 ARC 释放了。</p>
<p>如下图：实例化一个 AssetsLibrary 的局部变量，枚举所有相册并储存在名为 _albumsArray 的数组中，展示相册时再次查看数组，发现 ALAssetsGroup 中的数据已经丢失。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/ALAssetsLibrary_release.png?raw=true"><br></div>

<h5 id="2-AssetsLibrary-遵循写入优先原则"><a href="#2-AssetsLibrary-遵循写入优先原则" class="headerlink" title="2. AssetsLibrary 遵循写入优先原则"></a>2. AssetsLibrary 遵循写入优先原则</h5><p>写入优先也就是說，在利用 AssetsLibrary 读取资源的过程中，有任何其它的进程（不一定是同一个 App）在保存资源时，就会收到 ALAssetsLibraryChangedNotification，让用户自行中断读取操作。最常见的就是读取 fullResolutionImage 时，用进程在写入，由于读取 fullResolutionImage 耗时较长，很容易就会 exception。</p>
<h5 id="开启-Photo-Stream-容易导致-exception"><a href="#开启-Photo-Stream-容易导致-exception" class="headerlink" title="开启 Photo Stream 容易导致 exception"></a>开启 Photo Stream 容易导致 exception</h5><p>本质上，这跟上面的 AssetsLibrary 遵循写入优先原则是同一个问题。如果用户开启了共享照片流（Photo Stream），共享照片流会以 mstreamd 的方式“偷偷”执行，当有人把相片写入 Camera Roll 时，它就会自动保存到 Photo Stream Album 中，如果用户刚好在读取，那就跟上面说的一样产生 exception 了。由于共享照片流是用户决定是否要开启的，所以开发者无法改变，但是可以通过下面的接口在需要保护的时刻关闭监听共享照片流产生的频繁通知信息。</p>
<pre><code>[ALAssetsLibrary disableSharedPhotoStreamsSupport];
</code></pre><p>下一篇博客会介绍iOS8以后出现的框架 <a href="http://www.guiyongdong.com/2016/10/22/iOS%E7%85%A7%E7%89%87%E5%BC%80%E5%8F%91%E4%B9%8BPhotoKit/"><strong>PhotoKit</strong></a> 敬请关注!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博客讲解了UIImagePickerController的使用，这篇博客简单说一下AssetsLibrary。在 iOS 8 出现之前，开发者只能使用 AssetsLibrary 框架来访问设备的照片库，而在 iOS8 出现之后，苹果提供了一个名为 PhotoKit 的框架。这里主要说AssetsLibrary。&lt;/p&gt;
&lt;p&gt;另外值得强调的是，在 iOS 中，照片库并不只是照片的集合，同时也包含了视频。在 AssetsLibrary 中两者都有相同类型的对象去描述，只是类型不同而已。文中为了方便，大部分时候会使用「资源」代表 iOS 中的「照片和视频」。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS照片" scheme="http://www.guiyongdong.com/categories/iOS%E7%85%A7%E7%89%87/"/>
    
    
      <category term="iOS照片" scheme="http://www.guiyongdong.com/tags/iOS%E7%85%A7%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS照片开发之UIImagePickerController</title>
    <link href="http://www.guiyongdong.com/2016/10/12/iOS%E7%85%A7%E7%89%87%E5%BC%80%E5%8F%91%E4%B9%8BUIImagePickerController/"/>
    <id>http://www.guiyongdong.com/2016/10/12/iOS照片开发之UIImagePickerController/</id>
    <published>2016-10-12T02:37:08.000Z</published>
    <updated>2016-11-03T10:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中，通常获取照片的方式有三种，1.直接调用摄像头拍照 2.从相册中选择 3.从图库中选择。 通常使用到的类或框架有UIImagePickerController,AssetsLibrary,PhotoKit(iOS8later)。本篇博客主要讲解UIImagePickerController，其他的后续会讲解到。</p>
<a id="more"></a>
<h3 id="UIImagePickerController"><a href="#UIImagePickerController" class="headerlink" title="UIImagePickerController"></a>UIImagePickerController</h3><p>UIImagePickerController 是系统提供的用来获取图片和视频的类;</p>
<p>用UIImagePickerController 类来获取图片视频，大体分为以下几个步骤：</p>
<pre><code>1. 初始化UIImagePickerController 类；
2. 设置UIImagePickerController 实例的数据来源类型（下面解释）；
3. 设置代理；
4. 如果需要做图片修改的话设置allowsEditing =yes。
</code></pre><p><strong>数据来源类型一共有三种：</strong></p>
<pre><code>enum {
    UIImagePickerControllerSourceTypePhotoLibrary ,//来自图库
    UIImagePickerControllerSourceTypeCamera ,//来自相机
    UIImagePickerControllerSourceTypeSavedPhotosAlbum //来自相册
};
</code></pre><p>在用这些来源的时候最好检测以下设备是否支持；</p>
<pre><code>if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera])
{
    NSLog(@&quot;支持相机&quot;);
}
if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary])
{
    NSLog(@&quot;支持图库&quot;);
}
if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeSavedPhotosAlbum])
{
    NSLog(@&quot;支持相片库&quot;);
}
</code></pre><p>调用摄像头来获取资源</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    picker = [[UIImagePickerController alloc]init];
    //获取照片的类型
    UIImagePickerControllerSourceType sourcheType = UIImagePickerControllerSourceTypeCamera;
    picker.sourceType = sourcheType;
    //设置代理
    picker.delegate = self;
    //是否允许编辑
    picker.allowsEditing = YES;
}
</code></pre><p>上面只是实例了UIImagePickerController及其属性 在需要获取图片的时候需要弹出窗口调用</p>
<pre><code>[self presentViewController:picker animated:YES completion:nil];
</code></pre><p>代理中一共三个方法 其中一个3.0 已经废弃了，只剩下两个我们需要用的.<br>1.当用户选取完成后调用:</p>
<pre><code>- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info;
</code></pre><p><strong>选取的信息都在info中，info 是一个字典:</strong><br>字典中的键：</p>
<pre><code>NSString *const  UIImagePickerControllerMediaType ;指定用户选择的媒体类型（文章最后进行扩展）
NSString *const  UIImagePickerControllerOriginalImage ;原始图片
NSString *const  UIImagePickerControllerEditedImage ;修改后的图片
NSString *const  UIImagePickerControllerCropRect ;裁剪尺寸
NSString *const  UIImagePickerControllerMediaURL ;媒体的URL
NSString *const  UIImagePickerControllerReferenceURL ;原件的URL
NSString *const  UIImagePickerControllerMediaMetadata;当来数据来源是照相机的时候这个值才有效
</code></pre><p>1.当用户取消选取时调用:</p>
<pre><code>- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker;
</code></pre><p>UIImagePickerControllerMediaType 包含着KUTTypeImage 和KUTTypeMovie</p>
<p>1.KUTTypeImage 包含:</p>
<pre><code>const CFStringRef  kUTTypeImage ;抽象的图片类型
const CFStringRef  kUTTypeJPEG ;
const CFStringRef  kUTTypeJPEG2000 ;
const CFStringRef  kUTTypeTIFF ;
const CFStringRef  kUTTypePICT ;
const CFStringRef  kUTTypeGIF ;
const CFStringRef  kUTTypePNG ;
const CFStringRef  kUTTypeQuickTimeImage ;
const CFStringRef  kUTTypeAppleICNS 
const CFStringRef kUTTypeBMP;
const CFStringRef  kUTTypeICO;
</code></pre><p>2.KUTTypeMovie 包含:</p>
<pre><code>const CFStringRef  kUTTypeAudiovisualContent ;抽象的声音视频
const CFStringRef  kUTTypeMovie ;抽象的媒体格式（声音和视频）
const CFStringRef  kUTTypeVideo ;只有视频没有声音
const CFStringRef  kUTTypeAudio ;只有声音没有视频
const CFStringRef  kUTTypeQuickTimeMovie ;
const CFStringRef  kUTTypeMPEG ;
const CFStringRef  kUTTypeMPEG4 ;
const CFStringRef  kUTTypeMP3 ;
const CFStringRef  kUTTypeMPEG4Audio ;
const CFStringRef  kUTTypeAppleProtectedMPEG4Audio;
</code></pre><p>好了,写了个小Demo,直接上代码了</p>
<pre><code>#import &quot;ViewController.h&quot;

@interface ViewController ()&lt;UIImagePickerControllerDelegate,UINavigationControllerDelegate&gt;

/** imageView */
@property (nonatomic, strong) UIImageView *imageView;

/** imageViewR */
@property (nonatomic, strong) UIImageView *imageViewR;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.imageViewR = [[UIImageView alloc] initWithFrame:CGRectMake((self.view.frame.size.width - 100)/2, 30, 100, 100)];
    self.imageViewR.backgroundColor = [UIColor grayColor];
    self.imageViewR.layer.cornerRadius = 50;
    self.imageViewR.layer.masksToBounds = YES; // 裁剪边
    [self.view addSubview:self.imageViewR];

    self.imageView = [[UIImageView alloc] initWithFrame:CGRectMake(16, 140, self.view.frame.size.width - 32, self.view.frame.size.width - 32)];
    self.imageView.backgroundColor = [UIColor grayColor];
    [self.view addSubview:self.imageView];

    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];
    btn.frame = CGRectMake(16, CGRectGetMaxY(self.imageView.frame) + 20, self.view.frame.size.width - 32, 35);
    btn.backgroundColor = [UIColor greenColor];
    btn.layer.cornerRadius = 5;
    btn.layer.masksToBounds = YES;
    [btn setTitle:@&quot;获取图片&quot; forState:UIControlStateNormal];
    [btn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:btn];
}

- (void)btnClick:(UIButton *)button
{
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;选择照片&quot; message:nil preferredStyle:(UIAlertControllerStyleActionSheet)];
    // 判断是否支持相机
    if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) {
        UIAlertAction *cameraAc = [UIAlertAction actionWithTitle:@&quot;拍照&quot; style:(UIAlertActionStyleDefault) handler:^(UIAlertAction * _Nonnull action) {
            UIImagePickerController *imagePickerController = [[UIImagePickerController alloc] init];
            imagePickerController.delegate = self;
            imagePickerController.allowsEditing = YES;
            // 设置数据源类型
            imagePickerController.sourceType = UIImagePickerControllerSourceTypeCamera;
            [self presentViewController:imagePickerController animated:YES completion:nil];
        }];
        [alertController addAction:cameraAc];
    }
    // 图集
    UIAlertAction *photoAc = [UIAlertAction actionWithTitle:@&quot;相册&quot; style:(UIAlertActionStyleDefault) handler:^(UIAlertAction * _Nonnull action) {
        UIImagePickerController *imagePickerController = [[UIImagePickerController alloc] init];
        imagePickerController.delegate = self;
        imagePickerController.allowsEditing = YES;
        imagePickerController.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
        [self presentViewController:imagePickerController animated:YES completion:nil];
    }];
    [alertController addAction:photoAc];

    // 相片库
    UIAlertAction *albumAc = [UIAlertAction actionWithTitle:@&quot;相片库&quot; style:(UIAlertActionStyleDefault) handler:^(UIAlertAction * _Nonnull action) {
        UIImagePickerController *imagePickerController = [[UIImagePickerController alloc] init];
        imagePickerController.delegate = self;
        imagePickerController.allowsEditing = YES;
        imagePickerController.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;;
        [self presentViewController:imagePickerController animated:YES completion:nil];
    }];
    [alertController addAction:albumAc];

    UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {

    }];

    [alertController addAction:cancel];

    [self presentViewController:alertController animated:YES completion:nil];

}


- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker
{
    [self dismissViewControllerAnimated:YES completion:nil];
}

// 代理方法,获取图片
// 选取的信息都在info中，info 是一个字典。
/**
// info dictionary keys
UIKIT_EXTERN NSString *const UIImagePickerControllerMediaType __TVOS_PROHIBITED;      // an NSString (UTI, i.e. kUTTypeImage)
UIKIT_EXTERN NSString *const UIImagePickerControllerOriginalImage __TVOS_PROHIBITED;  // a UIImage
UIKIT_EXTERN NSString *const UIImagePickerControllerEditedImage __TVOS_PROHIBITED;    // a UIImage
UIKIT_EXTERN NSString *const UIImagePickerControllerCropRect __TVOS_PROHIBITED;       // an NSValue (CGRect)
UIKIT_EXTERN NSString *const UIImagePickerControllerMediaURL __TVOS_PROHIBITED;       // an NSURL
UIKIT_EXTERN NSString *const UIImagePickerControllerReferenceURL        NS_AVAILABLE_IOS(4_1) __TVOS_PROHIBITED;  // an NSURL that references an asset in the AssetsLibrary framework
UIKIT_EXTERN NSString *const UIImagePickerControllerMediaMetadata       NS_AVAILABLE_IOS(4_1) __TVOS_PROHIBITED;  // an NSDictionary containing metadata from a captured photo
UIKIT_EXTERN NSString *const UIImagePickerControllerLivePhoto NS_AVAILABLE_IOS(9_1) __TVOS_PROHIBITED;  // a PHLivePhoto
/
- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info
{
    [picker dismissViewControllerAnimated:YES completion:nil];

    UIImage *image = [info objectForKey:UIImagePickerControllerEditedImage];

    // 保存图片到本地沙盒,
    [self saveImage:image withName:@&quot;avatar.png&quot;];

    NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:@&quot;avatar.png&quot;];
    UIImage *saveImage = [[UIImage alloc] initWithContentsOfFile:fullPath];

    // 设置图片显示
    self.imageView.image = saveImage;
    self.imageViewR.image = saveImage;
}

- (void)saveImage:(UIImage *)currentImage withName:(NSString *)imageName
{
    NSData *imageData = UIImageJPEGRepresentation(currentImage, 1); // 1为不缩放保存,取值为(0~1)

    // 获取沙河路径
    NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:imageName];
    // 将照片写入文件
    [imageData writeToFile:fullPath atomically:NO];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

@end
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发中，通常获取照片的方式有三种，1.直接调用摄像头拍照 2.从相册中选择 3.从图库中选择。 通常使用到的类或框架有UIImagePickerController,AssetsLibrary,PhotoKit(iOS8later)。本篇博客主要讲解UIImagePickerController，其他的后续会讲解到。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS照片" scheme="http://www.guiyongdong.com/categories/iOS%E7%85%A7%E7%89%87/"/>
    
    
      <category term="iOS照片" scheme="http://www.guiyongdong.com/tags/iOS%E7%85%A7%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>UIBezierPath详解</title>
    <link href="http://www.guiyongdong.com/2016/09/22/UIBezierPath%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.guiyongdong.com/2016/09/22/UIBezierPath详解/</id>
    <published>2016-09-22T07:51:31.000Z</published>
    <updated>2016-09-25T00:48:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在写本篇文章之前，也没有系统学习过贝塞尔曲线，只是曾经某一次的需求需要使用到，才临时百度看了一看而且使用最基本的功能。现在总算有时间停下来好好研究研究这个神奇而伟大的贝塞尔先生！</p>
<a id="more"></a>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><hr>
<p>使用<code>UIBezierPath</code>可以创建基于矢量的路径，此类是<code>Core Graphics</code>框架关于路径的封装。使用此类可以定义简单的形状，如椭圆、矩形或者有多个直线和曲线段组成的形状等。</p>
<p><code>UIBezierPath</code>是<code>CGPathRef</code>数据类型的封装。如果是基于矢量形状的路径，都用直线和曲线去创建。我们使用直线段去创建矩形和多边形，使用曲线去创建圆弧（arc）、圆或者其他复杂的曲线形状。</p>
<p>使用<code>UIBezierPath</code>画图步骤：</p>
<ol>
<li>创建一个UIBezierPath对象</li>
<li>调用-moveToPoint:设置初始线段的起点</li>
<li>添加线或者曲线去定义一个或者多个子路径</li>
<li>改变UIBezierPath对象跟绘图相关的属性。如，我们可以设置画笔的属性、填充样式等</li>
</ol>
<h4 id="UIBezierPath创建方法介绍"><a href="#UIBezierPath创建方法介绍" class="headerlink" title="UIBezierPath创建方法介绍"></a>UIBezierPath创建方法介绍</h4><hr>
<p>我们先看看<code>UIBezierPath</code>类提供了哪些创建方式，这些都是工厂方法，直接使用即可。</p>
<pre><code>
+ (instancetype)bezierPath;
+ (instancetype)bezierPathWithRect:(CGRect)rect;
+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;
+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                            cornerRadius:(CGFloat)cornerRadius;
+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                        byRoundingCorners:(UIRectCorner)corners 
                              cornerRadii:(CGSize)cornerRadii;
+ (instancetype)bezierPathWithArcCenter:(CGPoint)center 
                                 radius:(CGFloat)radius 
                             startAngle:(CGFloat)startAngle 
                               endAngle:(CGFloat)endAngle 
                              clockwise:(BOOL)clockwise;
+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;
</code></pre>

<p>下面我们一个一个地介绍其用途。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPath;</div></pre></td></tr></table></figure>
<p>这个使用比较多，因为这个工厂方法创建的对象，我们可以根据我们的需要任意定制样式，可以画任何我们想画的图形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithRect:(CGRect)rect;</div></pre></td></tr></table></figure>
<p>这个工厂方法根据一个矩形画贝塞尔曲线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;</div></pre></td></tr></table></figure>
<p>这个工厂方法根据一个矩形画内切曲线。通常用它来画圆或者椭圆。</p>
<pre><code>
+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                            cornerRadius:(CGFloat)cornerRadius;
+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect
                        byRoundingCorners:(UIRectCorner)corners 
                              cornerRadii:(CGSize)cornerRadii;
</code></pre>

<p>第一个工厂方法是画矩形，但是这个矩形是可以画圆角的。第一个参数是矩形，第二个参数是圆角大小。<br>第二个工厂方法功能是一样的，但是可以指定某一个角画成圆角。像这种我们就可以很容易地给UIView扩展添加圆角的方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithArcCenter:(CGPoint)center </div><div class="line">                                 radius:(CGFloat)radius </div><div class="line">                             startAngle:(CGFloat)startAngle </div><div class="line">                               endAngle:(CGFloat)endAngle </div><div class="line">                              clockwise:(BOOL)clockwise;</div></pre></td></tr></table></figure>
<p>这个工厂方法用于画弧，参数说明如下：<br><code>center</code>: 弧线中心点的坐标<br><code>radius</code>: 弧线所在圆的半径<br><code>startAngle</code>: 弧线开始的角度值<br><code>endAngle</code>: 弧线结束的角度值<br><code>clockwise</code>: 是否顺时针画弧线</p>
<blockquote>
<p>温馨提示：我们下面的代码都是在自定义的BezierPathView类中的<code>- (void)drawRect:(CGRect)rect</code>方法中调用</p>
</blockquote>
<h5 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h5><hr>
<p>先看效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_1.jpg?raw=true" alt="image"><br></div>

<pre><code>
// 画三角形
- (void)drawTrianglePath {

  UIBezierPath *path = [UIBezierPath bezierPath];
  [path moveToPoint:CGPointMake(20, 20)];
  [path addLineToPoint:CGPointMake(self.frame.size.width - 40, 20)];
  [path addLineToPoint:CGPointMake(self.frame.size.width / 2, self.frame.size.height - 20)];

  // 最后的闭合线是可以通过调用closePath方法来自动生成的，也可以调用-addLineToPoint:方法来添加
  //  [path addLineToPoint:CGPointMake(20, 20)];

  [path closePath];

  // 设置线宽
  path.lineWidth = 1.5;

  // 设置填充颜色
  UIColor *fillColor = [UIColor greenColor];
  [fillColor set];
  [path fill];

  // 设置画笔颜色
  UIColor *strokeColor = [UIColor blueColor];
  [strokeColor set];

  // 根据我们设置的各个点连线
  [path stroke];
}
</code></pre>

<p>我们设置画笔颜色通过set方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIColor *strokeColor = [UIColor blueColor];</div><div class="line">[strokeColor set];</div></pre></td></tr></table></figure></p>
<p>如果我们需要设置填充颜色，比如这里设置为绿色，那么我们需要在设置画笔颜色之前先设置填充颜色，否则画笔颜色就被填充颜色替代了。也就是说，如果要让填充颜色与画笔颜色不一样，那么我们的顺序必须是先设置填充颜色再设置画笔颜色。如下，这两者顺序不能改变。因为我们设置填充颜色也是跟设置画笔颜色一样调用UIColor的-set方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 设置填充颜色</div><div class="line">UIColor *fillColor = [UIColor greenColor];</div><div class="line">[fillColor set];</div><div class="line">[path fill];</div><div class="line"></div><div class="line">// 设置画笔颜色</div><div class="line">UIColor *strokeColor = [UIColor blueColor];</div><div class="line">[strokeColor set];</div></pre></td></tr></table></figure>
<h5 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h5><hr>
<p>先看效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_2.jpg?raw=true" alt="image"><br></div>

<pre><code>
// 画矩形
- (void)drawRectPath {
  UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(20, 20, self.frame.size.width - 40, self.frame.size.height - 40)];

  path.lineWidth = 1.5;
  path.lineCapStyle = kCGLineCapRound;
  path.lineJoinStyle = kCGLineJoinBevel;

  // 设置填充颜色
  UIColor *fillColor = [UIColor greenColor];
  [fillColor set];
  [path fill];

  // 设置画笔颜色
  UIColor *strokeColor = [UIColor blueColor];
  [strokeColor set];

  // 根据我们设置的各个点连线
  [path stroke];
}
</code></pre>

<p>lineCapStyle属性是用来设置线条拐角帽的样式的，其中有三个选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* Line cap styles. */</div><div class="line"></div><div class="line">typedef CF_ENUM(int32_t, CGLineCap) &#123;</div><div class="line">    kCGLineCapButt,</div><div class="line">    kCGLineCapRound,</div><div class="line">    kCGLineCapSquare</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，第一个是默认的，第二个是轻微圆角，第三个正方形。</p>
<p>lineJoinStyle属性是用来设置两条线连结点的样式，其中也有三个选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* Line join styles. */</div><div class="line"></div><div class="line">typedef CF_ENUM(int32_t, CGLineJoin) &#123;</div><div class="line">    kCGLineJoinMiter,</div><div class="line">    kCGLineJoinRound,</div><div class="line">    kCGLineJoinBevel</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，第一个是默认的表示斜接，第二个是圆滑衔接，第三个是斜角连接。</p>
<h5 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h5><hr>
<p>我们可以使用+ bezierPathWithOvalInRect:方法来画圆，当我们传的rect参数是一下正方形时，画出来的就是圆。</p>
<p>先看效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_3.jpg?raw=true" alt="image"><br></div>

<pre><code>
- (void)drawCiclePath {
  // 传的是正方形，因此就可以绘制出圆了
  UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(20, 20, self.frame.size.width - 40, self.frame.size.width - 40)];

  // 设置填充颜色
  UIColor *fillColor = [UIColor greenColor];
  [fillColor set];
  [path fill];

  // 设置画笔颜色
  UIColor *strokeColor = [UIColor blueColor];
  [strokeColor set];

  // 根据我们设置的各个点连线
  [path stroke];
}
</code></pre>

<blockquote>
<p>注意：要画圆，我们需要传的rect参数必须是正方形哦！</p>
</blockquote>
<h5 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h5><hr>
<p>先看效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_4.jpg?raw=true" alt="image"><br></div><br>前面我们已经画圆了，我们可以使用+ bezierPathWithOvalInRect:方法来画圆，当我们传的rect参数是一下正方形时，画出来的就是圆。那么我们要是不传正方形，那么绘制出来的就是椭圆了。<br><br><pre><code><br>// 画椭圆<br>- (void)drawOvalPath {<br>  // 传的是不是正方形，因此就可以绘制出椭圆圆了<br>  UIBezierPath <em>path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(20, 20, self.frame.size.width - 80, self.frame.size.height - 40)];<br><br>  // 设置填充颜色<br>  UIColor </em>fillColor = [UIColor greenColor];<br>  [fillColor set];<br>  [path fill];<br><br>  // 设置画笔颜色<br>  UIColor <em>strokeColor = [UIColor blueColor];<br>  [strokeColor set];<br><br>  // 根据我们设置的各个点连线<br>  [path stroke];<br>}<br></em></code></pre><br><br>##### 画带圆角的矩形<br>**<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect</div><div class="line">                            cornerRadius:(CGFloat)cornerRadius;</div><div class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect</div><div class="line">                        byRoundingCorners:(UIRectCorner)corners </div><div class="line">                              cornerRadii:(CGSize)cornerRadii;</div></pre></td></tr></table></figure><br><br>第一个工厂方法是画矩形，但是这个矩形是可以画圆角的。第一个参数是矩形，第二个参数是圆角大小。<br>第二个工厂方法功能是一样的，但是可以指定某一个角画成圆角。像这种我们就可以很容易地给UIView扩展添加圆角的方法了。<br><br>四个都是圆角10：<br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_5.jpg?raw=true" alt="image"><br></div>

<pre><code>
- (void)drawRoundedRectPath {
  UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, self.frame.size.width - 40, self.frame.size.height - 40) cornerRadius:10];

  // 设置填充颜色
  UIColor *fillColor = [UIColor greenColor];
  [fillColor set];
  [path fill];

  // 设置画笔颜色
  UIColor *strokeColor = [UIColor blueColor];
  [strokeColor set];

  // 根据我们设置的各个点连线
  [path stroke];
}
</code></pre>

<p>如果要画只有一个角是圆角，那么我们就修改创建方法：</p>
<pre><code>
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(20, 20, self.frame.size.width - 40, self.frame.size.height - 40) byRoundingCorners:UIRectCornerTopRight cornerRadii:CGSizeMake(20, 20)];
</code></pre>

<p>其中第一个参数一样是传了个矩形，第二个参数是指定在哪个方向画圆角，第三个参数是一个CGSize类型，用来指定水平和垂直方向的半径的大小。看下效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_6.jpg?raw=true" alt="image"><br></div>

<h5 id="画弧"><a href="#画弧" class="headerlink" title="画弧"></a>画弧</h5><hr>
<p>画弧前，我们需要了解其参考系，如下图（图片来自网络）：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_7.jpg?raw=true" alt="image"><br></div>

<pre><code>
#define   kDegreesToRadians(degrees)  ((pi * degrees)/ 180)
- (void)drawARCPath {
  const CGFloat pi = 3.14159265359;

  CGPoint center = CGPointMake(self.frame.size.width / 2, self.frame.size.height / 2);
  UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:center
                                                      radius:100
                                                  startAngle:0
                                                    endAngle:kDegreesToRadians(135)
                                                   clockwise:YES];

  path.lineCapStyle = kCGLineCapRound;
  path.lineJoinStyle = kCGLineJoinRound;
  path.lineWidth = 5.0;

  UIColor *strokeColor = [UIColor redColor];
  [strokeColor set];

  [path stroke];
}
</code></pre>

<p>效果图如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_8.jpg?raw=true" alt="image"><br></div>

<p>我们要明确一点，画弧参数startAngle和endAngle使用的是弧度，而不是角度，因此我们需要将常用的角度转换成弧度。对于效果图中，我们设置弧的中心为控件的中心，起点弧度为0，也就是正东方向，而终点是135度角的位置。如果设置的clockwise:YES是逆时针方向绘制，如果设置为NO，效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_9.jpg?raw=true" alt="image"><br></div>

<p>这两者正好是相反的。</p>
<h5 id="画二次贝塞尔曲线"><a href="#画二次贝塞尔曲线" class="headerlink" title="画二次贝塞尔曲线"></a>画二次贝塞尔曲线</h5><hr>
<p>先来学习一下关于控制点，如下图（图片来自网络）：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_10.jpeg?raw=true" alt="image"><br></div><br>画二次贝塞尔曲线，是通过调用此方法来实现的：<br><br><pre><code>- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint<br></code></pre><br><br>参数说明：<br><br>endPoint：终端点<br><br>controlPoint：控制点，对于二次贝塞尔曲线，只有一个控制点<br><br>看效果图：<br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_11.jpg?raw=true" alt="image"><br></div>

<pre><code>
- (void)drawSecondBezierPath {
  UIBezierPath *path = [UIBezierPath bezierPath];

  // 首先设置一个起始点
  [path moveToPoint:CGPointMake(20, self.frame.size.height - 100)];

  // 添加二次曲线
  [path addQuadCurveToPoint:CGPointMake(self.frame.size.width - 20, self.frame.size.height - 100)
               controlPoint:CGPointMake(self.frame.size.width / 2, 0)];

  path.lineCapStyle = kCGLineCapRound;
  path.lineJoinStyle = kCGLineJoinRound;
  path.lineWidth = 5.0;

  UIColor *strokeColor = [UIColor redColor];
  [strokeColor set];

  [path stroke];
}
</code></pre>

<p>画二次贝塞尔曲线的步骤：</p>
<ol>
<li>先设置一个起始点，也就是通过-moveToPoint:设置</li>
<li>调用-addQuadCurveToPoint:controlPoint:方法设置终端点和控制点，以画二次曲线</li>
</ol>
<p>在效果图中，拱桥左边的起始点就是我们设置的起始点，最右边的终点，就是我们设置的终端点，而我们设置的控制点为（width / 2, 0）对应于红色矩形中水平方向在正中央，而垂直方向在最顶部。</p>
<blockquote>
<p>这个样式看起来很像sin或者cos函数吧？这两个只是特例而已，其实可以画任意图形，只是想不到，没有做不到的。</p>
</blockquote>
<h5 id="画三次贝塞尔曲线"><a href="#画三次贝塞尔曲线" class="headerlink" title="画三次贝塞尔曲线"></a>画三次贝塞尔曲线</h5><hr>
<p>贝塞尔曲线必定通过首尾两个点，称为端点；中间两个点虽然未必要通过，但却起到牵制曲线形状路径的作用，称作控制点。关于三次贝塞尔曲线的控制器，看下图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_12.jpeg?raw=true" alt="image"><br></div>

<blockquote>
<p>提示：其组成是起始端点+控制点1+控制点2+终止端点</p>
</blockquote>
<p>如下方法就是画三次贝塞尔曲线的关键方法，以三个点画一段曲线，一般和-moveToPoint:配合使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)addCurveToPoint:(CGPoint)endPoint </div><div class="line">          controlPoint1:(CGPoint)controlPoint1 </div><div class="line">          controlPoint2:(CGPoint)controlPoint2</div></pre></td></tr></table></figure>
<p>看下效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/UIBezierPath/UIBezierPath_13.jpg?raw=true" alt="image"><br></div>

<p>实现代码是这样的：</p>
<pre><code>
- (void)drawThirdBezierPath {
  UIBezierPath *path = [UIBezierPath bezierPath];

  // 设置起始端点
  [path moveToPoint:CGPointMake(20, 150)];

  [path addCurveToPoint:CGPointMake(300, 150)
          controlPoint1:CGPointMake(160, 0)
          controlPoint2:CGPointMake(160, 250)];

  path.lineCapStyle = kCGLineCapRound;
  path.lineJoinStyle = kCGLineJoinRound;
  path.lineWidth = 5.0;

  UIColor *strokeColor = [UIColor redColor];
  [strokeColor set];

  [path stroke];
}
</code></pre>

<p>我们需要注意，这里确定的起始端点为(20,150)，终止端点为(300, 150)，基水平方向是一致的。控制点1的坐标是（160，0），水平方向相当于在中间附近，这个参数可以调整。控制点2的坐标是（160，250），如果以两个端点的连线为水平线，那么就是250-150=100，也就是在水平线下100。这样看起来就像一个sin函数了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在写本篇文章之前，也没有系统学习过贝塞尔曲线，只是曾经某一次的需求需要使用到，才临时百度看了一看而且使用最基本的功能。现在总算有时间停下来好好研究研究这个神奇而伟大的贝塞尔先生！&lt;/p&gt;
    
    </summary>
    
      <category term="动画" scheme="http://www.guiyongdong.com/categories/%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="UIBezierPath" scheme="http://www.guiyongdong.com/tags/UIBezierPath/"/>
    
  </entry>
  
  <entry>
    <title>iOS动画之CATransition动画</title>
    <link href="http://www.guiyongdong.com/2016/09/22/iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCATransition%E5%8A%A8%E7%94%BB/"/>
    <id>http://www.guiyongdong.com/2016/09/22/iOS动画之CATransition动画/</id>
    <published>2016-09-22T07:35:15.000Z</published>
    <updated>2016-09-25T01:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要用到的动画类是CALayer下的CATransition至于各种动画类中如何继承的在这也不做赘述，网上的资料是一抓一大把。好废话少说切入今天的正题。</p>
<a id="more"></a>
<h3 id="一-封装动画方法"><a href="#一-封装动画方法" class="headerlink" title="一.封装动画方法"></a>一.封装动画方法</h3><h5 id="1-用CATransition实现动画的封装方法如下，每句代码是何意思，请看注释之。"><a href="#1-用CATransition实现动画的封装方法如下，每句代码是何意思，请看注释之。" class="headerlink" title="1.用CATransition实现动画的封装方法如下，每句代码是何意思，请看注释之。"></a>1.用CATransition实现动画的封装方法如下，每句代码是何意思，请看注释之。</h5><pre><code>
 #pragma CATransition动画实现
 - (void) transitionWithType:(NSString *) type WithSubtype:(NSString *) subtype ForView : (UIView *) view
 {
     //创建CATransition对象
     CATransition *animation = [CATransition animation];

     //设置运动时间
     animation.duration = DURATION;

     //设置运动type
     animation.type = type;
     if (subtype != nil) {

         //设置子类
         animation.subtype = subtype;
     }

     //设置运动速度
     animation.timingFunction = UIViewAnimationOptionCurveEaseInOut;

     [view.layer addAnimation:animation forKey:@"animation"];
 }
</code></pre>

<p><strong>代码说明：</strong><br><strong>CATransition</strong>常用的属性如下：</p>
<ul>
<li><strong>duration</strong>:设置动画时间</li>
<li><strong>type</strong>:稍后下面会详细的介绍运动类型</li>
<li><strong>subtype</strong>:和type匹配使用，指定运动的方向，下面也会详细介绍</li>
<li><strong>timingFunction</strong> ：<ul>
<li>动画的运动轨迹，用于变化起点和终点之间的插值计算,形象点说它决定了动画运行的节奏,比如是均匀变化(相同时间变化量相同)还是先快后慢,先慢后快还是先慢再快再慢.</li>
<li>动画的开始与结束的快慢,有五个预置分别为(下同):<ul>
<li>kCAMediaTimingFunctionLinear            线性,即匀速</li>
<li>kCAMediaTimingFunctionEaseIn            先慢后快</li>
<li>kCAMediaTimingFunctionEaseOut           先快后慢</li>
<li>kCAMediaTimingFunctionEaseInEaseOut     先慢后快再慢</li>
<li>kCAMediaTimingFunctionDefault           实际效果是动画中间比较快.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-用UIView的block回调实现动画的代码封装"><a href="#2-用UIView的block回调实现动画的代码封装" class="headerlink" title="2.用UIView的block回调实现动画的代码封装　"></a>2.用UIView的block回调实现动画的代码封装　</h5><pre><code>
 #pragma UIView实现动画
 - (void) animationWithView : (UIView *)view WithAnimationTransition : (UIViewAnimationTransition) transition
 {
     [UIView animateWithDuration:DURATION animations:^{
         [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];
         [UIView setAnimationTransition:transition forView:view cache:YES];
     }];
 }
</code></pre>

<h5 id="3-改变View的背景图，便于切换时观察"><a href="#3-改变View的背景图，便于切换时观察" class="headerlink" title="3.改变View的背景图，便于切换时观察"></a>3.改变View的背景图，便于切换时观察</h5><pre><code>
 #pragma 给View添加背景图
 -(void)addBgImageWithImageName:(NSString *) imageName
 {
     self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:imageName]];
 }
</code></pre>

<h3 id="二-调用上面的方法实现我们想要的动画"><a href="#二-调用上面的方法实现我们想要的动画" class="headerlink" title="二.调用上面的方法实现我们想要的动画"></a>二.调用上面的方法实现我们想要的动画</h3><h5 id="1-我们在View上添加多个Button-给不同的Button设置不同的Tag值，然后再ViewController中绑定同一个方法，点击不同的button实现不同的页面切换效果。storyBoard上的控件效果如下图所示："><a href="#1-我们在View上添加多个Button-给不同的Button设置不同的Tag值，然后再ViewController中绑定同一个方法，点击不同的button实现不同的页面切换效果。storyBoard上的控件效果如下图所示：" class="headerlink" title="1.我们在View上添加多个Button,给不同的Button设置不同的Tag值，然后再ViewController中绑定同一个方法，点击不同的button实现不同的页面切换效果。storyBoard上的控件效果如下图所示："></a>1.我们在View上添加多个Button,给不同的Button设置不同的Tag值，然后再ViewController中绑定同一个方法，点击不同的button实现不同的页面切换效果。storyBoard上的控件效果如下图所示：</h5><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_1.png?raw=true" alt="image" width="375" height="667/"><br></div>

<h5 id="2-下面我们就开始编写点击button要回调的方法"><a href="#2-下面我们就开始编写点击button要回调的方法" class="headerlink" title="2.下面我们就开始编写点击button要回调的方法"></a>2.下面我们就开始编写点击button要回调的方法</h5><ul>
<li>定义枚举来标示按钮所对应的动画类型，代码如下：</li>
</ul>
<pre><code>
typedef enum : NSUInteger {
    Fade = 1,                   //淡入淡出
    Push,                       //推挤
    Reveal,                     //揭开
    MoveIn,                     //覆盖
    Cube,                       //立方体
    SuckEffect,                 //吮吸
    OglFlip,                    //翻转
    RippleEffect,               //波纹
    PageCurl,                   //翻页
    PageUnCurl,                 //反翻页
    CameraIrisHollowOpen,       //开镜头
    CameraIrisHollowClose,      //关镜头
    CurlDown,                   //下翻页
    CurlUp,                     //上翻页
    FlipFromLeft,               //左翻转
    FlipFromRight,              //右翻转

} AnimationType;
</code></pre>

<ul>
<li>获取Button的Tag值：</li>
</ul>
<pre><code>
     UIButton *button = sender;
     AnimationType animationType = button.tag;
</code></pre>

<ul>
<li>每次点击button都改变subtype的值，包括上,左,下,右</li>
</ul>
<pre><code>
NSString *subtypeString;

    switch (_subtype) {
        case 0:
            subtypeString = kCATransitionFromLeft;
            break;
        case 1:
            subtypeString = kCATransitionFromBottom;
            break;
        case 2:
            subtypeString = kCATransitionFromRight;
            break;
        case 3:
            subtypeString = kCATransitionFromTop;
            break;
        default:
            break;
    }
    _subtype += 1;
    if (_subtype > 3) {
        _subtype = 0;
    }
</code></pre>

<ul>
<li>通过switch结合上边的枚举来判断是那个按钮点击的</li>
</ul>
<pre><code>
 switch (animationType)
 {
     //各种Case,此处代码下面会给出  
 }
</code></pre>

<h5 id="3-调用我们封装的运动方法，来实现动画效果"><a href="#3-调用我们封装的运动方法，来实现动画效果" class="headerlink" title="3.调用我们封装的运动方法，来实现动画效果"></a>3.调用我们封装的运动方法，来实现动画效果</h5><ul>
<li>淡化效果</li>
</ul>
<pre><code>
case Fade:
     [self transitionWithType:kCATransitionFade WithSubtype:subtypeString ForView:self.view];
     break;
</code></pre>

<ul>
<li>Push效果</li>
</ul>
<pre><code>
case Push: 
     [self transitionWithType:kCATransitionPush WithSubtype:subtypeString ForView:self.view];
     break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_2.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>揭开效果：</li>
</ul>
<pre><code>
case Reveal:
    [self transitionWithType:kCATransitionReveal WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_3.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>覆盖效果：</li>
</ul>
<pre><code>
case MoveIn:
    [self transitionWithType:kCATransitionMoveIn WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_4.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>立方体效果：</li>
</ul>
<pre><code>
case Cube:
    [self transitionWithType:@"cube" WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_5.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>吮吸效果：</li>
</ul>
<pre><code>
case SuckEffect:
    [self transitionWithType:@"suckEffect" WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_6.png?raw=true" alt="image" width="375" height="667"><br></div>

<ul>
<li>翻转效果：</li>
</ul>
<pre><code>
case OglFlip:
    [self transitionWithType:@"oglFlip" WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_7.png?raw=true" alt="image" width="375" height="667"><br></div> 

<ul>
<li>波纹效果：</li>
</ul>
<pre><code>
case RippleEffect:
    [self transitionWithType:@"rippleEffect" WithSubtype:subtypeString ForView:self.view];
    break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_8.png?raw=true" alt="image" width="375" height="667"><br></div> 

<ul>
<li>翻页和反翻页效果：</li>
</ul>
<pre><code>
case PageCurl:
            [self transitionWithType:@"pageCurl" WithSubtype:subtypeString ForView:self.view];
            break;

        case PageUnCurl:
            [self transitionWithType:@"pageUnCurl" WithSubtype:subtypeString ForView:self.view];
            break;
</code></pre>

<p>效果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_9.png?raw=true" alt="image" width="375" height="667"><br></div><br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_10.png?raw=true" alt="image" width="375" height="667"><br></div> 

<ul>
<li>相机打开效果：</li>
</ul>
<pre><code>
case CameraIrisHollowOpen:
            [self transitionWithType:@"cameraIrisHollowOpen" WithSubtype:subtypeString ForView:self.view];
            break;

        case CameraIrisHollowClose:
            [self transitionWithType:@"cameraIrisHollowClose" WithSubtype:subtypeString ForView:self.view];
            break;
</code></pre>

<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_11.png?raw=true" alt="image" width="375" height="667"><br></div> 

<ul>
<li>调用上面封装的第二个动画方法</li>
</ul>
<pre><code>
case CurlDown:
            [self animationWithView:self.view WithAnimationTransition:UIViewAnimationTransitionCurlDown];
            break;

        case CurlUp:
            [self animationWithView:self.view WithAnimationTransition:UIViewAnimationTransitionCurlUp];
            break;

        case FlipFromLeft:
            [self animationWithView:self.view WithAnimationTransition:UIViewAnimationTransitionFlipFromLeft];
            break;

        case FlipFromRight:
            [self animationWithView:self.view WithAnimationTransition:UIViewAnimationTransitionFlipFromRight];
            break;
</code></pre>

<p><a href="https://github.com/guiyongdong/Resource/tree/master/demo/CATransitionDemo" target="_blank" rel="external">Demo传送门</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要用到的动画类是CALayer下的CATransition至于各种动画类中如何继承的在这也不做赘述，网上的资料是一抓一大把。好废话少说切入今天的正题。&lt;/p&gt;
    
    </summary>
    
      <category term="动画" scheme="http://www.guiyongdong.com/categories/%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="动画" scheme="http://www.guiyongdong.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS动画篇之CoreAnimation动画</title>
    <link href="http://www.guiyongdong.com/2016/09/22/iOS%E5%8A%A8%E7%94%BB%E7%AF%87%E4%B9%8BCoreAnimation%E5%8A%A8%E7%94%BB/"/>
    <id>http://www.guiyongdong.com/2016/09/22/iOS动画篇之CoreAnimation动画/</id>
    <published>2016-09-22T06:08:56.000Z</published>
    <updated>2016-09-25T01:21:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>App如果想被大众喜欢，漂亮的UI和精美的动画都是必不可少的，苹果虽然为UIView提供了一些常用动画，但是大部分看起来比较不错的效果都是通过操作Layer层实现的，因此了解核心动画是必要的.CoreAnimation是直接作用在CALayer上的(并非UIView上)非常强大的跨Mac OS X和iOS平台的动画处理API，Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。<br><a id="more"></a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>开发中用的最多的是<code>CoreAnimation</code>动画库，简称是CA，所以动画类都是CA开头。所有的动画类都在<code>QuartzCore</code>库中，在iOS7之前使用需要<code>#import &lt;QuartzCore/QuartzCore.h&gt;</code>,iOS7之后系统已经将其自动导入了。<code>CoreAnimation</code>动画都是作用在<code>layer</code>上。<br>先来看下动画类的层级关系：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_12.png?raw=true" alt="动画层级结构"><br></div><br>关于上图中的层级结构只需要了解一下，用的多了，自然就记住了。本篇只讲述<code>CABasicAnimation</code>、<code>CAKeyframeAnimation</code>、<code>CAAnimationGroup</code>的使用。<br><br>### 使用<br>上面讲了CA动画都是作用在Layer上，而CA动画中修改的也是Layer的动画属性，可以产生动画的layer属性也有<code>Animatable</code>标识。<br>#### 1.CABasicAnimation<br><code>CABasicAnimation</code>动画主要是设置某个动画属性的初始值fromValue和结束值toValue，来产生动画效果。<br>先上个示例代码，将一个视图往上移动一段距离：<br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_13.gif?raw=true" alt="animation"><br></div>

<pre><code>
CABasicAnimation *postionAnimation = [CABasicAnimation animationWithKeyPath:@"position.y"];
postionAnimation.duration = 1.0f;
postionAnimation.fromValue = @(self.squareView.center.y);
postionAnimation.toValue = @(self.squareView.center.y - 300);
postionAnimation.removedOnCompletion = NO;
postionAnimation.delegate = self;
postionAnimation.autoreverses = YES;
postionAnimation.fillMode = kCAFillModeForwards;
postionAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
[self.squareView.layer addAnimation:postionAnimation forKey:@"posstionAnimation"];
</code></pre>

<blockquote>
<ul>
<li>动画的创建使用<code>animationWithKeyPath:</code>,因为使用的keyPath所以动画属性或者其结构体中元素都可以产生动画。</li>
<li><code>duration</code> 动画的时长。</li>
<li><code>fromValue</code>和<code>toValue</code> 是<code>CABasicAnimation</code>的属性，都是id类型的，所以要将基本类型包装成对象。</li>
<li><code>removedOnCompletion</code> 决定动画执行完之后是否将该动画的影响移除，默认是YES,则layer回到动画前的状态。</li>
<li><code>fillMode</code> 是个枚举值（四种），当<code>removedOnCompletion</code>设置为NO之后才会起作用。可以设置layer是保持动画开始前的状态还是动画结束后的状态，或是其他的。</li>
<li><code>autoreverses</code> 表示动画结束后是否 backwards(回退) 到动画开始前的状态。可与上面两个属性组合出不同效果。</li>
<li><code>timingFunction</code> 动画的运动是匀速线性的还是先快后慢等，类似UIView动画的opitions。另外，CAMediaTimingFunction 方法可以自定义。</li>
<li><code>delegate</code> 代理，两个动画代理方法：<code>- (void)animationDidStart:(CAAnimation *)anim</code>; 和<code>- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</code>;</li>
<li><code>-(void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key</code>; 给某个layer添加动画，与之对应的移除某个动画是<code>- (void)removeAnimationForKey:(NSString *)key</code>;</li>
<li>还有一些其他的属性，就不一一介绍了，可以在使用的使用去.h文件中查看。</li>
</ul>
</blockquote>
<p>在这里简单介绍一下fillMode<br>注意：fillMode这个属性，必须要配合下面这个属性来使用。这个属性的默认值是YES(回到原处),此时fillMode是没有作用的如果设置为NO那么就需要设置一个fillMode属性，就是动画结束之后的状态，如果不设置，动画也会回到原处。</p>
<p><code>postionAnimation.removedOnCompletion = NO;</code></p>
<pre><code>
kCAFillModeRemoved 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态 
kCAFillModeForwards 当动画结束后,layer会一直保持着动画最后的状态 
kCAFillModeBackwards 这个和kCAFillModeForwards是相对的,就是在动画开始前,你只要将动画加入了
一个layer,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,将一个动画加入一个
layer的时候延迟5秒执行.然后就会发现在动画没有开始的时候,只要动画被加入了layer,layer便处于动画初
始状态 
kCAFillModeBoth 理解了上面两个,这个就很好理解了,这个其实就是上面两个的合成.动画加入后开始之
前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态.</code></pre>    


<h5 id="Rotation旋转"><a href="#Rotation旋转" class="headerlink" title="Rotation旋转"></a>Rotation旋转</h5><ul>
<li><strong>Z轴</strong></li>
</ul>
<pre><code>
CABasicAnimation *rotationAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation"];
rotationAnimation.fromValue = [NSNumber numberWithFloat:0.0];
rotationAnimation.toValue = [NSNumber numberWithFloat:2*M_PI];
rotationAnimation.repeatCount = MAXFLOAT;
rotationAnimation.duration =10;
[self.rotationImgView.layer addAnimation:rotationAnimation forKey:@"transform.rotation.z"];
</code></pre>

<ul>
<li><strong>X轴</strong></li>
</ul>
<pre><code>
CABasicAnimation *rotationXAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.x"];
rotationXAnimation.fromValue = [NSNumber numberWithFloat:0.0];
rotationXAnimation.toValue = [NSNumber numberWithFloat:2*M_PI];
rotationXAnimation.repeatCount = MAXFLOAT;
rotationXAnimation.duration =3;
[self.rotationXImgView.layer addAnimation:rotationXAnimation forKey:@"transform.rotation.x"];
</code></pre>

<ul>
<li><strong>Y轴</strong></li>
</ul>
<pre><code>
CABasicAnimation *rotationYAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"];
rotationYAnimation.fromValue = [NSNumber numberWithFloat:0.0];
rotationYAnimation.toValue = [NSNumber numberWithFloat:2*M_PI];
rotationYAnimation.repeatCount = MAXFLOAT;
rotationYAnimation.duration =10;
[self.rotationYImgView.layer addAnimation:rotationYAnimation forKey:@"transform.rotation.y"];
</code></pre>

<h5 id="Scale放大缩小"><a href="#Scale放大缩小" class="headerlink" title="Scale放大缩小"></a>Scale放大缩小</h5><ul>
<li><strong>任意方向放大</strong></li>
</ul>
<pre><code>
CABasicAnimation *scaleAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale"];
scaleAnimation.fromValue = [NSNumber numberWithFloat:1.0];
scaleAnimation.toValue = [NSNumber numberWithFloat:1.5];
scaleAnimation.autoreverses = YES;//自动反向执行动画效果
scaleAnimation.repeatCount = MAXFLOAT;
scaleAnimation.duration = 0.8;
[self.scaleImgView.layer addAnimation:scaleAnimation forKey:@"FlyElephant.scale"];
</code></pre>

<ul>
<li><strong>X轴放大</strong></li>
</ul>
<pre><code>
CABasicAnimation *scaleXAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale.x"];
scaleXAnimation.fromValue = [NSNumber numberWithFloat:1.0];
scaleXAnimation.toValue = [NSNumber numberWithFloat:1.5];
scaleXAnimation.autoreverses = YES;//自动反向执行动画效果
scaleXAnimation.repeatCount = MAXFLOAT;
scaleXAnimation.duration = 0.8;
[self.scaleXImgView.layer addAnimation:scaleXAnimation forKey:@"FlyElephant.scale.x"];
</code></pre>

<ul>
<li><strong>Y轴放大</strong></li>
</ul>
<pre><code>
CABasicAnimation *scaleYAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale.y"];
scaleYAnimation.fromValue = [NSNumber numberWithFloat:1.0];
scaleYAnimation.toValue = [NSNumber numberWithFloat:1.5];
scaleYAnimation.autoreverses = YES;//自动反向执行动画效果
scaleYAnimation.repeatCount = MAXFLOAT;
scaleYAnimation.duration = 0.8;
[self.scaleYImgView.layer addAnimation:scaleYAnimation forKey:@"FlyElephant.scale.y"];
</code></pre>

<ul>
<li><strong>Z轴放大</strong></li>
</ul>
<pre><code>
CABasicAnimation *scaleZAnimation = [CABasicAnimation animationWithKeyPath:@"transform.scale.z"];
scaleZAnimation.fromValue = [NSNumber numberWithFloat:1.0];
scaleZAnimation.toValue = [NSNumber numberWithFloat:1.5];
scaleZAnimation.autoreverses = YES;//自动反向执行动画效果
scaleZAnimation.repeatCount = MAXFLOAT;
scaleZAnimation.duration = 0.8;
[self.scaleZImgView.layer addAnimation:scaleZAnimation forKey:@"FlyElephant.scale.z"];
</code></pre>

<h5 id="Translation平移"><a href="#Translation平移" class="headerlink" title="Translation平移"></a>Translation平移</h5><ul>
<li><strong>X轴平移</strong></li>
</ul>
<pre><code>
CABasicAnimation *translationX=[CABasicAnimation animationWithKeyPath:@"transform.translation.x"];
translationX.toValue=@(200);
translationX.duration=5;
translationX.removedOnCompletion=NO;
translationX.fillMode=kCAFillModeForwards;
translationX.repeatCount=MAXFLOAT;
translationX.autoreverses=YES;
[self.translationXImgView.layer addAnimation:translationX forKey:@"FlyElephant.translation.x"];

</code></pre>

<ul>
<li><strong>Y轴平移</strong></li>
</ul>
<pre><code>
CABasicAnimation *translationY=[CABasicAnimation animationWithKeyPath:@"transform.translation.y"];
translationY.toValue=@(100);
translationY.duration=5;
translationY.removedOnCompletion=NO;
translationY.fillMode=kCAFillModeForwards;
translationY.repeatCount=MAXFLOAT;
translationY.autoreverses=YES;
[self.translationYImgView.layer addAnimation:translationY forKey:@"FlyElephant.translation.y"];
</code></pre>

<ul>
<li><strong>XY轴平移</strong></li>
</ul>
<pre><code>
CABasicAnimation *translation=[CABasicAnimation animationWithKeyPath:@"transform.translation"];
translation.toValue=[NSValue valueWithCGPoint:CGPointMake(100, 100)];
translation.duration=5;
translation.removedOnCompletion=NO;
translation.fillMode=kCAFillModeForwards;
translation.repeatCount=MAXFLOAT;
translation.autoreverses=YES;
[self.translationImgView.layer addAnimation:translation forKey:@"FlyElephant.translation"];
</code></pre>

<p><font color="blue"><strong>动画实例图：</strong></font></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_14.gif?raw=true" alt="animation"><br></div>

<h4 id="2-CAKeyframeAnimation"><a href="#2-CAKeyframeAnimation" class="headerlink" title="2.CAKeyframeAnimation"></a>2.CAKeyframeAnimation</h4><p>CAKeyframeAnimation我们一般称为关键帧动画，主要是利用其values属性，设置多个关键帧属性值，来产生动画。</p>
<h5 id="基于Scale变换"><a href="#基于Scale变换" class="headerlink" title="基于Scale变换:"></a>基于Scale变换:</h5><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_15.gif?raw=true" alt="animation"><br></div>

<pre><code>
CAKeyframeAnimation *keyAnimation = [CAKeyframeAnimation animationWithKeyPath:@"transform"];
keyAnimation.duration = 1.0f;
keyAnimation.beginTime = CACurrentMediaTime() + 1.0;

CATransform3D transform1 = CATransform3DMakeScale(1.5, 1.5, 0);
CATransform3D transform2 = CATransform3DMakeScale(0.8, 0.8, 0);
CATransform3D transform3 = CATransform3DMakeScale(3, 3, 0);

keyAnimation.values = @[[NSValue valueWithCATransform3D:transform1],[NSValue valueWithCATransform3D:transform2],[NSValue valueWithCATransform3D:transform3]];
keyAnimation.keyTimes = @[@0,@0.5,@1];
keyAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
keyAnimation.removedOnCompletion = NO;
keyAnimation.fillMode = kCAFillModeForwards;
[_someView.layer addAnimation:keyAnimation forKey:nil];
</code></pre>

<blockquote>
<ul>
<li><code>beginTime</code> 也是<code>CAAnimation</code>类的属性，可以设置动画延迟多久执行，示例代码是延迟1秒执行。</li>
<li><code>values</code> 是<code>CAKeyframeAnimation</code>的属性，设置keyPath属性在几个关键帧的值，也是id类型的。</li>
<li><code>keyTimes</code> 也是<code>CAKeyframeAnimation</code>的属性，每个值对应相应关键帧的时间比例值。</li>
<li><code>timingFunctions</code> 也是<code>CAKeyframeAnimation</code>的属性，对应每个动画段的动画过渡情况；而<code>timingFunction</code>是<code>CAAnimation</code>的属性。</li>
</ul>
</blockquote>
<h5 id="基于Point的变换"><a href="#基于Point的变换" class="headerlink" title="基于Point的变换:"></a>基于Point的变换:</h5><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_16.gif?raw=true" alt="animation"><br></div>

<pre><code>
CGPoint p1=CGPointMake(self.positionImgView.center.x, self.positionImgView.center.y);
CGPoint p2=CGPointMake(80, 100);
CGPoint p3=CGPointMake(100, 120);

CGPoint p4=CGPointMake(120, 150);
CGPoint p5=CGPointMake(140, 160);
NSArray *values=[NSArray arrayWithObjects:[NSValue valueWithCGPoint:p1],[NSValue valueWithCGPoint:p2],[NSValue valueWithCGPoint:p3],[NSValue valueWithCGPoint:p4],[NSValue valueWithCGPoint:p5], nil];
CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"position"];
[animation setValues:values];
[animation setDuration:10.0];
[animation setCalculationMode:kCAAnimationCubic];
animation.timingFunction=[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];
[self.positionImgView.layer addAnimation:animation forKey:@"FlyElephant.point"];
</code></pre>

<h5 id="基于Path的变换"><a href="#基于Path的变换" class="headerlink" title="基于Path的变换:"></a>基于Path的变换:</h5><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_17.gif?raw=true" alt="animation"><br></div>

<pre><code>
CGMutablePathRef path = CGPathCreateMutable();
CGPathMoveToPoint(path,NULL,self.positionImgView.center.x,self.positionImgView.center.y);
for(NSInteger i = 1; i < 5 i++){
    CGPathAddLineToPoint(path, NULL, self.positionImgView.center.x+i*10,     self.positionImgView.center.y);
}
//曲线
CGPathAddCurveToPoint(path,NULL,50.0,275.0,150.0,275.0,70.0,120.0);
CGPathAddCurveToPoint(path,NULL,150.0,275.0,250.0,275.0,90.0,120.0);
CGPathAddCurveToPoint(path,NULL,250.0,275.0,350.0,275.0,110.0,120.0);
CGPathAddCurveToPoint(path,NULL,350.0,275.0,450.0,275.0,130.0,120.0);
CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"position"];
[animation setPath:path];
[animation setDuration:3.0];
// [animation setAutoreverses:YES];
CFRelease(path);
[self.positionImgView.layer addAnimation:animation:@"FlyElephant"];
</code></pre>

<p>通过代码我们发现，Path和values接收都是一个数组，而不是一个固定值，这里面我们没有设置keyTimes，下面看一个常见的抖动效果:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_18.gif?raw=true" alt="animation"><br></div>

<pre><code>
CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
animation.keyPath = @"position.x";
animation.values = @[ @0, @20, @-20, @20, @0 ];
animation.keyTimes = @[ @0, @(1 /8.0), @(1/ 2.0), @(7/ 8.0), @1 ];
animation.duration =0.5;
animation.additive = YES;
[self.textField.layer addAnimation:animation forKey:@"FlyElephant.Shake"];
</code></pre>

<h4 id="3-CAAnimationGroup"><a href="#3-CAAnimationGroup" class="headerlink" title="3.CAAnimationGroup"></a>3.CAAnimationGroup</h4><p>CAAnimationGroup的用法与其他动画类一样，都是添加到layer上，比CAAnimation多了一个animations属性。<br>先看示例代码，动画效果是视图一边向上移动，一边绕Y轴旋转：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_19.gif?raw=true" alt="animation"><br></div>

<pre><code>
CABasicAnimation *rotationYAnimation = [CABasicAnimation animationWithKeyPath:@"transform.rotation.y"];
rotationYAnimation.fromValue = @0;
rotationYAnimation.toValue = @(M_PI);
rotationYAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];

CABasicAnimation *postionAnimation = [CABasicAnimation animationWithKeyPath:@"position.y"];
postionAnimation.fromValue = @(_markView.center.y);
postionAnimation.toValue = @(_markView.center.y - 100);
postionAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];

CAAnimationGroup *animationGroup = [CAAnimationGroup animation];
animationGroup.duration = kUpDuration;
animationGroup.removedOnCompletion = NO;
animationGroup.fillMode = kCAFillModeForwards;
animationGroup.delegate = self;
animationGroup.animations = @[rotationYAnimation, postionAnimation];

[_markView.layer addAnimation:animationGroup forKey:kJumpAnimation];
</code></pre>

<blockquote>
<p>CAAnimationGroup的animations中可以放其他任何动画类（包括CAAnimationGroup），需要注意的是animations里的动画设置了duration之后动画可能会有不同，一般里面不设置，在最外层设置group的duration即可。</p>
</blockquote>
<h5 id="AnimationWithKeyPath的值"><a href="#AnimationWithKeyPath的值" class="headerlink" title="AnimationWithKeyPath的值"></a>AnimationWithKeyPath的值</h5><p>最开始做动画一般都会对keyPath这个值莫名其妙，因为它不是常量，需要变换的时候找不到对应的需要设置的值，如果你在网上搜索，很可能看到的是这张图:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_20.png?raw=true" alt="animation"><br></div><br>下面这张图你基本上是找不到的，如下:<br><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_21.png?raw=true" alt="animation"><br></div>

<h4 id="4-CATransition"><a href="#4-CATransition" class="headerlink" title="4.CATransition"></a>4.CATransition</h4><p>CATransition一般来做转场动画。先上gif动画效果</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_22.gif?raw=true" alt="animation"><br></div>

<pre><code>
//修改视图的背景色
_someView.backgroundColor = [UIColor greenColor];
CATransition *animation = [CATransition animation];
animation.duration = 0.5;
/* 这里可设置的参数有：kCATransitionFade、kCATransitionPush、kCATransitionReveal、kCATransitionMoveIn、
"cube"、"suckEffect"、"oglFlip"、"rippleEffect"、"pageCurl"、"pageUnCurl"、"cameraIrisHollowOpen"、
 "cameraIrisHollowClose"，这些都是动画类型
*/
animation.type = @"cube";
// 动画执行的方向，kCATransitionFromRight、kCATransitionFromLeft、kCATransitionFromTop、kCATransitionFromBottom
animation.subtype = kCATransitionFromRight;
animation.timingFunction = UIViewAnimationOptionCurveEaseInOut;
[_someView.layer addAnimation:animation forKey:nil];
//也可以写这里
//    _someView.backgroundColor = [UIColor greenColor];
</code></pre>

<p>只需要在动画开始前或者动画开始后替换掉视图上显示的内容即可。具体可以看我的这篇博客<a href="http://www.guiyongdong.com/2016/09/22/iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCATransition%E5%8A%A8%E7%94%BB/">iOS动画之CATransition动画</a></p>
<h4 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h4><p>附加的内容是关于CALayer和UIBezierPath。个人觉得理解了UIBezierPath和CALayer,才能更好的理解CoreAnimation动画。</p>
<h5 id="1-UIBezierPath"><a href="#1-UIBezierPath" class="headerlink" title="1.UIBezierPath"></a>1.UIBezierPath</h5><p>UIBezierPath主要是用来绘制路径的，分为一阶、二阶…..n阶。一阶是直线，二阶以上才是曲线。而最终路径的显示还是得依靠CALayer。用CoreGraphics将路径绘制出来，最终也是绘制到CALayer上。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_23.png?raw=true" alt="animation"><br></div>

<blockquote>
<p>方法一：构造bezierPath对象，一般用于自定义路径。<br>方法二：绘制圆弧路径，参数1是中心点位置，参数2是半径，参数3是开始的弧度值，参数4是结束的弧度值，参数5是是否顺时针(YES是顺时针方向，NO逆时针)。<br>方法三：根据某个路径绘制路径。<br>方法四：根据某个CGRect绘制内切圆或椭圆（CGRect是正方形即为圆，为长方形则为椭圆）。<br>方法五：根据某个CGRect绘制路径。<br>方法六：绘制带圆角的矩形路径，参数2哪个角，参数3，横、纵向半径。<br>方法七：绘制每个角都是圆角的矩形，参数2是半径。</p>
</blockquote>
<p>自定义路径时常用的API:</p>
<pre><code>
- (void)moveToPoint:(CGPoint)point; // 移到某个点
- (void)addLineToPoint:(CGPoint)point; // 绘制直线
- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2; //绘制贝塞尔曲线
- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint; // 绘制规则的贝塞尔曲线
- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise
// 绘制圆形曲线
- (void)appendPath:(UIBezierPath *)bezierPath; // 拼接曲线
</code></pre>

<h5 id="如果将路径显示的图案显示到视图上呢？"><a href="#如果将路径显示的图案显示到视图上呢？" class="headerlink" title="如果将路径显示的图案显示到视图上呢？"></a>如果将路径显示的图案显示到视图上呢？</h5><p>有三种方式：1、直接使用UIBezierPath的方法；2、使用CoreGraphics绘制；3、利用CAShapeLayer绘制。<br>示例代码如下，绘制一个右侧为弧型的视图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_24.gif?raw=true" alt="animation"><br></div>

<pre><code>
- (void)drawRect:(CGRect)rect
{
    UIColor *fillColor = [UIColor colorWithRed:0.0 green:0.722 blue:1.0 alpha:1.0];

    UIBezierPath *bezierPath = [UIBezierPath bezierPath];
    [bezierPath moveToPoint:CGPointMake(0, 0)];
    [bezierPath addLineToPoint:CGPointMake(rect.size.width - spaceWidth, 0)];
    [bezierPath addQuadCurveToPoint:CGPointMake(rect.size.width - spaceWidth, rect.size.height) controlPoint:CGPointMake(rect.size.width - spaceWidth + _deltaWith, rect.size.height * 0.5)];
    [bezierPath addLineToPoint:CGPointMake(0, rect.size.height)];
    [bezierPath addLineToPoint:CGPointMake(0, 0)];
    [bezierPath closePath];

    // 1、bezierPath方法
//    [fillColor setFill];
//    [bezierPath fill];

    // 2、使用CoreGraphics
//    CGContextRef ctx = UIGraphicsGetCurrentContext();
//    CGContextAddPath(ctx, bezierPath.CGPath);
//    CGContextSetFillColorWithColor(ctx, fillColor.CGColor);
//    CGContextFillPath(ctx);

    // 3.CAShaperLayer
    [self.layer.sublayers makeObjectsPerformSelector:@selector(removeFromSuperlayer)];
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    shapeLayer.path = bezierPath.CGPath;
    shapeLayer.fillColor = fillColor.CGColor;
    [self.layer addSublayer:shapeLayer];
}
</code></pre>

<p><div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_25.gif?raw=true" alt="animation"><br></div><br>上图这样的视图是用UIBezierPath用多个CAShapeLayer制作出来的，而动画效果只需要改变进度的layer的strokeEnd和修改下面代表水面进度的视图位置即可。动画的组合也可以有多种方式组合<br>动画的示例代码：</p>
<pre><code>
- (void)setProgress:(CGFloat)progress animated:(BOOL)animated duration:(NSTimeInterval)duration
{
    CGFloat tempPro = progress;
    if (tempPro > 1.0) {
        tempPro = 1.0;
    } else if (progress < 0.0){
        tempPro = 0.0;
    }
    _progress = tempPro;

    CABasicAnimation *pathAniamtion = [CABasicAnimation animationWithKeyPath:@"strokeEnd"];
    pathAniamtion.duration = duration;
    pathAniamtion.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
    pathAniamtion.fromValue = [NSNumber numberWithFloat:0.0f];
    pathAniamtion.toValue = [NSNumber numberWithFloat:_progress];
    pathAniamtion.autoreverses = NO;
    [_progressLayer addAnimation:pathAniamtion forKey:nil];

    // 水位上升的动画
    if (!_showSolidAnimation) {
        return;
    }

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        _imageView.transform = CGAffineTransformIdentity;
        [UIView animateWithDuration:duration animations:^{
            CGRect rect = _imageView.frame;
            CGFloat dy = rect.size.height * progress;
            _imageView.transform = CGAffineTransformMakeTranslation(0, -dy);
        }];
    });
}
</code></pre>

<p>在用自定义的CAShapeLayer做动画时，建议在动画开始前先将动画属性与最终的属性值一致，再开始动画，不要使用removedOnCompletion控制最终的状态，这在WWDC苹果这么建议。</p>
<p><strong>具体UIBezierPath可以看这篇文章<a href="http://www.guiyongdong.com/2016/09/22/UIBezierPath%E8%AF%A6%E8%A7%A3/">UIBezierPath详解</a></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;App如果想被大众喜欢，漂亮的UI和精美的动画都是必不可少的，苹果虽然为UIView提供了一些常用动画，但是大部分看起来比较不错的效果都是通过操作Layer层实现的，因此了解核心动画是必要的.CoreAnimation是直接作用在CALayer上的(并非UIView上)非常强大的跨Mac OS X和iOS平台的动画处理API，Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。&lt;br&gt;
    
    </summary>
    
      <category term="动画" scheme="http://www.guiyongdong.com/categories/%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="动画" scheme="http://www.guiyongdong.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS动画篇之UIView动画</title>
    <link href="http://www.guiyongdong.com/2016/09/21/iOS%E5%8A%A8%E7%94%BB%E7%AF%87-transfrom/"/>
    <id>http://www.guiyongdong.com/2016/09/21/iOS动画篇-transfrom/</id>
    <published>2016-09-21T03:38:37.000Z</published>
    <updated>2016-09-25T01:23:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持。<br><a id="more"></a></p>
<h4 id="UIViewAnimationOptions参考"><a href="#UIViewAnimationOptions参考" class="headerlink" title="UIViewAnimationOptions参考"></a>UIViewAnimationOptions参考</h4><pre><code>
1.基本类型
UIViewAnimationOptionLayoutSubviews：动画过程中保证子视图跟随运动。
UIViewAnimationOptionAllowUserInteraction：动画过程中允许用户交互。
UIViewAnimationOptionBeginFromCurrentState：所有视图从当前状态开始运行。
UIViewAnimationOptionRepeat：重复运行动画。
UIViewAnimationOptionAutoreverse ：动画运行到结束点后仍然以动画方式回到初始点。
UIViewAnimationOptionOverrideInheritedDuration：忽略嵌套动画时间设置。
UIViewAnimationOptionOverrideInheritedCurve：忽略嵌套动画速度设置。
UIViewAnimationOptionAllowAnimatedContent：动画过程中重绘视图（注意仅仅适用于转场动画）。  
UIViewAnimationOptionShowHideTransitionViews：视图切换时直接隐藏旧视图、显示新视图，而不是将旧视图从父视图移除（仅仅适用于转场动画）
UIViewAnimationOptionOverrideInheritedOptions ：不继承父动画设置或动画类型。

2.动画速度控制（可从其中选择一个设置）
UIViewAnimationOptionCurveEaseInOut：动画先缓慢，然后逐渐加速。
UIViewAnimationOptionCurveEaseIn ：动画逐渐变慢。
UIViewAnimationOptionCurveEaseOut：动画逐渐加速。
UIViewAnimationOptionCurveLinear ：动画匀速执行，默认值。

3.转场类型（仅适用于转场动画设置，可以从中选择一个进行设置，基本动画、关键帧动画不需要设置）
UIViewAnimationOptionTransitionNone：没有转场动画效果。
UIViewAnimationOptionTransitionFlipFromLeft ：从左侧翻转效果。
UIViewAnimationOptionTransitionFlipFromRight：从右侧翻转效果。
UIViewAnimationOptionTransitionCurlUp：向后翻页的动画过渡效果。    
UIViewAnimationOptionTransitionCurlDown ：向前翻页的动画过渡效果。    
UIViewAnimationOptionTransitionCrossDissolve：旧视图溶解消失显示下一个新视图的效果。    
UIViewAnimationOptionTransitionFlipFromTop ：从上方翻转效果。    
UIViewAnimationOptionTransitionFlipFromBottom：从底部翻转效果。
</code></pre>


<h3 id="1-基本动画"><a href="#1-基本动画" class="headerlink" title="1. 基本动画"></a>1. 基本动画</h3><p><code>+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<pre><code>
duration   :   持续时间  
delay      :   延迟执行  
options    :   动画选项(往复、循环等)  
animations :   动画block  
completion :   完成后的block 
</code></pre>

<ul>
<li><strong>可实现动画的属性</strong></li>
</ul>
<pre><code>
坐标尺寸类: bounds、frame、center  
视图显示类: backgroundColor、alpha、hidden  
形态变化类: transform
</code></pre>

<h3 id="2-弹簧动画"><a href="#2-弹簧动画" class="headerlink" title="2.弹簧动画"></a>2.弹簧动画</h3><p><code>+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">usingSpringWithDamping   :   0.0 ~ 1.0 阻尼比例，数值越小「弹簧」的振动效果越明显</div><div class="line">initialSpringVelocity    :   初始的速度，数值越大一开始移动越快</div></pre></td></tr></table></figure>
<h3 id="3-过渡动画"><a href="#3-过渡动画" class="headerlink" title="3.过渡动画"></a>3.过渡动画</h3><p><code>+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<pre><code>
view       :   需要进行转场动画的视图
options    :   转场动画的类型
</code></pre>

<p><code>+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<pre><code>
方法调用完毕后，相当于执行了下面两句代码：
// 添加toView到父视图
[fromView.superview addSubview:toView];
// 把fromView从父视图中移除
[fromView removeFromSuperview];
</code></pre>

<h3 id="4-keyframe动画"><a href="#4-keyframe动画" class="headerlink" title="4. keyframe动画"></a>4. keyframe动画</h3><p><code>+ (void)animateKeyframesWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewKeyframeAnimationOptions)options animations:(void (^)(void))animations completion:(void (^ __nullable)(BOOL finished))completion</code></p>
<p><code>+ (void)addKeyframeWithRelativeStartTime:(double)frameStartTime relativeDuration:(double)frameDuration animations:(void (^)(void))animations</code></p>
<ul>
<li><strong>参数详情:</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RelativeStartTime : 关键帧动画开始时间的比例值</div><div class="line">RelativeDuration  : 关键帧动画持续实践的比例值</div></pre></td></tr></table></figure>
<ul>
<li><strong>用法示例:</strong></li>
</ul>
<pre><code>
[UIView animateKeyframesWithDuration:8 delay:0 options:UIViewKeyframeAnimationOptionCalculationModeLinear animations:^{
        [UIView addKeyframeWithRelativeStartTime:0 relativeDuration:0.25 animations:^{
            self.imgV.center = (CGPoint){center.x + 200 ,center.y + 150};
        }];
        [UIView addKeyframeWithRelativeStartTime:0.25 relativeDuration:0.25 animations:^{
            self.imgV.center = (CGPoint){center.x ,center.y + 300};
        }];
        [UIView addKeyframeWithRelativeStartTime:0.5 relativeDuration:0.25 animations:^{
            self.imgV.center = (CGPoint){center.x + 200,center.y + 450};
        }];
        [UIView addKeyframeWithRelativeStartTime:0.75 relativeDuration:0.25 animations:^{
            self.imgV.center = (CGPoint){center.x + 0,center.y + 600 };
        }];
    } completion:nil];
</code></pre>

<h3 id="5-transform变换"><a href="#5-transform变换" class="headerlink" title="5. transform变换"></a>5. transform变换</h3><p><code>CGAffineTransform</code></p>
<ul>
<li><strong>变换原理</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct CGAffineTransform &#123;</div><div class="line">   CGFloat a;</div><div class="line">   CGFloat b;</div><div class="line">   CGFloat c;</div><div class="line">   CGFloat d;</div><div class="line">   CGFloat tx;</div><div class="line">   CGFloat ty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>结构体矩阵图为：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_26.gif?raw=true" alt="矩阵图"><br></div>

<p>因为最后一列总是是(0,0,1)，所以有用的信息就是前面两列<br>对一个view进行仿射变化就相当于对view上的每个点做一个乘法<br>结果就是：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Animation/Animation_27.gif?raw=true" alt="映射变换"><br></div>

<p><strong>相当于：</strong><br>(x, y, 1 ) –&gt; (ax + cy + tx, bx + dy + ty, 1) </p>
<p>如果不看c和b的话<br>a表示x水平方向的缩放，tx表示x水平方向的偏移<br>d表示y垂直方向的缩放，ty表示y垂直方向的偏移<br>如果b和c不为零的话，那么视图肯定发生了旋转</p>
<p><strong>常量</strong><br>CGAffineTransformIdentity<br>CGAffineTransform<br>CGAffineTransformIdentity;<br>这个就是没有变化的最初的样子 </p>
<ul>
<li><strong>常用函数</strong></li>
</ul>
<pre><code>
/// 用来连接两个变换效果并返回。返回的t = t1 * t2
CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2)

/// 矩阵初始值。[ 1 0 0 1 0 0 ]
CGAffineTransformIdentity

/// 自定义矩阵变换，需要掌握矩阵变换的知识才知道怎么用。参照(x, y, 1 ) --> (ax + cy + tx, bx + dy + ty, 1)  
CGAffineTransformMake(CGFloat a, CGFloat b, CGFloat c, CGFloat d, CGFloat tx, CGFloat ty)

/// 旋转视图。传入参数为 角度 * (M_PI / 180)。等同于 CGAffineTransformRotate(self.transform, angle)
CGAffineTransformMakeRotation(CGFloat angle)
CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)

/// 缩放视图。等同于CGAffineTransformScale(self.transform, sx, sy)
CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)
CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)

/// 缩放视图。等同于CGAffineTransformTranslate(self.transform, tx, ty)
CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)
CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)
</code></pre>

<ul>
<li><strong>常用函数</strong></li>
</ul>
<pre><code>
- (void)viewDidAppear:(BOOL)animated {
    CGFloat offset = self.label1.frame.size.height * 0.5;

    self.label1.transform = CGAffineTransformConcat(
                                                    CGAffineTransformMakeScale(1, 0),
                                                    CGAffineTransformMakeTranslation(0, -offset));

    self.label1.alpha = 0;
    [UIView animateWithDuration:3.0 animations:^{
        self.label1.transform = CGAffineTransformIdentity;
        self.label1.alpha = 1;

        self.label2.transform = CGAffineTransformConcat(
                                                        CGAffineTransformMakeScale(1, 0.1),
                                                        CGAffineTransformMakeTranslation(0, offset));
        self.label2.alpha = 0;
    }];
}
</code></pre>


<h3 id="6-UIView动画（首尾方式）"><a href="#6-UIView动画（首尾方式）" class="headerlink" title="6.UIView动画（首尾方式）"></a>6.UIView动画（首尾方式）</h3><p>UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持<br>执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]之间</p>
<p>常见方法解析:<br>　　<strong>+ (void)setAnimationDelegate:(id)delegate</strong>     设置动画代理对象，当动画开始或者结束时会发消息给代理对象<br>　　<strong>+ (void)setAnimationWillStartSelector:(SEL)selector</strong>   当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector<br>　　<strong>+ (void)setAnimationDidStopSelector:(SEL)selector</strong>  当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector<br>　　<strong>+ (void)setAnimationDuration:(NSTimeInterval)duration</strong>   动画的持续时间，秒为单位<br>　　<strong>+ (void)setAnimationDelay:(NSTimeInterval)delay</strong>  动画延迟delay秒后再开始<br>　　<strong>+ (void)setAnimationStartDate:(NSDate *)startDate</strong>   动画的开始时间，默认为now<br>　　<strong>+ (void)setAnimationCurve:(UIViewAnimationCurve)curve</strong>  动画的节奏控制<br>　　<strong>+ (void)setAnimationRepeatCount:(float)repeatCount</strong>  动画的重复次数<br>　　<strong>+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses</strong>  如果设置为YES,代表动画每次重复执行的效果会跟上一次相反<br>　　<strong>+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache</strong>  设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</p>
<p><strong>代码示例: </strong></p>
<pre><code>
@interface ViewController ()
@property (weak, nonatomic) IBOutlet UIView *customView;


@end

@implementation YYViewController

- (void)viewDidLoad
{
     [super viewDidLoad];

}

-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
     //打印动画块的位置
     NSLog(@"动画执行之前的位置：%@",NSStringFromCGPoint(self.customView.center));

     //首尾式动画
     [UIView beginAnimations:nil context:nil];
     //执行动画
     //设置动画执行时间
     [UIView setAnimationDuration:2.0];
     //设置代理
     [UIView setAnimationDelegate:self];
     //设置动画执行完毕调用的事件
     [UIView setAnimationDidStopSelector:@selector(didStopAnimation)];
     self.customView.center=CGPointMake(200, 300);
     [UIView commitAnimations];

}

-(void)didStopAnimation
{
     NSLog(@"动画执行完毕");
     //打印动画块的位置
     NSLog(@"动画执行之后的位置：%@",NSStringFromCGPoint(self.customView.center));
}
@end
</code></pre>

<p><strong>说明:</strong><br>　　使用UIView和CALayer都能实现动画效果，但是在真实的开发中，一般还是主要使用UIView封装的动画，而很少使用CALayer的动画。</p>
<p>CALayer核心动画与UIView动画的区别：<br>　　<strong>UIView封装的动画执行完毕之后不会反弹。即如果是通过CALayer核心动画改变layer的位置状态，表面上看虽然已经改变了，但是实际上它的位置是没有改变的。</strong></p>
<h3 id="7-补充"><a href="#7-补充" class="headerlink" title="7.补充"></a>7.补充</h3><h5 id="UIImageView的帧动画"><a href="#UIImageView的帧动画" class="headerlink" title="UIImageView的帧动画"></a>UIImageView的帧动画</h5><p>UIImageView可以让一系列的图片在特定的时间内按顺序显示</p>
<p>相关属性解析:<br>　　<strong>animationImages</strong>：要显示的图片(一个装着UIImage的NSArray)<br>　　<strong>animationDuration</strong>：完整地显示一次animationImages中的所有图片所需的时间<br>　　<strong>animationRepeatCount</strong>：动画的执行次数(默认为0，代表无限循环)</p>
<p>相关方法解析:<br>　　<strong>- (void)startAnimating</strong>; 开始动画<br>　　<strong>- (void)stopAnimating</strong>;  停止动画<br>　　<strong>- (BOOL)isAnimating</strong>;  是否正在运行动画</p>
<h5 id="UIActivityIndicatorView"><a href="#UIActivityIndicatorView" class="headerlink" title="UIActivityIndicatorView"></a>UIActivityIndicatorView</h5><p>是一个旋转进度轮，可以用来告知用户有一个操作正在进行中，一般用initWithActivityIndicatorStyle初始化</p>
<p>相关方法解析:<br>　　<strong>- (void)startAnimating</strong>; 开始动画<br>　　<strong>- (void)stopAnimating</strong>;  停止动画<br>　　<strong>- (BOOL)isAnimating</strong>;  是否正在运行动画</p>
<p>UIActivityIndicatorViewStyle有3个值可供选择：<br>　　<strong>UIActivityIndicatorViewStyleWhiteLarge</strong>   //大型白色指示器<br>　　<strong>UIActivityIndicatorViewStyleWhite</strong>      //标准尺寸白色指示器<br>　　<strong>UIActivityIndicatorViewStyleGray</strong>    //灰色指示器，用于白色背景</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持。&lt;br&gt;
    
    </summary>
    
      <category term="动画" scheme="http://www.guiyongdong.com/categories/%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="动画" scheme="http://www.guiyongdong.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊NSOperation的那些事</title>
    <link href="http://www.guiyongdong.com/2016/09/18/%E8%81%8A%E4%B8%80%E8%81%8ANSOperation%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://www.guiyongdong.com/2016/09/18/聊一聊NSOperation的那些事/</id>
    <published>2016-09-18T08:23:05.000Z</published>
    <updated>2016-09-18T09:06:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中，多线程技术用到最多的就是GCD和NSOperation，上一篇文章已经对GCD有了全面的了解，这篇文章简单的聊一聊NSOperation。<br><a id="more"></a></p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><ul>
<li>除了，NSThread和GCD实现多线程，配合使用NSOperation和NSOperationQueue也能实现多线程编程</li>
</ul>
<blockquote>
<p>NSOperation和NSOperationQueue<code>实现多线程的具体步骤</code></p>
</blockquote>
<ul>
<li>1、先将需要执行的操作封装到一个NSOperation的子类对象中<ul>
<li>实际上，NSOperation是个抽象类,并不具备封装操作的能力，必须使用它的子类</li>
</ul>
</li>
<li>2、然后将NSOperation对象添加到NSOperationQueue中</li>
<li>3、系统会自动将NSOperationQueue中的NSOperation取出来</li>
<li>4、将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
<h3 id="二、NSOperation"><a href="#二、NSOperation" class="headerlink" title="二、NSOperation"></a>二、NSOperation</h3><ul>
<li>如上所示：要实现多线程，必须要将执行的操作封装到NSOperation的子类对象中，那么NSOperation的子类有哪些？</li>
</ul>
<p><strong>1、使用NSOperation子类的方式有3种</strong></p>
<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义子类继承NSOperation，实现内部相应main的方法封装操作</li>
</ul>
<blockquote>
<p>1.1 NSInvocationOperation</p>
</blockquote>
<ul>
<li><p>创建NSInvocationOperation对象<br><code>-(id)initWithTarget:(id)target selector:(SEL)selector object:(id)arg;</code></p>
</li>
<li><p>调用start方法开始执行操作</p>
<ul>
<li>默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作<pre><code>// 一旦执行操作，就会调用target的selector方法
-(void)start;
</code></pre></li>
<li>只有将NSOperation操作任务放到一个NSOperationQueue中，才会异步执行操作</li>
</ul>
</li>
<li><p>使用</p>
<pre><code>- (void)invocation
{    
  // 1.将操作封装到Operation中
  NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil];
  // 2.执行封装的操作
  // 如果直接执行NSInvocationOperation中的操作, 那么默认会在主线程中执行
  [op1 start];

  NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];
  [op2 start];
}
</code></pre>

</li>
</ul>
<blockquote>
<p>1.2 NSBlockOperation</p>
</blockquote>
<ul>
<li>注意点：<code>只要NSBlockOperation封装的操作数 &gt;1，就会异步执行操作</code></li>
<li>创建NSBlockOperation对象<pre><code>+(id)blockOperationWithBlock:(void(^)(void))block;</code></pre></li>
<li>通过addExecutionBlock:方法添加更多的操作<pre><code>-(void)addExecutionBlock:(void(^)(void))block;</code></pre></li>
<li><p>使用</p>
<pre><code>- (void)blockOperation
{
  // 1.封装操作
  NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
      NSLog(@"1- %@", [NSThread currentThread]);
  }];

  // 2.添加操作
  [op1 addExecutionBlock:^{
      NSLog(@"2- %@", [NSThread currentThread]);
  }];
  [op1 addExecutionBlock:^{
      NSLog(@"3- %@", [NSThread currentThread]);
  }];

  // 2.执行操作
  // 如果只封装了一个操作, 那么默认会在主线程中执行
  // 如果封装了多个操作, 那么除了第一个操作以外, 其它的操作会在子线程中执行
  [op1 start];
}</code></pre>

</li>
</ul>
<blockquote>
<p>1.3 自定义 NSOperation，继承NSOperation</p>
</blockquote>
<ul>
<li>如果是自定义类继承于NSOperation, 那么需要将操作写到自定义类的main方法中，重写main方法<ul>
<li>重写-(void)main方法的注意点<ul>
<li>自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）</li>
<li>经常通过-(BOOL)isCancelled方法检测操作是否被取消，对取消做出响应</li>
</ul>
</li>
</ul>
</li>
<li>这种实现方式封装操作, 可以提高代码的复用性</li>
<li>1.创建类JPOperation，继承NSOperation</li>
</ul>
<pre><code>#import <foundation foundation.h="">
@interface JPOperation : NSOperation

@end

#import "JPOperation.h"

@implementation JPOperation

// 我们要重写main方法，封装操作
- (void)main
{
    NSLog(@"%s, %@", __func__,[NSThread currentThread]);
}
@end
</foundation></code></pre>

<ul>
<li>2.使用自定义的NSOperation</li>
</ul>
<pre><code>// 1.封装操作
JPOperation *op1 = [[JPOperation alloc] init];
// 2.执行操作
[op1 start];

JPOperation *op2 = [[JPOperation alloc] init];
[op2 start];
</code></pre>


<h3 id="三、NSOperationQueue"><a href="#三、NSOperationQueue" class="headerlink" title="三、NSOperationQueue"></a>三、NSOperationQueue</h3><ul>
<li><code>NSOperationQueue的作用:</code><ul>
<li>如上所述：NSOperation可以调用start方法来执行任务，但默认是同步执行的</li>
<li>如果将NSOperation<code>添加到NSOperationQueue</code>（操作队列）中，<code>系统会自动异步执行NSOperation中的操作</code></li>
</ul>
</li>
<li>添加操作到NSOperationQueue：两个方法<ul>
<li>只要将一个任务添加到alloc/init的队列(默认并发，可以设置其为串行)中, 那么队列内部会自动调用start</li>
<li>如果想实现串行, 那么就设置队列的maxConcurrentOperationCount = 1</li>
</ul>
</li>
</ul>
<pre><code>-(void)addOperation:(NSOperation*)op;
-(void)addOperationWithBlock:(void(^)(void))block;
</code></pre>

<blockquote>
<p>基本使用</p>
</blockquote>
<ul>
<li>GCD队列:<ul>
<li>串行: 自己创建, 主队列</li>
<li>并发: 自己创建, 全局</li>
</ul>
</li>
<li>NSOperationQueue:<ul>
<li>自己创建: alloc/init –&gt; 默认是并发 –&gt; 也可以让它串行</li>
<li>主队列 : mainQueue</li>
</ul>
</li>
</ul>
<pre><code>#import "ViewController.h"
#import "JPOperation.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    // 2.封装任务
    JPOperation *op1 = [[JPOperation alloc] init];
    JPOperation *op2 = [[JPOperation alloc] init];

    // 3.将任务添加到队列中
    [queue addOperation:op1];
    [queue addOperation:op2];
}

- (void)block
{
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    // 2.将任务添加到队列中
    // addOperationWithBlock方法会做两件事情
    // 1.根据传入的block, 创建一个NSBlockOperation对象
    // 2.将内部创建好的NSBlockOperation对象, 添加到队列中
    [queue addOperationWithBlock:^{
        NSLog(@"1 = %@", [NSThread currentThread]);
    }];
    [queue addOperationWithBlock:^{
        NSLog(@"2 = %@", [NSThread currentThread]);
    }];
}

- (void)invation
{
    /*
     GCD队列:
     串行: 自己创建, 主队列
     并发: 自己创建, 全局

     NSOperationQueue:
     自己创建: alloc/init --> 默认是并发 --> 也可以让它串行
     主队列  : mainQueue
     */
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    //    NSOperationQueue *queue = [NSOperationQueue mainQueue];

    // 2.封装任务
    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(demo) object:nil];
    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];

    // 3.将任务添加到队列中
    // 只要将一个任务添加到alloc/init的队列中, 那么队列内部会自动调用start
    // 只要将一个任务添加到alloc/init的队列中, 就会开启一个新的线程执行队列
    [queue addOperation:op1];
    [queue addOperation:op2];
}

- (void)demo
{
    NSLog(@"demo = %@", [NSThread currentThread]);
}
- (void)test
{
    NSLog(@"test = %@", [NSThread currentThread]);
}
@end
</code></pre>


<h3 id="四、NSOperatinoQueue的串行和并发-：-最大并发数"><a href="#四、NSOperatinoQueue的串行和并发-：-最大并发数" class="headerlink" title="四、NSOperatinoQueue的串行和并发 ： 最大并发数"></a>四、NSOperatinoQueue的串行和并发 ： 最大并发数</h3><ul>
<li>队列的maxConcurrentOperationCount最大并发数</li>
<li>maxConcurrentOperationCount 默认等于 -1, 代表不限制, 可以创建N多线程</li>
<li>alloc/init的NSOperatinoQueue队列默认就是并发， 如果想实现串行, 那么就设置maxConcurrentOperationCount = 1</li>
<li>注意: 最大并发数, 不能设置为0, 否则任务不会被执行 </li>
</ul>
<pre><code>#import "ViewController.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // 1.创建队列
    NSOperationQueue *queue = [[NSOperationQueue alloc] init
                               ];
    // maxConcurrentOperationCount 默认等于 -1, 代表不限制, 可以创建N多线程
    // 默认就是并发
    // 如果想实现串行, 那么就设置maxConcurrentOperationCount = 1
    // 注意: 最大并发数, 不能设置为0, 否则任务不会被执行 \
    如果想再主线程中执行任务, 那么直接创建mainQueu即可
//    queue.maxConcurrentOperationCount = 1;

    // 2.创建任务
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"1 = %@", [NSThread currentThread]);
    }];
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"2 = %@", [NSThread currentThread]);
    }];
    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"3 = %@", [NSThread currentThread]);
    }];

    // 3.将任务添加到队列中
    [queue addOperation:op1];
    [queue addOperation:op2];
    [queue addOperation:op3];   
}
@end
</code></pre>

<h3 id="五、NSOperationQueue的暂停-恢复-取消"><a href="#五、NSOperationQueue的暂停-恢复-取消" class="headerlink" title="五、NSOperationQueue的暂停-恢复-取消"></a>五、NSOperationQueue的暂停-恢复-取消</h3><blockquote>
<p>1、取消队列的所有操作</p>
</blockquote>
<ul>
<li>也可以调用NSOperation的-(void)cancel方法取消单个操作</li>
<li>注意点：<ul>
<li>任务只要被取消, 就不会再恢复了</li>
<li>取消任务和暂停任务一样, 不会取消当前正在执行的任务, 只能取消还未执行的任务<pre><code>-(void)cancelAllOperations;
</code></pre>

</li>
</ul>
</li>
</ul>
<blockquote>
<p>2、暂停和恢复队列</p>
</blockquote>
<ul>
<li>注意:<ul>
<li>1.如果在任务执行的过程中暂停队列中的任务, 那么当前正在执行的任务并不会被暂停, 而是会暂停队列中的下一个任务</li>
<li>2.恢复任务, 是从队列第一个没有被执行过的任务开始恢复<pre><code>-(void)setSuspended:(BOOL)b;//如果是YES, 代表需要暂停，NO代表代表不需要暂停 ==  恢复执行
-(BOOL)isSuspended;
</code></pre>

</li>
</ul>
</li>
</ul>
<h3 id="六、NSOperationQueue线程间通信"><a href="#六、NSOperationQueue线程间通信" class="headerlink" title="六、NSOperationQueue线程间通信"></a>六、NSOperationQueue线程间通信</h3><blockquote>
<p>实例程序：开启子线程下载图片，下载好图片后，回到主线程进行更新UI</p>
</blockquote>
<pre><code>#import "ViewController.h"

@interface ViewController ()
@property (weak, nonatomic) IBOutlet UIImageView *imageView;

@end

@implementation ViewController

- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    // 1.开启子线程下载图片
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperationWithBlock:^{
     // 子线程
        NSString *urlStr = @"https://www.baidu.com/img/bd_logo1.png";
    // url中文编码，防止乱码
    // urlStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
        NSURL *url = [NSURL URLWithString:urlStr];
        NSData *data = [NSData dataWithContentsOfURL:url];
        // 2.生成下载好的图片
        UIImage *image = [UIImage imageWithData:data];

        // 3.回到主线程更新UI
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            NSLog(@"更新UI");
           // 主线程
            self.imageView.image = image;
        }];
    }];
}
@end
</code></pre>

<h3 id="七、操作依赖"><a href="#七、操作依赖" class="headerlink" title="七、操作依赖"></a>七、操作依赖</h3><ul>
<li>1、目的 -&gt; NSOperation之间可以设置依赖来保证执行顺序<ul>
<li>例如：一定要让操作A执行完后，才能执行操作B，可以这么写</li>
</ul>
</li>
<li>只要添加了依赖, 那么就会等依赖的任务执行完毕, 才会执行当前任务  <pre><code>[operationB addDependency:operationA];// 操作B依赖于操作A , A操作执行完才会执行操作B</code></pre></li>
<li>2、除了同一quere操作间建立依赖关系，当然也可以在不同queue的NSOperation之间创建依赖关系</li>
<li>注意点：<ul>
<li>不能相互依赖 -&gt; 比如A依赖B，B依赖A</li>
</ul>
</li>
</ul>
<blockquote>
<p>经典实例：合成图片</p>
</blockquote>
<pre><code>#import "ViewController.h"

@interface ViewController ()
@property (weak, nonatomic) IBOutlet UIImageView *imageView;

@end

@implementation ViewController
- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];

    __block UIImage *image1 = nil;
    __block UIImage *image2 = nil;
    // 1.开启一个线程下载第一张图片
    NSOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        NSURL *url = [NSURL URLWithString:@"http://cdn.cocimg.com/assets/images/logo.png?v=201510272"];
        NSData *data = [NSData dataWithContentsOfURL:url];
        // 2.生成下载好的图片
        UIImage *image = [UIImage imageWithData:data];
        image1 = image;
    }];

    // 2.开启一个线程下载第二长图片
    NSOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        NSURL *url = [NSURL URLWithString:@"https://www.baidu.com/img/bd_logo1.png"];
        NSData *data = [NSData dataWithContentsOfURL:url];
        // 2.生成下载好的图片
        UIImage *image = [UIImage imageWithData:data];
        image2 = image;

    }];
    // 3.开启一个线程合成图片
    NSOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{
        UIGraphicsBeginImageContext(CGSizeMake(200, 200));
        [image1 drawInRect:CGRectMake(0, 0, 100, 200)];
        [image2 drawInRect:CGRectMake(100, 0, 100, 200)];
        UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
        UIGraphicsEndImageContext();

        // 4.回到主线程更新UI
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            NSLog(@"回到主线程更新UI");
            self.imageView.image = newImage;
        }];
    }];


    // 监听任务是否执行完毕
    op1.completionBlock = ^{
        NSLog(@"第一张图片下载完毕");
    };
    op2.completionBlock = ^{
        NSLog(@"第二张图片下载完毕");
    };

    // 添加依赖
    // 只要添加了依赖, 那么就会等依赖的任务执行完毕, 才会执行当前任务
    // 注意:
    // 1.添加依赖, 不能添加循环依赖
    // 2.NSOperation可以跨队列添加依赖
    [op3 addDependency:op1];
    [op3 addDependency:op2];

    // 将任务添加到队列中
    [queue addOperation:op1];
    [queue addOperation:op2];
    [queue2 addOperation:op3];
}
@end</code></pre>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，多线程技术用到最多的就是GCD和NSOperation，上一篇文章已经对GCD有了全面的了解，这篇文章简单的聊一聊NSOperation。&lt;br&gt;
    
    </summary>
    
      <category term="NSOperation" scheme="http://www.guiyongdong.com/categories/NSOperation/"/>
    
    
      <category term="NSOperation" scheme="http://www.guiyongdong.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊GCD的那些事</title>
    <link href="http://www.guiyongdong.com/2016/09/13/%E8%81%8A%E4%B8%80%E8%81%8AGCD%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/</id>
    <published>2016-09-13T08:56:07.000Z</published>
    <updated>2016-09-14T08:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。</p>
<a id="more"></a>
<p><strong>目录</strong></p>
<blockquote>
<ol>
<li>文字描述</li>
<li>Dispatch Queue</li>
<li>dispatch_sync&amp;dispatch_async</li>
<li>创建的线程任务有四种执行方式</li>
<li>Dispatch Group</li>
<li>Dispatch Block</li>
<li>dispatch_after</li>
<li>dispatch_apply</li>
<li>dispatch_once</li>
<li>dispatch_barrier_async</li>
<li>dispatch_set_target_queue</li>
<li>dispatch_semaphore_t(信号量)</li>
<li>GCD定时器</li>
</ol>
</blockquote>
<h3 id="1-文字描述"><a href="#1-文字描述" class="headerlink" title="1. 文字描述"></a>1. 文字描述</h3><blockquote>
<p>GCD英文全称：Grand Central Dispatch 翻译就是 宏大的中央调度，是苹果开发的一种支持并行操作的机制,基于C语言，提供了非常多强大的函数</p>
</blockquote>
<p>在了解GCD并使用之前，必须要掌握四个名词：<strong>串行</strong>，<strong>并发</strong>，<strong>同步</strong>，<strong>异步</strong></p>
<p><strong>串行(Serial)：</strong><br>一个任务执行完, 再执行下一个任务</p>
<p><strong>并发 (Concurrent)：</strong><br>多个任务同时执行(自动开启多个线程),只有在异步函数下才有效</p>
<p><strong>同步(Synchronous)：</strong><br>在当前线程中执行任务，不具备开启新线程的能力<br>提交的任务在执行完成后才会返回<br>同步函数: dispatch_sync()</p>
<p><strong>异步 (Asynchronous)：</strong><br>在新的线程中执行任务, 具备开启线程的能力<br>在新线程中执行任务，具备开启新线程的能力<br>提交的任务立刻返回，在后台队列中执行<br>异步函数: dispatch_async()</p>
<hr>
<h3 id="2-Dispatch-Queue"><a href="#2-Dispatch-Queue" class="headerlink" title="2.Dispatch Queue"></a>2.Dispatch Queue</h3><p>Dispatch Queue是执行处理的等待队列, 按照先进先出(FIFO, First-In-First-Out)的顺序进行任务处理.<br>开发者将需要执行的任务添加到合适的Dispatch Queue中即可，Dispatch Queue会根据任务添加的顺序先到先执行，其中有以下几种队列：</p>
<p>另外, 队列分两种, 一种是<strong>串行队列(Serial Dispatch Queue)</strong>, 一种是<strong>并行队列(Concurrent Dispatch Queue)</strong>.</p>
<table>
<thead>
<tr>
<th>Dispatch Queue的种类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial Dispatch Queue</td>
<td style="text-align:center">等待现在执行中处理结束</td>
</tr>
<tr>
<td>Concurrent Dispatch Queue</td>
<td style="text-align:center">不等待现在执行中处理结束</td>
</tr>
</tbody>
</table>
<pre><code>
//创建一个串行队列
dispatch_queue_t serialQueue=dispatch_queue_create("com.serial.queue", DISPATCH_QUEUE_SERIAL);

//创建一个并发队列
dispatch_queue_t concurrentQueue=dispatch_queue_create("com.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);

//第一个参数为队列名，第二个参数为队列类型，当然，第二个参数人如果写NULL，创建出来的也是一个串行队列。然后我们在异步线程来执行这个队列：
</code></pre>

<p>另外系统为我们准备了两个队列</p>
<ul>
<li><p><strong>main dispatch queue</strong><br>功能跟主线程一样，通过dispatch_get_main_queue()来获取，提交到main queue的任务实际上都是在主线程执行的，所以这是一个串行队列<br><code>dispatch_queue_t queue = dispatch_get_main_queue();</code></p>
</li>
<li><p><strong>global dispatch queues</strong><br>系统给每个应用提供四个全局的并发队列，这四个队列分别有不同的优先级：高、默认、低以及后台，用户不能去创建全局队列，只能根据优先级去获取:</p>
<pre><code>dispatch_queue_t queue  = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</code></pre>    



</li>
</ul>
<hr>
<h3 id="3-dispatch-sync-amp-dispatch-async"><a href="#3-dispatch-sync-amp-dispatch-async" class="headerlink" title="3.dispatch_sync&amp;dispatch_async"></a>3.dispatch_sync&amp;dispatch_async</h3><p>执行队列中任务的两种方式，dispatch_sync是同步任务，dispatch_async是异步任务</p>
<p>1.<strong>用同步的方式执行任务(同步：synchronization)</strong>， 只能在当前线程中执行任务，不具备开启新线程的能力</p>
<pre><code>/*
 *  第一个参数：该任务所在的队列
 *  第二个参数：该任务要做的事情
 */
dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code></pre>

<ul>
<li><p>假如我指定的队列A是串行队列，则该队列中只能有一个线程，也就是说我放在队列A中的任务，所以必须得一个一个的执行。不仅如此，在上面我们还手动选择了在队列A中用同步的方式执行任务，这也限制了，队列中的任务只能一个一个执行。</p>
</li>
<li><p>假如我指定的队列A是并行队列，则该队列中可以开辟多个线程去执行任务，虽然如此，但由于我们在上面手动选择了在队列A中用同步的方式执行线程，所以队列A中的任务也只能一个一个去执行，<strong>不能开辟多线程同时执行</strong>。</p>
</li>
</ul>
<p>2.用异步的方式执行任务(异步：asynchronous)，可以在新的线程中执行任务，具备开启新线程的能力。</p>
<pre><code>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code></pre>

<ul>
<li>假如此时我指定的队列B是并行队列，则表明该队列中可以存在多个线程，又因为我们采用的是异步的方式执行任务，所以在这个队列的任务可以实现同时运行。</li>
<li>假如此时我指定的队列B是串行队列，则表明该队列中，只能有一个线程，所以尽管我采用异步的方式执行任务，但该队列中的任务还是只能一个一个的运行。</li>
</ul>
<hr>
<h3 id="4-创建的线程任务有四种执行方式"><a href="#4-创建的线程任务有四种执行方式" class="headerlink" title="4.创建的线程任务有四种执行方式"></a>4.创建的线程任务有四种执行方式</h3><p><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/GCD1.png?raw=true" alt=""></p>
<h5 id="1-串行队列同步执行任务"><a href="#1-串行队列同步执行任务" class="headerlink" title="1. 串行队列同步执行任务"></a>1. 串行队列同步执行任务</h5><ul>
<li>同步不具有开辟新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程中执行任务。</li>
<li>按照串行的方式去执行任务</li>
</ul>
<pre><code>-(void)syncSERIAL{
    NSLog(@"star");
    //不会开辟新的线程
    dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_sync(queue, ^{
        NSLog(@"SERIAL_work_1 ");
    });
    dispatch_sync(queue, ^{
        NSLog(@"SERIAL_work_2 ");
    });
    dispatch_sync(queue, ^{
        NSLog(@"SERIAL_work_3 ");
    });

    NSLog(@"end");

}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:08:09.695 GCD_Demo[8196:1029563] star
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] SERIAL_work_1 
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] SERIAL_work_2 
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] SERIAL_work_3 
2016-07-20 20:08:09.696 GCD_Demo[8196:1029563] end</code></pre>

<p><strong>由于是同步操作，不能开辟线程，所以都是在主线程并按照顺序执行</strong></p>
<h5 id="2-串行队列异步执行任务"><a href="#2-串行队列异步执行任务" class="headerlink" title="2. 串行队列异步执行任务"></a>2. 串行队列异步执行任务</h5><ul>
<li>异步具有创建新线程的能力，会开辟新的线程去执行任务</li>
<li>按照串行的方式去执行任务</li>
</ul>
<pre><code>-(void)asyncSERIAL{
    NSLog(@"star");

    //会开辟新的线程,但是是串行执行任务
    dispatch_queue_t queue=dispatch_queue_create("ki", DISPATCH_QUEUE_SERIAL);
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:3];
        NSLog(@"SERIAL_work_1 ");
    });
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"SERIAL_work_2 ");
    });
    dispatch_async(queue, ^{
        NSLog(@"SERIAL_work_3 ");
    });

    NSLog(@"end");

}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:09:58.494 GCD_Demo[8213:1031268] star
2016-07-20 20:09:58.495 GCD_Demo[8213:1031268] end
2016-07-20 20:10:01.496 GCD_Demo[8213:1031315] SERIAL_work_1 
2016-07-20 20:10:03.502 GCD_Demo[8213:1031315] SERIAL_work_2 
2016-07-20 20:10:03.502 GCD_Demo[8213:1031315] SERIAL_work_3</code></pre>

<p><strong>因为是异步操作，所以有个编号为2的子线程被开辟，但有因为是串行队列，所以只开辟了一个线程。最终造就了三个任务顺序执行。</strong></p>
<h5 id="3-并行队列同步执行任务"><a href="#3-并行队列同步执行任务" class="headerlink" title="3. 并行队列同步执行任务"></a>3. 并行队列同步执行任务</h5><ul>
<li>同步不具有创建新线程的能力，不会开辟新的线程去执行任务，会在当前程序的主线程去执行任务</li>
<li>按照同步的方式去执行任务</li>
</ul>
<pre><code>-(void)syncCONCURRENT{
  NSLog(@"star");
  //不会开辟新的线程
  //串行执行命令
  dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
  dispatch_sync(queue, ^{
      [NSThread sleepForTimeInterval:3];
      NSLog(@"CONCURRENT_work_1 ");
  });
  dispatch_sync(queue, ^{
      [NSThread sleepForTimeInterval:2];
      NSLog(@"CONCURRENT_work_2 ");
  });
  dispatch_sync(queue, ^{
      NSLog(@"CONCURRENT_work_3 ");
  });

  NSLog(@"end");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:13:03.753 GCD_Demo[8232:1033759] star
2016-07-20 20:13:06.755 GCD_Demo[8232:1033759] CONCURRENT_work_1 
2016-07-20 20:13:08.756 GCD_Demo[8232:1033759] CONCURRENT_work_2 
2016-07-20 20:13:08.756 GCD_Demo[8232:1033759] CONCURRENT_work_3 
2016-07-20 20:13:08.757 GCD_Demo[8232:1033759] end</code></pre>

<p><strong>虽然并行队列决定了该队列中可以有多个线程，但由于是同步操作，不能开辟线程，所以还都是在主线程中按顺序执行。</strong></p>
<h5 id="4-并发队列异步执行任务-常用"><a href="#4-并发队列异步执行任务-常用" class="headerlink" title="4. 并发队列异步执行任务(常用)"></a>4. 并发队列异步执行任务(常用)</h5><ul>
<li>异步具有创建新线程的能力，会开辟新的线程去执行任务，不会在当前程序的主线程去执行任务</li>
<li>按照并发的方式去执行任务</li>
</ul>
<pre><code>-(void)asyncCONCURRENT{
  NSLog(@"star");

  //一个队列 为 每个任务开辟一个线程
  dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
  dispatch_async(queue, ^{
      [NSThread sleepForTimeInterval:3];
      NSLog(@"CONCURRENT_work_1 ");
  });
  dispatch_async(queue, ^{
      [NSThread sleepForTimeInterval:2];
      NSLog(@"CONCURRENT_work_2 ");
  });
  dispatch_async(queue, ^{
      NSLog(@"CONCURRENT_work_3 ");
  });

  NSLog(@"end");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-20 20:18:26.768 GCD_Demo[8256:1038143] star
2016-07-20 20:18:26.768 GCD_Demo[8256:1038143] end
2016-07-20 20:18:26.769 GCD_Demo[8256:1038192] CONCURRENT_work_3 
2016-07-20 20:18:28.771 GCD_Demo[8256:1038179] CONCURRENT_work_2 
2016-07-20 20:18:29.773 GCD_Demo[8256:1038188] CONCURRENT_work_1</code></pre>

<p><strong>并行队列可以里可以有多个线程，同步执行的方式又可以开辟多个线程，所以这里实现了多个线程并行执行。</strong></p>
<hr>
<h3 id="5-Dispatch-Group"><a href="#5-Dispatch-Group" class="headerlink" title="5.Dispatch Group"></a>5.Dispatch Group</h3><p>当我们想在gcd queue中所有的任务执行完毕之后做些特定事情的时候，也就是队列的同步问题，如果队列是串行的话，那将该操作最后添加到队列中即可，但如果队列是并行队列的话，这时候就可以利用dispatch_group来实现了，dispatch_group能很方便的解决同步的问题。dispatch_group_create可以创建一个group对象，然后可以添加block到该组里面，下面看下它的一些用法：</p>
<ul>
<li><p>dispatch_group_notify<br>  是通过异步的方式通知，所以，不会阻塞线程</p>
<pre><code>-(void)asyncGroupNotify
{
NSLog(@"star");
dispatch_group_t group=dispatch_group_create();
dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
dispatch_group_async(group, queue, ^{
    [NSThread sleepForTimeInterval:1];
    NSLog(@"group_work_1");
});
dispatch_group_async(group, queue, ^{
    [NSThread sleepForTimeInterval:6];
    NSLog(@"group_work_2");
});
dispatch_group_async(group, queue, ^{
    [NSThread sleepForTimeInterval:2];
    NSLog(@"group_work_3");
});

dispatch_group_notify(group, queue, ^{
    NSLog(@"dispatch_group_Notify 结束");
});
}</code></pre>

</li>
</ul>
<p>运行结果</p>
<pre><code>2016-07-21 13:51:40.600 GCD_Demo[9044:1162213] star
2016-07-21 13:51:41.605 GCD_Demo[9044:1162359] group_work_1
2016-07-21 13:51:42.608 GCD_Demo[9044:1162389] group_work_3
2016-07-21 13:51:46.603 GCD_Demo[9044:1162349] group_work_2
2016-07-21 13:51:46.605 GCD_Demo[9044:1162349] dispatch_group_Notify 结束</code></pre>

<ul>
<li>dispatch_group_wait<br>  会阻塞当前线程，知道任务都完成时才会继续执行下面的代码</li>
</ul>
<pre><code>-(void)asyncGroupWait
{
    NSLog(@"star");
    dispatch_group_t group=dispatch_group_create();
    dispatch_queue_t queue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
    dispatch_group_async(group, queue, ^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"group_work_1");
    });
    dispatch_group_async(group, queue, ^{
        [NSThread sleepForTimeInterval:6];
        NSLog(@"group_work_2");
    });
    dispatch_group_async(group, queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"group_work_3");
    });

    //在此设置了一个12秒的等待时间，如果group的执行结束没有到12秒那么就返回0
    //如果执行group的执行时间超过了12秒，那么返回非0 数值，
    //在使用dispatch_group_wait函数的时候，会阻塞当前线程，阻塞的时间 在wait函数时间值和当前group执行时间值取最小的。
    long kk=dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW, 12 * NSEC_PER_SEC));
    if(kk==0)
    {
         NSLog(@"dispatch_group_wait 结果1");
    }
    else
    {
         NSLog(@"dispatch_group_wait 结果2");
    }

}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 13:56:47.471 GCD_Demo[9065:1165380] star
2016-07-21 13:56:48.472 GCD_Demo[9065:1165494] group_work_1
2016-07-21 13:56:49.476 GCD_Demo[9065:1165502] group_work_3
2016-07-21 13:56:53.475 GCD_Demo[9065:1165485] group_work_2
2016-07-21 13:56:53.475 GCD_Demo[9065:1165380] dispatch_group_wait 结果1</code></pre>

<ul>
<li>dispatch_group_enter&amp;dispatch_group_leave<br>  假如我们不想使用dispatch_group_async异步的将任务丢到group中去执行，这时候就需要用到dispatch_group_enter跟dispatch_group_leave方法，这两个方法要配对出现，以下这两种方法是等价的：</li>
</ul>
<pre><code>-(void)asyncGroupEnter
{
  // 群组－统一监控一组任务
  dispatch_group_t group = dispatch_group_create();

  dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

  // 1> 入组 -> 之后的 block 会被 group 监听
  // dispatch_group_enter 一定和 dispatch_group_leave 要配对出现
  dispatch_group_enter(group);
  dispatch_async(queue, ^{
      NSLog(@"dispatch_async_work1");

      // block 的末尾，所有任务执行完毕后，添加一个出组
      dispatch_group_leave(group);
  });

  //  再次入组
  dispatch_group_enter(group);
  dispatch_async(queue, ^{
      [NSThread sleepForTimeInterval:6];

      NSLog(@"dispatch_async_work1");

      // block 的末尾，所有任务执行完毕后，添加一个出组
      dispatch_group_leave(group);
  });

  // 群组结束
  dispatch_group_notify(group, dispatch_get_main_queue(), ^{
      NSLog(@"OVER");
  });  
  NSLog(@"come here");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 15:21:40.707 GCD_Demo[9256:1205427] come here
2016-07-21 15:21:40.707 GCD_Demo[9256:1205465] dispatch_async_work1
2016-07-21 15:21:46.709 GCD_Demo[9256:1205460] dispatch_async_work1
2016-07-21 15:21:46.710 GCD_Demo[9256:1205427] OVER</code></pre>



<hr>
<h3 id="6-Dispatch-Block"><a href="#6-Dispatch-Block" class="headerlink" title="6. Dispatch Block"></a>6. Dispatch Block</h3><p>添加到gcd队列中执行的任务是以block的形式添加的，block封装了需要执行功能，block带来的开发效率提升就不说了，gcd跟block可以说是一对好基友，能够很好的配合使用。</p>
<pre><code>-(void)dispatchBlock
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block=dispatch_block_create(0, ^{
        NSLog(@"dispatchBlock_work");
    });

    dispatch_sync(queue, block);
}</code></pre>

<h5 id="1-dispatch-block-wait"><a href="#1-dispatch-block-wait" class="headerlink" title="1.dispatch_block_wait"></a>1.dispatch_block_wait</h5><p>当需要等待前面的任务执行完毕时，我们可以使用dispatch_block_wait这个接口，设置等待时间DISPATCH_TIME_FOREVER会一直等待直到前面的任务完成.用法跟dispatch_group_wait类似</p>
<pre><code>-(void)dispatchBlockWait
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t block = dispatch_block_create(0, ^{
        NSLog(@"before sleep");
        [NSThread sleepForTimeInterval:6];
        NSLog(@"after sleep");
    });
    dispatch_async(queue, block);
    //等待前面的任务执行完毕
    long kk=dispatch_block_wait(block, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));
    if(kk==0)
    {
        NSLog(@"coutinue");
    }
    else
    {
        NSLog(@"timeOut！！！");
    }
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:28:38.313 GCD_Demo[9533:1251011] before sleep
2016-07-21 16:28:41.314 GCD_Demo[9533:1250971] timeOut！！！
2016-07-21 16:28:44.318 GCD_Demo[9533:1251011] after sleep</code></pre>

<h5 id="2-dispatch-block-notify"><a href="#2-dispatch-block-notify" class="headerlink" title="2.dispatch_block_notify"></a>2.dispatch_block_notify</h5><p>dispatch_block_notify当观察的某个block执行结束之后立刻通知提交另一特定的block到指定的queue中执行，该函数有三个参数，第一参数是需要观察的block，第二个参数是被通知block提交执行的queue，第三参数是当需要被通知执行的block</p>
<pre><code>-(void)dispatchBlockNotify
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_block_t previousBlock = dispatch_block_create(0, ^{
        NSLog(@"previousBlock begin");
        [NSThread sleepForTimeInterval:2];
        NSLog(@"previousBlock done");
    });
    dispatch_async(queue, previousBlock);
    dispatch_block_t notifyBlock = dispatch_block_create(0, ^{
        NSLog(@"notifyBlock");
    });
    //当previousBlock执行完毕后，提交notifyBlock到global queue中执行
    dispatch_block_notify(previousBlock, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), notifyBlock);
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:38:19.756 GCD_Demo[9664:1261328] previousBlock begin
2016-07-21 16:38:21.762 GCD_Demo[9664:1261328] previousBlock done
2016-07-21 16:38:21.762 GCD_Demo[9664:1261329] notifyBlock</code></pre>

<h5 id="3-dispatch-block-cancel"><a href="#3-dispatch-block-cancel" class="headerlink" title="3. dispatch_block_cancel"></a>3. dispatch_block_cancel</h5><p>可以取消提交到队列的block</p>
<pre><code>-(void)dispatchBlockCancel
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);
    dispatch_block_t block1 = dispatch_block_create(0, ^{
        NSLog(@"block1 begin");
        [NSThread sleepForTimeInterval:1];
        NSLog(@"block1 done");
    });
    dispatch_block_t block2 = dispatch_block_create(0, ^{
        NSLog(@"block2 ");
    });
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_block_cancel(block2);
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:50:28.140 GCD_Demo[9723:1272259] block1 begin
2016-07-21 16:50:29.144 GCD_Demo[9723:1272259] block1 done</code></pre>


<hr>
<h3 id="7-dispatch-after"><a href="#7-dispatch-after" class="headerlink" title="7.dispatch_after"></a>7.dispatch_after</h3><p>来延迟执行的GCD方法，因为在主线程中我们不能用sleep来延迟方法的调用，所以用它是最合适的，我们做一个简单的例子：</p>
<pre><code>-(void)dispatchAfter
{
    NSLog(@"dispatchAfter_star");
    int64_t time=2*NSEC_PER_SEC;

    dispatch_queue_t mainQueue=dispatch_get_main_queue();

        for (int i=0; i<5; i++)="" {="" dispatch_time_t="" distime="dispatch_time(DISPATCH_TIME_NOW," time*i);="" dispatch_after(distime,="" mainqueue,="" ^{="" nslog(@"dispatchafter_work");="" });="" }="" }<="" code=""></5;></code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 16:12:07.204 GCD_Demo[9439:1237251] dispatchAfter_star
2016-07-21 16:12:07.211 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:09.398 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:11.205 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:13.205 GCD_Demo[9439:1237251] dispatchAfter_work
2016-07-21 16:12:15.205 GCD_Demo[9439:1237251] dispatchAfter_work</code></pre>


<hr>
<h3 id="8-dispatch-apply"><a href="#8-dispatch-apply" class="headerlink" title="8.dispatch_apply"></a>8.dispatch_apply</h3><p>dispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次，如果队列是并发队列，则会并发执行block任务，dispatch_apply是一个同步调用，block任务执行n次后才返回。</p>
<pre><code>-(void)dispatchApply
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);


    dispatch_apply(6, queue, ^(size_t i) {
        NSLog(@"do a job %zu times",i);

    });
    NSLog(@"go on");
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 17:04:54.558 GCD_Demo[9831:1284549] do a job 0 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284583] do a job 1 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284589] do a job 2 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284593] do a job 3 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284549] do a job 4 times
2016-07-21 17:04:54.564 GCD_Demo[9831:1284583] do a job 5 times
2016-07-21 17:04:54.566 GCD_Demo[9831:1284549] go on</code></pre>


<hr>
<h3 id="9-dispatch-once"><a href="#9-dispatch-once" class="headerlink" title="9.dispatch_once"></a>9.dispatch_once</h3><p>整个程序运行中只会执行一次，使用dispatch_once可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或者同步。所有问题都由GCD在底层处理。由于每次调用时都必须使用完全相同的标记，所以标记要声明成static。所以用在单例模式上是最好的</p>
<pre><code>static SingletonTimer * instance;
static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
    instance = [[SingletonTimer alloc] init];
});

return instance;</code></pre>


<hr>
<h3 id="10-dispatch-barrier-async"><a href="#10-dispatch-barrier-async" class="headerlink" title="10. dispatch_barrier_async"></a>10. dispatch_barrier_async</h3><p>dispatch_barrier_async用于等待前面的任务执行完毕后自己才执行，而它后面的任务需等待它完成之后才执行。一个典型的例子就是数据的读写，通常为了防止文件读写导致冲突，我们会创建一个串行的队列，所有的文件操作都是通过这个队列来执行，比如FMDB，这样就可以避免读写冲突。不过其实这样效率是有提升的空间的，当没有更新数据时，读操作其实是可以并行进行的，而写操作需要串行的执行</p>
<pre><code>-(void)diapatchBarrier
{
    dispatch_queue_t queue = dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_CONCURRENT);

    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:6];
        NSLog(@"dispatch_async_work1");
    });
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:2];
        NSLog(@"dispatch_async_work2");
    });
    dispatch_barrier_async(queue, ^{
        NSLog(@"dispatch_async_work3");
        [NSThread sleepForTimeInterval:1];

    });
    dispatch_async(queue, ^{
        [NSThread sleepForTimeInterval:1];
        NSLog(@"dispatch_async_work4");
    });
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 15:54:24.402 GCD_Demo[9354:1225160] dispatch_async_work2
2016-07-21 15:54:28.403 GCD_Demo[9354:1225152] dispatch_async_work1
2016-07-21 15:54:28.403 GCD_Demo[9354:1225152] dispatch_async_work3
2016-07-21 15:54:30.412 GCD_Demo[9354:1225152] dispatch_async_work4</code></pre>


<hr>
<h3 id="11-dispatch-set-target-queue"><a href="#11-dispatch-set-target-queue" class="headerlink" title="11.dispatch_set_target_queue"></a>11.dispatch_set_target_queue</h3><p>1.系统的Global Queue是可以指定优先级的，那我们可以用到dispatch_set_target_queue这个方法来指定自己创建队列的优先级</p>
<pre><code>-(void)DispatchSet
{
    dispatch_queue_t serialDiapatchQueue=dispatch_queue_create("com.GCD_demo.www", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t dispatchgetglobalqueue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
    dispatch_set_target_queue(serialDiapatchQueue, dispatchgetglobalqueue);
    dispatch_async(serialDiapatchQueue, ^{
        NSLog(@"我优先级低，先让让");
    });
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"我优先级高,我先block");
    });
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 17:22:02.512 GCD_Demo[9902:1297023] 我优先级高,我先block
2016-07-21 17:22:02.512 GCD_Demo[9902:1297035] 我优先级低，先让让</code></pre>

<p>2.dispatch_set_target_queue除了能用来设置队列的优先级之外，还能够创建队列的层次体系，当我们想让不同队列中的任务同步的执行时，我们可以创建一个串行队列，然后将这些队列的target指向新创建的队列即可</p>
<pre><code>-(void)dispatchSet2
{
    dispatch_queue_t targetQueue = dispatch_queue_create("target_queue", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue1 = dispatch_queue_create("queue1", DISPATCH_QUEUE_SERIAL);
    dispatch_queue_t queue2 = dispatch_queue_create("queue2", DISPATCH_QUEUE_CONCURRENT);


    dispatch_set_target_queue(queue1, targetQueue);
    dispatch_set_target_queue(queue2, targetQueue);

    dispatch_async(queue1, ^{
        [NSThread sleepForTimeInterval:3.f];
        NSLog(@"do job1");

    });
    dispatch_async(queue2, ^{
        [NSThread sleepForTimeInterval:2.f];
        NSLog(@"do job2");

    });
    dispatch_async(queue2, ^{
        [NSThread sleepForTimeInterval:1.f];
        NSLog(@"do job3");

    });
}</code></pre>

<p>执行结果</p>
<pre><code>2016-07-21 17:28:54.327 GCD_Demo[10043:1303853] do job1
2016-07-21 17:28:56.331 GCD_Demo[10043:1303853] do job2
2016-07-21 17:28:57.335 GCD_Demo[10043:1303853] do job3</code></pre>


<hr>
<h3 id="12-dispatch-semaphore-t"><a href="#12-dispatch-semaphore-t" class="headerlink" title="12.dispatch_semaphore_t"></a>12.dispatch_semaphore_t</h3><p>信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra 介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。</p>
<pre><code>- (void)downloadImageURLWithString:(NSString *)URLString
{
    // 1
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    NSURL *url = [NSURL URLWithString:URLString];
    __unused Photo *photo = [[Photo alloc]
                             initwithURL:url
                             withCompletionBlock:^(UIImage *image, NSError *error) {
                                 if (error) {
                                     XCTFail(@"%@ failed. %@", URLString, error);
                                 }

                                 // 2
                                 dispatch_semaphore_signal(semaphore);
                             }];

    // 3
    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);
    if (dispatch_semaphore_wait(semaphore, timeoutTime)) {
        XCTFail(@"%@ timed out", URLString);
    }
}</code></pre>

<p>下面来说明你代码中的信号量是如何工作的：</p>
<ol>
<li>创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。</li>
<li>在 Completion Block 里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。</li>
<li>这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过 10 秒钟就会返回——一个平衡点！</li>
</ol>
<hr>
<h3 id="13-GCD定时器"><a href="#13-GCD定时器" class="headerlink" title="13.GCD定时器"></a>13.GCD定时器</h3><p>基于以前讲的runloop中的CFRunLoopTimerRef :</p>
<ul>
<li>CFRunLoopTimerRef是基于时间的触发器</li>
<li>CFRunLoopTimerRef基本上说的就是NSTimer,它受RunLoop的Mode的影响(Tracking,Defalult)</li>
<li>GCD的定时器不受RunLoop中Mode的影响(RunLoop内部也是基于GCD实现的,可以根据源码看到), 比如滚动TableView的时候,GCD的定时器不受影响</li>
<li>一般NSTimer不是特别准, NSTimer是在RunLoop中, RunLoop要处理各种东西(source,timer,observe),有时导致NSTimer不是特别准</li>
</ul>
<p>GCD定时器算是一个源(source),类型是Timer</p>
<pre><code>-(void)startTime{
    __block int timeout=30; //倒计时时间
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);

    dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行
    dispatch_source_set_event_handler(_timer, ^{
        if(timeout=0){ //倒计时结束，关闭
            dispatch_source_cancel(_timer);
            dispatch_async(dispatch_get_main_queue(), ^{
                //倒计时时间结束，回到主线程 根据自己需求设置

            });
        }else{
            //            int minutes = timeout / 60;
            int seconds = timeout % 60;
            NSString *strTime = [NSString stringWithFormat:@"%.2d", seconds];
            dispatch_async(dispatch_get_main_queue(), ^{
                //设置界面的按钮显示 根据自己需求设置
                NSLog(@"____%@",strTime);
                [l_timeButton setTitle:[NSString stringWithFormat:@"%@秒后重新发送",strTime] forState:UIControlStateNormal];
                l_timeButton.userInteractionEnabled = NO;

            });
            timeout--;

        }
    });
    dispatch_resume(_timer);

}</code></pre>






<!-- more -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。&lt;/p&gt;
    
    </summary>
    
      <category term="GCD" scheme="http://www.guiyongdong.com/categories/GCD/"/>
    
    
      <category term="GCD" scheme="http://www.guiyongdong.com/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>RunLoop总结</title>
    <link href="http://www.guiyongdong.com/2016/09/08/RunLoop%E6%80%BB%E7%BB%93/"/>
    <id>http://www.guiyongdong.com/2016/09/08/RunLoop总结/</id>
    <published>2016-09-08T09:05:52.000Z</published>
    <updated>2016-09-08T09:43:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究了一下RunLoop，在这里对RunLoop做一个总结，主要是对<code>&lt;CoreFoundation/CFRunLoop.h&gt;</code>的头文件函数总结。</p>
<a id="more"></a>
<h3 id="关于RunLoop的资料总结"><a href="#关于RunLoop的资料总结" class="headerlink" title="关于RunLoop的资料总结"></a>关于RunLoop的资料总结</h3><p>网上关于RunLoop的总结大致相同，这里推荐几篇好的文章共大家学习。</p>
<ul>
<li><p>YYModel作者关于RunLoop的总结 《<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a>》</p>
</li>
<li><p>简书上不错的文章 《<a href="http://www.jianshu.com/p/37ab0397fec7" target="_blank" rel="external">【iOS程序启动与运转】- RunLoop个人小结</a>》</p>
</li>
<li><p>sunnyxx的RunLoop线下讨论会 <a href="https://pan.baidu.com/s/1i5bN3dN" target="_blank" rel="external">百度网盘</a></p>
</li>
<li><p>用RunLoop捕获程序Crash 防止用户使用时程序崩溃 <a href="https://github.com/guiyongdong/Resource/tree/master/%20CrashManager" target="_blank" rel="external">git连接</a></p>
</li>
</ul>
<h3 id="关于CFRunLoop-h的总结"><a href="#关于CFRunLoop-h的总结" class="headerlink" title="关于CFRunLoop.h的总结"></a>关于CFRunLoop.h的总结</h3><pre><code>

//Runloop
typedef struct __CFRunLoop * CFRunLoopRef;
//事件源
typedef struct __CFRunLoopSource * CFRunLoopSourceRef;
//观察者
typedef struct __CFRunLoopObserver * CFRunLoopObserverRef;
//定时器
typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;

/* Reasons for CFRunLoopRunInMode() to Return */
enum {
    kCFRunLoopRunFinished = 1, //Run Loop结束，没有Timer或者其他Input Source
    kCFRunLoopRunStopped = 2, //Run Loop被停止，使用CFRunLoopStop停止Run Loop
    kCFRunLoopRunTimedOut = 3, //RunLoop 超时
    kCFRunLoopRunHandledSource = 4 //Run Loop处理完事件，注意Timer事件的触发是不会让Run Loop退出返回的，即使CFRunLoopRunInMode的第三个参数是YES也不行
};

/* Run Loop Observer Activities */
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry = (1UL << 0), // 即将进入Loop
    kCFRunLoopBeforeTimers = (1UL << 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠
    kCFRunLoopAfterWaiting = (1UL << 6), // 刚从休眠中唤醒
    kCFRunLoopExit = (1UL << 7), // 即将退出Loop
    kCFRunLoopAllActivities = 0x0FFFFFFFU
};

//默认model
CF_EXPORT const CFStringRef kCFRunLoopDefaultMode;
//当uiscrollView滑动时Model
CF_EXPORT const CFStringRef kCFRunLoopCommonModes;

//获取当前RunLoop 当当前RunLoop没有的时候回创建一个  一个线程对应一个RunLoop
CF_EXPORT CFRunLoopRef CFRunLoopGetCurrent(void);
//获取主线程的RunLoop
CF_EXPORT CFRunLoopRef CFRunLoopGetMain(void);
//复制当前RunLoop
CF_EXPORT CFStringRef CFRunLoopCopyCurrentMode(CFRunLoopRef rl);
//复制当前RunLoop的所有Model
CF_EXPORT CFArrayRef CFRunLoopCopyAllModes(CFRunLoopRef rl);
//给当前RunLoop添加Model
CF_EXPORT void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFStringRef mode);
//获取RunLoop model的超时时间
CF_EXPORT CFAbsoluteTime CFRunLoopGetNextTimerFireDate(CFRunLoopRef rl, CFStringRef mode);
//手动启动RunLoop
CF_EXPORT void CFRunLoopRun(void);
/**
 *  切换当前RunLoop的model
 *
 *  @param mode                     model
 *  @param seconds                  执行时间
 *  @param returnAfterSourceHandled 执行完是否结束
 */
CF_EXPORT SInt32 CFRunLoopRunInMode(CFStringRef mode, CFTimeInterval seconds, Boolean returnAfterSourceHandled);
//当前RunLoop是否休眠
CF_EXPORT Boolean CFRunLoopIsWaiting(CFRunLoopRef rl);
//唤醒RunLoop
CF_EXPORT void CFRunLoopWakeUp(CFRunLoopRef rl);
//手动停止RunLoop
CF_EXPORT void CFRunLoopStop(CFRunLoopRef rl);

#if __BLOCKS__
//在RunLoop 特定Model执行 操作
CF_EXPORT void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void (^block)(void)) CF_AVAILABLE(10_6, 4_0); 
#endif
//RunLoop下是否包含某个Source
CF_EXPORT Boolean CFRunLoopContainsSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);
//添加Source
CF_EXPORT void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);
//移除Source
CF_EXPORT void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef mode);
//是否包换观察者
CF_EXPORT Boolean CFRunLoopContainsObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);
//添加某个model下的观察者
CF_EXPORT void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);
//移除观察者
CF_EXPORT void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef mode);
//是否包含定时器
CF_EXPORT Boolean CFRunLoopContainsTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
//添加定时器
CF_EXPORT void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
//移除定时器
CF_EXPORT void CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);

typedef struct {
    CFIndex    version;
    void *    info;
    const void *(*retain)(const void *info);
    void    (*release)(const void *info);
    CFStringRef    (*copyDescription)(const void *info);
    Boolean    (*equal)(const void *info1, const void *info2);
    CFHashCode    (*hash)(const void *info);
    void    (*schedule)(void *info, CFRunLoopRef rl, CFStringRef mode);
    void    (*cancel)(void *info, CFRunLoopRef rl, CFStringRef mode);
    void    (*perform)(void *info);
} CFRunLoopSourceContext;

typedef struct {
    CFIndex    version;
    void *    info;
    const void *(*retain)(const void *info);
    void    (*release)(const void *info);
    CFStringRef    (*copyDescription)(const void *info);
    Boolean    (*equal)(const void *info1, const void *info2);
    CFHashCode    (*hash)(const void *info);
#if (TARGET_OS_MAC && !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)
    mach_port_t    (*getPort)(void *info);
    void *    (*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info);
#else
    void *    (*getPort)(void *info);
    void    (*perform)(void *info);
#endif
} CFRunLoopSourceContext1;

CF_EXPORT CFTypeID CFRunLoopSourceGetTypeID(void);

//创建事件源
CF_EXPORT CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context);

CF_EXPORT CFIndex CFRunLoopSourceGetOrder(CFRunLoopSourceRef source);
CF_EXPORT void CFRunLoopSourceInvalidate(CFRunLoopSourceRef source);
CF_EXPORT Boolean CFRunLoopSourceIsValid(CFRunLoopSourceRef source);
CF_EXPORT void CFRunLoopSourceGetContext(CFRunLoopSourceRef source, CFRunLoopSourceContext *context);
CF_EXPORT void CFRunLoopSourceSignal(CFRunLoopSourceRef source);

typedef struct {
    CFIndex    version;
    void *    info;
    const void *(*retain)(const void *info);
    void    (*release)(const void *info);
    CFStringRef    (*copyDescription)(const void *info);
} CFRunLoopObserverContext;

typedef void (*CFRunLoopObserverCallBack)(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info);

CF_EXPORT CFTypeID CFRunLoopObserverGetTypeID(void);

CF_EXPORT CFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context);
#if __BLOCKS__
/**
 *  创建观察者
 *
 *  @param allocator  默认 kCFAllocatorDefault
 *  @param activities 监听 RunLoop的哪种状态
 *  @param repeats    是否一直监听
 *  @param order      优先级 默认 0
 *  @param ^block     回调
 *
 */
CF_EXPORT CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, void (^block) (CFRunLoopObserverRef observer, CFRunLoopActivity activity)) CF_AVAILABLE(10_7, 5_0);
#endif

//获取当前观察者观察的状态
CF_EXPORT CFOptionFlags CFRunLoopObserverGetActivities(CFRunLoopObserverRef observer);
//获取当前观察者是否一直观察
CF_EXPORT Boolean CFRunLoopObserverDoesRepeat(CFRunLoopObserverRef observer);
//获取优先级
CF_EXPORT CFIndex CFRunLoopObserverGetOrder(CFRunLoopObserverRef observer);
CF_EXPORT void CFRunLoopObserverInvalidate(CFRunLoopObserverRef observer);
CF_EXPORT Boolean CFRunLoopObserverIsValid(CFRunLoopObserverRef observer);
CF_EXPORT void CFRunLoopObserverGetContext(CFRunLoopObserverRef observer, CFRunLoopObserverContext *context);

typedef struct {
    CFIndex    version;
    void *    info;
    const void *(*retain)(const void *info);
    void    (*release)(const void *info);
    CFStringRef    (*copyDescription)(const void *info);
} CFRunLoopTimerContext;

typedef void (*CFRunLoopTimerCallBack)(CFRunLoopTimerRef timer, void *info);

CF_EXPORT CFTypeID CFRunLoopTimerGetTypeID(void);
//创建定时器
CF_EXPORT CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context);
#if __BLOCKS__
//使用Block创建定时器
CF_EXPORT CFRunLoopTimerRef CFRunLoopTimerCreateWithHandler(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, void (^block) (CFRunLoopTimerRef timer)) CF_AVAILABLE(10_7, 5_0);
#endif
//获取超时时间
CF_EXPORT CFAbsoluteTime CFRunLoopTimerGetNextFireDate(CFRunLoopTimerRef timer);
//设置超时时间
CF_EXPORT void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate);
CF_EXPORT CFTimeInterval CFRunLoopTimerGetInterval(CFRunLoopTimerRef timer);
//是否循环执行
CF_EXPORT Boolean CFRunLoopTimerDoesRepeat(CFRunLoopTimerRef timer);
//获取优先级
CF_EXPORT CFIndex CFRunLoopTimerGetOrder(CFRunLoopTimerRef timer);
CF_EXPORT void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer);
CF_EXPORT Boolean CFRunLoopTimerIsValid(CFRunLoopTimerRef timer);
CF_EXPORT void CFRunLoopTimerGetContext(CFRunLoopTimerRef timer, CFRunLoopTimerContext *context);

// Setting a tolerance for a timer allows it to fire later than the scheduled fire date, improving the ability of the system to optimize for increased power savings and responsiveness. The timer may fire at any time between its scheduled fire date and the scheduled fire date plus the tolerance. The timer will not fire before the scheduled fire date. For repeating timers, the next fire date is calculated from the original fire date regardless of tolerance applied at individual fire times, to avoid drift. The default value is zero, which means no additional tolerance is applied. The system reserves the right to apply a small amount of tolerance to certain timers regardless of the value of this property.
// As the user of the timer, you will have the best idea of what an appropriate tolerance for a timer may be. A general rule of thumb, though, is to set the tolerance to at least 10% of the interval, for a repeating timer. Even a small amount of tolerance will have a significant positive impact on the power usage of your application. The system may put a maximum value of the tolerance.
CF_EXPORT CFTimeInterval CFRunLoopTimerGetTolerance(CFRunLoopTimerRef timer) CF_AVAILABLE(10_9, 7_0);
CF_EXPORT void CFRunLoopTimerSetTolerance(CFRunLoopTimerRef timer, CFTimeInterval tolerance) CF_AVAILABLE(10_9, 7_0);

CF_EXTERN_C_END
CF_IMPLICIT_BRIDGING_DISABLED


</code></pre>






<!-- more -->
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近研究了一下RunLoop，在这里对RunLoop做一个总结，主要是对&lt;code&gt;&amp;lt;CoreFoundation/CFRunLoop.h&amp;gt;&lt;/code&gt;的头文件函数总结。&lt;/p&gt;
    
    </summary>
    
      <category term="RunLoop" scheme="http://www.guiyongdong.com/categories/RunLoop/"/>
    
    
      <category term="RunLoop" scheme="http://www.guiyongdong.com/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title>关于RAC的一些资料</title>
    <link href="http://www.guiyongdong.com/2016/09/06/%E5%85%B3%E4%BA%8ERAC%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B5%84%E6%96%99/"/>
    <id>http://www.guiyongdong.com/2016/09/06/关于RAC的一些资料/</id>
    <published>2016-09-06T06:47:26.000Z</published>
    <updated>2016-09-06T07:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>看了这么多RAC资料，在这里我整理了一下，以备学习。</p>
<a id="more"></a>
<h5 id="何为函数式编程"><a href="#何为函数式编程" class="headerlink" title="何为函数式编程"></a>何为函数式编程</h5><ul>
<li><a href="http://valiantcat.com/2016/06/03/%E4%BB%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%88%B0%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" target="_blank" rel="external">从函数调用到函数式编程</a></li>
</ul>
<h5 id="RP入门"><a href="#RP入门" class="headerlink" title="RP入门"></a>RP入门</h5><ul>
<li><a href="https://github.com/benjycui/introrx-chinese-edition" target="_blank" rel="external">RP入门</a></li>
</ul>
<h5 id="RAC思想"><a href="#RAC思想" class="headerlink" title="RAC思想"></a>RAC思想</h5><ul>
<li><p><a href="http://www.jianshu.com/p/25922584bc43" target="_blank" rel="external">iOS Reactive Cocoa使用浅析</a></p>
</li>
<li><p><a href="http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/index.html" target="_blank" rel="external">ReactiveCocoa 讨论会</a></p>
</li>
</ul>
<h5 id="RAC基础篇"><a href="#RAC基础篇" class="headerlink" title="RAC基础篇"></a>RAC基础篇</h5><ul>
<li><p><a href="http://www.guiyongdong.com/2016/08/11/%E5%88%9D%E8%AF%86ReactiveCocoa/">初识ReactiveCocoa</a></p>
</li>
<li><p><a href="http://www.guiyongdong.com/2016/08/12/%E6%B7%B1%E5%85%A5ReactiveCocoa/">深入ReactiveCocoa</a></p>
</li>
</ul>
<h5 id="非常不错的RAC入门教程"><a href="#非常不错的RAC入门教程" class="headerlink" title="非常不错的RAC入门教程"></a>非常不错的RAC入门教程</h5><ul>
<li><p><a href="http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1" target="_blank" rel="external">ReactiveCocoa入门教程——第一部分对应的中文版</a></p>
</li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="external">Reactive Cocoa Tutorial [1] = 神奇的Macros</a></p>
</li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_2_racstream/" target="_blank" rel="external">Reactive Cocoa Tutorial [2] = 百变RACStream</a></p>
</li>
<li><p><a href="http://blog.sunnyxx.com/2014/03/06/rac_3_racsignal/" target="_blank" rel="external">Reactive Cocoa Tutorial [3] = RACSignal的巧克力工厂</a></p>
</li>
<li><p><a href="http://blog.sunnyxx.com/2014/04/19/rac_4_filters/" target="_blank" rel="external">Reactive Cocoa Tutorial [4] = 只取所需的Filters</a></p>
</li>
<li><p><a href="http://leichunfeng.github.io/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan" target="_blank" rel="external">ReactiveCocoa v2.5 源码解析之架构总览</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/d262f2c55fbe" target="_blank" rel="external">RAC核心元素与信号流</a></p>
</li>
</ul>
<h5 id="来自美团的对冷热信号的分析"><a href="#来自美团的对冷热信号的分析" class="headerlink" title="来自美团的对冷热信号的分析"></a>来自美团的对冷热信号的分析</h5><ul>
<li><p><a href="http://tech.meituan.com/RACSignalSubscription.html" target="_blank" rel="external">RACSignal的Subscription深入分析 - 美团点评技术团队</a></p>
</li>
<li><p><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（一）</a></p>
</li>
<li><p><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-2.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号</a></p>
</li>
<li><p><a href="http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号</a></p>
</li>
<li><p><a href="http://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html" target="_blank" rel="external">ReactiveCocoa中潜在的内存泄漏及解决方案</a></p>
</li>
<li><p><a href="http://tech.meituan.com/RACSignalSubscription.html" target="_blank" rel="external">RACSignal的Subscription深入分析</a></p>
</li>
</ul>
<h5 id="RAC源码解析"><a href="#RAC源码解析" class="headerlink" title="RAC源码解析"></a>RAC源码解析</h5><ul>
<li><p><a href="http://www.jianshu.com/p/d262f2c55fbe" target="_blank" rel="external">RAC核心元素与信号流</a></p>
</li>
<li><p><a href="http://ios.jobbole.com/85019/" target="_blank" rel="external">剖析@weakify 和 @strongify</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/baeebca1f6f4" target="_blank" rel="external">ReactiveCocoa源码阅读之前序</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/d5e4dc7e592e" target="_blank" rel="external">ReactiveCocoa源码阅读之RACSignal(一)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/bcdea71ba824" target="_blank" rel="external">ReactiveCocoa源码阅读之RACSignal(二)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/7c1ddba2b3a4" target="_blank" rel="external">ReactiveCocoa源码阅读之bind函数</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/f939bf6afc93" target="_blank" rel="external">ReactiveCocoa源码阅读之攻略flatten</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/f3b00e90035d" target="_blank" rel="external">ReactiveCocoa源码阅读之switchToLatest/combineLatestWith</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/a151e5cb0aae" target="_blank" rel="external">ReactiveCocoa源码阅读之RACScheduler</a></p>
</li>
</ul>
<h5 id="MVVM-With-ReactiveCocoa"><a href="#MVVM-With-ReactiveCocoa" class="headerlink" title="MVVM With ReactiveCocoa"></a>MVVM With ReactiveCocoa</h5><ul>
<li><p><a href="http://www.jianshu.com/p/b2fe0920e3aa" target="_blank" rel="external">MVVM与ReactiveCocoa的运用(Part1)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/b51344f4f3a3" target="_blank" rel="external">MVVM与ReactiveCocoa的运用(Part2)</a></p>
</li>
<li><p><a href="https://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 1/2</a></p>
</li>
<li><p><a href="https://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 2/2</a></p>
</li>
<li><p><a href="http://leichunfeng.github.io/blog/2016/02/27/mvvm-with-reactivecocoa" target="_blank" rel="external">MVVM With ReactiveCocoa</a></p>
</li>
</ul>
<h5 id="RAC其它"><a href="#RAC其它" class="headerlink" title="RAC其它"></a>RAC其它</h5><ul>
<li><p><a href="http://www.jianshu.com/p/fccba7be1ca1" target="_blank" rel="external">ReactiveCocoa 4 文档翻译目录</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/0ea216239efb" target="_blank" rel="external">ReactiveCocoa 4 图解之一——事件（Event）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/ba5247d713a9" target="_blank" rel="external">ReactiveCocoa 4 图解之二——监听器（Observer）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/7a4a1d005aee" target="_blank" rel="external">ReactiveCocoa 4 图解之三——存根（Disposable)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/f0c945e5b2fe" target="_blank" rel="external">ReactiveCocoa 4 图解之五——信号（Signal)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/617063a81136" target="_blank" rel="external">ReactiveCocoa 4 图解之六——信号发生器（SignalProducer）</a></p>
</li>
</ul>
<!-- more -->
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了这么多RAC资料，在这里我整理了一下，以备学习。&lt;/p&gt;
    
    </summary>
    
      <category term="ReactiveCocoa" scheme="http://www.guiyongdong.com/categories/ReactiveCocoa/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.guiyongdong.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa和RXSwift速查表</title>
    <link href="http://www.guiyongdong.com/2016/09/06/ReactiveCocoa%E5%92%8CRXSwift%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <id>http://www.guiyongdong.com/2016/09/06/ReactiveCocoa和RXSwift速查表/</id>
    <published>2016-09-06T01:55:48.000Z</published>
    <updated>2016-09-06T02:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>在接触了RAC以后,对RAC有了一个基本的了解，这里整理了一下RAC脑图，方便日后查看。ps(<a href="https://github.com/aiqiuqiu/FRPCheatSheeta" target="_blank" rel="external">转载</a>)</p>
<a id="more"></a>
<h3 id="ReactiveCocoa-Objective-C部分"><a href="#ReactiveCocoa-Objective-C部分" class="headerlink" title="ReactiveCocoa-Objective-C部分"></a>ReactiveCocoa-Objective-C部分</h3><p><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/ReactiveCocoa-Objective-C.png?raw=true" alt="ReactiveCocoa-Objective-C Swartz"></p>
<h3 id="ReactiveCocoaV4-x-Swift部分"><a href="#ReactiveCocoaV4-x-Swift部分" class="headerlink" title="ReactiveCocoaV4.x-Swift部分"></a>ReactiveCocoaV4.x-Swift部分</h3><p><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/ReactiveCocoaV4.x-Swift.png?raw=true" alt="ReactiveCocoaV4.x-Swift Swartz"></p>
<h3 id="RXSwift部分"><a href="#RXSwift部分" class="headerlink" title="RXSwift部分"></a>RXSwift部分</h3><p><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/RXSwift.png?raw=true" alt="ReactiveCocoaV4.x-Swift Swartz"></p>
<!-- more -->
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接触了RAC以后,对RAC有了一个基本的了解，这里整理了一下RAC脑图，方便日后查看。ps(&lt;a href=&quot;https://github.com/aiqiuqiu/FRPCheatSheeta&quot;&gt;转载&lt;/a&gt;)&lt;/p&gt;
    
    </summary>
    
      <category term="ReactiveCocoa" scheme="http://www.guiyongdong.com/categories/ReactiveCocoa/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.guiyongdong.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>深入ReactiveCocoa</title>
    <link href="http://www.guiyongdong.com/2016/08/12/%E6%B7%B1%E5%85%A5ReactiveCocoa/"/>
    <id>http://www.guiyongdong.com/2016/08/12/深入ReactiveCocoa/</id>
    <published>2016-08-12T09:37:47.000Z</published>
    <updated>2016-08-26T09:29:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>(简称为RAC),上一篇文章，我们简单的对RAC有个初步的了解，在开发中，我们实际用到的基本都是上一篇所介绍的知识，这篇文章我们对RAC有个深入的了解。</p>
<a id="more"></a>
<h3 id="1-ReactiveCocoa常见操作方法介绍"><a href="#1-ReactiveCocoa常见操作方法介绍" class="headerlink" title="1.ReactiveCocoa常见操作方法介绍"></a>1.ReactiveCocoa常见操作方法介绍</h3><ul>
<li>1.1 ReactiveCocoa操作须知<ul>
<li>所有的信号（RACSignal）都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，而RACSignal继承RACStream。</li>
</ul>
</li>
<li>1.2  ReactiveCocoa操作思想<ul>
<li>运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术.</li>
<li>Hook用处：截获API调用的技术。</li>
<li>Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。</li>
<li>RAC开发方式：RAC中核心开发方式，也是绑定，之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。</li>
<li>列如：把数据展示到控件上，之前都是重写控件的setModel方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。</li>
</ul>
</li>
<li>1.3  ReactiveCocoa核心方法bind<ul>
<li>eactiveCocoa操作的核心方法是bind（绑定）,给RAC中的信号进行绑定，只要信号一发送数据，就能监听到，从而把发送数据改成自己想要的数据。</li>
<li>在开发中很少使用bind方法，bind属于RAC中的底层方法，RAC已经封装了很多好用的其他方法，底层都是调用bind，用法比bind简单.</li>
<li><code>bind</code>方法简单介绍和使用。</li>
</ul>
</li>
</ul>
<pre><code>
    // 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”            
    // 方式一:在返回结果后，拼接。
        [_textField.rac_textSignal subscribeNext:^(id x) {
            NSLog(@"输出:%@",x);
        }];

    // 方式二:在返回结果前，拼接，使用RAC中bind方法做处理。
    // bind方法参数:需要传入一个返回值是RACStreamBindBlock的block参数
    // RACStreamBindBlock是一个block的类型，返回值是信号，参数（value,stop），因此参数的block返回值也是一个block。

    // RACStreamBindBlock:
    // 参数一(value):表示接收到信号的原始值，还没做处理
    // 参数二(*stop):用来控制绑定Block，如果*stop = yes,那么就会结束绑定。
    // 返回值：信号，做好处理，在通过这个信号返回出去，一般使用RACReturnSignal,需要手动导入头文件RACReturnSignal.h。

    // bind方法使用步骤:
    // 1.传入一个返回值RACStreamBindBlock的block。
    // 2.描述一个RACStreamBindBlock类型的bindBlock作为block的返回值。
    // 3.描述一个返回结果的信号，作为bindBlock的返回值。
    // 注意：在bindBlock中做信号结果的处理。

    // 底层实现:
    // 1.源信号调用bind,会重新创建一个绑定信号。
    // 2.当绑定信号被订阅，就会调用绑定信号中的didSubscribe，生成一个bindingBlock。
    // 3.当源信号有内容发出，就会把内容传递到bindingBlock处理，调用bindingBlock(value,stop)
    // 4.调用bindingBlock(value,stop)，会返回一个内容处理完成的信号（RACReturnSignal）。
    // 5.订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。

    // 注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。
    // 这里需要手动导入#import <reactivecocoa racreturnsignal.h="">，才能使用RACReturnSignal。

    [[_textField.rac_textSignal bind:^RACStreamBindBlock{

        // 什么时候调用:
        // block作用:表示绑定了一个信号.

        return ^RACStream *(id value, BOOL *stop){

            // 什么时候调用block:当信号有新的值发出，就会来到这个block。

            // block作用:做返回值的处理

            // 做好处理，通过信号返回出去.
            return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]];
        };

    }] subscribeNext:^(id x) {

        NSLog(@"%@",x);

    }];
</reactivecocoa></code></pre>

<ul>
<li>1.4 ReactiveCocoa操作方法之映射(flattenMap,Map)<ul>
<li><code>flattenMap</code>，<code>Map</code> 用于把源信号内容映射成新的内容。</li>
</ul>
</li>
</ul>
<p><code>flattenMap</code> 简单使用</p>
<pre><code>
    // 监听文本框的内容改变，把结构重新映射成一个新值.

    // flattenMap作用:把源信号的内容映射成一个新的信号，信号可以是任意类型。

    // flattenMap使用步骤:
    // 1.传入一个block，block类型是返回值RACStream，参数value
    // 2.参数value就是源信号的内容，拿到源信号的内容做处理
    // 3.包装成RACReturnSignal信号，返回出去。

    // flattenMap底层实现:
    // 0.flattenMap内部调用bind方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。
    // 1.当订阅绑定信号，就会生成bindBlock。
    // 2.当源信号发送内容，就会调用bindBlock(value, *stop)
    // 3.调用bindBlock，内部就会调用flattenMap的block，flattenMap的block作用：就是把处理好的数据包装成信号。
    // 4.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。
    // 5.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。



    [[_textField.rac_textSignal flattenMap:^RACStream *(id value) {

    // block什么时候 : 源信号发出的时候，就会调用这个block。

    // block作用 : 改变源信号的内容。

    // 返回值：绑定信号的内容.
    return [RACReturnSignal return:[NSString stringWithFormat:@"输出:%@",value]];

    }] subscribeNext:^(id x) {

    // 订阅绑定信号，每当源信号发送内容，做完处理，就会调用这个block。

    NSLog(@"%@",x);

    }];
</code></pre>

<p><code>Map</code> 简单使用:</p>
<pre><code>
    // 监听文本框的内容改变，把结构重新映射成一个新值.

    // Map作用:把源信号的值映射成一个新的值

    // Map使用步骤:
    // 1.传入一个block,类型是返回对象，参数是value
    // 2.value就是源信号的内容，直接拿到源信号的内容做处理
    // 3.把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。

    // Map底层实现:
    // 0.Map底层其实是调用flatternMap,Map中block中的返回的值会作为flatternMap中block中的值。
    // 1.当订阅绑定信号，就会生成bindBlock。
    // 3.当源信号发送内容，就会调用bindBlock(value, *stop)
    // 4.调用bindBlock，内部就会调用flattenMap的block
    // 5.flattenMap的block内部会调用Map中的block，把Map中的block返回的内容包装成返回的信号。
    // 5.返回的信号最终会作为bindBlock中的返回信号，当做bindBlock的返回信号。
    // 6.订阅bindBlock的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。

    [[_textField.rac_textSignal map:^id(id value) {
        // 当源信号发出，就会调用这个block，修改源信号的内容
        // 返回值：就是处理完源信号的内容。
        return [NSString stringWithFormat:@"输出:%@",value];
    }] subscribeNext:^(id x) {

        NSLog(@"%@",x);
    }];
</code></pre>


<ul>
<li><p><code>FlatternMap</code>和<code>Map</code>的区别</p>
<ul>
<li>1.FlatternMap中的Block返回信号。</li>
<li>2.Map中的Block返回对象。</li>
<li>3.开发中，如果信号发出的值不是信号，映射一般使用Map</li>
<li>4.开发中，如果信号发出的值是信号，映射一般使用FlatternMap。</li>
</ul>
</li>
<li><p><code>总结</code>：signalOfsignals用FlatternMap。</p>
</li>
</ul>
<pre><code>
    // 创建信号中的信号
    RACSubject *signalOfsignals = [RACSubject subject];
    RACSubject *signal = [RACSubject subject];

    [[signalOfsignals flattenMap:^RACStream *(id value) {

     // 当signalOfsignals的signals发出信号才会调用

        return value;

    }] subscribeNext:^(id x) {

        // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。
        // 也就是flattenMap返回的信号发出内容，才会调用。

        NSLog(@"%@aaa",x);
    }];

    // 信号的信号发送信号
    [signalOfsignals sendNext:signal];

    // 信号发送内容
    [signal sendNext:@1];
</code></pre>

<ul>
<li><p>1.5 ReactiveCocoa操作方法之组合。</p>
<ul>
<li><p><code>concat</code>:按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号。</p>
<pre><code>
RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  [subscriber sendCompleted];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 把signalA拼接到signalB后，signalA发送完成，signalB才会被激活。
RACSignal *concatSignal = [signalA concat:signalB];
// 以后只需要面对拼接信号开发。
// 订阅拼接的信号，不需要单独订阅signalA，signalB
// 内部会自动订阅。
// 注意：第一个信号必须发送完成，第二个信号才会被激活
[concatSignal subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
// concat底层实现:
// 1.当拼接信号被订阅，就会调用拼接信号的didSubscribe
// 2.didSubscribe中，会先订阅第一个源信号（signalA）
// 3.会执行第一个源信号（signalA）的didSubscribe
// 4.第一个源信号（signalA）didSubscribe中发送值，就会调用第一个源信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来.
// 5.第一个源信号（signalA）didSubscribe中发送完成，就会调用第一个源信号（signalA）订阅者的completedBlock,订阅第二个源信号（signalB）这时候才激活（signalB）。
// 6.订阅第二个源信号（signalB）,执行第二个源信号（signalB）的didSubscribe
// 7.第二个源信号（signalA）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来.
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>then</code>:用于连接两个信号，当第一个信号完成，才会连接then返回的信号。</p>
<pre><code>
// then:用于连接两个信号，当第一个信号完成，才会连接then返回的信号
// 注意使用then，之前信号的值会被忽略掉.
// 底层实现：1、先过滤掉之前的信号发出的值。2.使用concat连接then返回的信号
[[[RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  [subscriber sendCompleted];
  return nil;
}] then:^RACSignal *{
  return [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
      [subscriber sendNext:@2];
      return nil;
  }];
}] subscribeNext:^(id x) {
  // 只能接收到第二个信号的值，也就是then返回信号的值
  NSLog(@"%@",x);
}];
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>merge</code>:把多个信号合并为一个信号，任何一个信号有新值的时候就会调用.</p>
<pre><code>
// merge:把多个信号合并成一个信号
//创建多个信号
RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 合并信号,任何一个信号发送数据，都能监听到.
RACSignal *mergeSignal = [signalA merge:signalB];
[mergeSignal subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
// 底层实现：
// 1.合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。
// 2.每发出一个信号，这个信号就会被订阅
// 3.也就是合并信号一被订阅，就会订阅里面所有的信号。
// 4.只要有一个信号被发出就会被监听。
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>zipWith</code>:把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。</p>
<pre><code>
RACSignal *signalA = [RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 压缩信号A，信号B
RACSignal *zipSignal = [signalA zipWith:signalB];
[zipSignal subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
// 底层实现:
// 1.定义压缩信号，内部就会自动订阅signalA，signalB
// 2.每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把最近发出的信号都包装成元组发出。
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>combineLatest</code>:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</p>
<pre><code>
RACSignal *signalA = [RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 把两个信号组合成一个信号,跟zip一样，没什么区别
RACSignal *combineSignal = [signalA combineLatestWith:signalB];
[combineSignal subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
// 底层实现：
// 1.当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。
// 2.并且把两个信号组合成元组发出。
</racsubscriber></racsubscriber></code></pre>
</li>
<li><p><code>reduce</code>聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值</p>
<pre><code>
RACSignal *signalA = [RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
  [subscriber sendNext:@1];
  return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  [subscriber sendNext:@2];
  return nil;
}];
// 聚合
// 常见的用法，（先组合在聚合）。combineLatest:(id<nsfastenumeration>)signals reduce:(id (^)())reduceBlock
// reduce中的block简介:
// reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容
// reduceblcok的返回值：聚合信号之后的内容。
RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB] reduce:^id(NSNumber *num1 ,NSNumber *num2){
 return [NSString stringWithFormat:@"%@ %@",num1,num2];
}];
[reduceSignal subscribeNext:^(id x) {

  NSLog(@"%@",x);
}];
// 底层实现:
// 1.订阅聚合信号，每次有内容发出，就会执行reduceblcok，把信号内容转换成reduceblcok返回的值。
</nsfastenumeration></racsubscriber></racsubscriber></code></pre>
</li>
</ul>
</li>
<li><p>1.6 ReactiveCocoa操作方法之过滤。    </p>
<ul>
<li><p><code>filter</code>:过滤信号，使用它可以获取满足条件的信号.</p>
<pre><code>
// 过滤:
// 每次信号发出，会先执行过滤条件判断.
[_textField.rac_textSignal filter:^BOOL(NSString *value) {
    return value.length > 3;
}];
</code></pre>
</li>
<li><p><code>ignore</code>:忽略完某些值的信号. </p>
<pre><code>
// 内部调用filter过滤，忽略掉ignore的值
[[_textField.rac_textSignal ignore:@"1"] subscribeNext:^(id x) {
NSLog(@"%@",x);
}];
</code></pre>
</li>
<li><p><code>distinctUntilChanged</code>:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</p>
<pre><code>
// 过滤，当上一次和当前的值不一样，就会发出内容。
// 在开发中，刷新UI经常使用，只有两次数据不一样才需要刷新
[[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) {
NSLog(@"%@",x);
}];
</code></pre>
</li>
<li><p><code>take</code>:从开始一共取N次的信号</p>
<pre><code>
   // 1、创建信号
  RACSubject *signal = [RACSubject subject];
  // 2、处理信号，订阅信号
  [[signal takeLast:1] subscribeNext:^(id x) {
    NSLog(@"%@",x);
  }];
  // 3.发送信号
  [signal sendNext:@1];
  [signal sendNext:@2];
  [signal sendCompleted];
</code></pre>
</li>
<li><p><code>skip</code>:(NSUInteger):跳过几个信号,不接受。</p>
<pre><code>
   // 表示输入第一次，不会被监听到，跳过第一次发出的信号
    [[_textField.rac_textSignal skip:1] subscribeNext:^(id x) {
        NSLog(@"%@",x);
    }];
</code></pre>
</li>
<li><p><code>switchToLatest</code>:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</p>
<pre><code>
   RACSubject *signalOfSignals = [RACSubject subject];
  RACSubject *signal = [RACSubject subject];
  [signalOfSignals sendNext:signal];
  [signal sendNext:@1];
  // 获取信号中信号最近发出信号，订阅最近发出的信号。
  // 注意switchToLatest：只能用于信号中的信号
  [signalOfSignals.switchToLatest subscribeNext:^(id x) {
   NSLog(@"%@",x);
  }];
</code></pre>
</li>
</ul>
</li>
<li><p>1.7 ReactiveCocoa操作方法之秩序.</p>
<ul>
<li><code>doNext</code>: 执行Next之前，会先执行这个Block</li>
<li><code>doCompleted</code>: 执行sendCompleted之前，会先执行这个Block<pre><code>
[[[[RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
[subscriber sendNext:@1];
[subscriber sendCompleted];
return nil;
}] doNext:^(id x) {
// 执行[subscriber sendNext:@1];之前会调用这个Block
NSLog(@"doNext");;
}] doCompleted:^{
 // 执行[subscriber sendCompleted];之前会调用这个Block
NSLog(@"doCompleted");;
}] subscribeNext:^(id x) {
NSLog(@"%@",x);
}];
</racsubscriber></code></pre>
</li>
</ul>
</li>
<li><p>1.8 ReactiveCocoa操作方法之线程。    </p>
<ul>
<li><code>deliverOn</code>: 内容传递切换到制定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。</li>
<li><code>subscribeOn</code>: 内容传递和副作用都会切换到制定线程中。</li>
</ul>
</li>
<li><p>1.9 ReactiveCocoa操作方法之时间。</p>
<ul>
<li><p><code>timeout</code>：超时，可以让一个信号在一定的时间后，自动报错。</p>
<pre><code>
RACSignal *signal = [[RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
return nil;
}] timeout:1 onScheduler:[RACScheduler currentScheduler]];
[signal subscribeNext:^(id x) {
NSLog(@"%@",x);
} error:^(NSError *error) {
// 1秒后会自动调用
NSLog(@"%@",error);
}];
</racsubscriber></code></pre>
</li>
<li><p><code>interval</code> 定时：每隔一段时间发出信号</p>
<pre><code>
[[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) {
   NSLog(@"%@",x);
}];
</code></pre>
</li>
<li><p><code>delay</code> 延迟发送next。</p>
<pre><code>
RACSignal *signal = [[[RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
[subscriber sendNext:@1];
   return nil;
}] delay:2] subscribeNext:^(id x) {
   NSLog(@"%@",x);
}];
</racsubscriber></code></pre>
</li>
</ul>
</li>
<li><p>1.9 ReactiveCocoa操作方法之重复。</p>
<ul>
<li><p><code>retry</code>重试 ：只要失败，就会重新执行创建信号中的block,直到成功.</p>
<pre><code>
__block int i = 0;
[[[RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
  if (i == 10) {
      [subscriber sendNext:@1];
  }else{
      NSLog(@"接收到错误");
      [subscriber sendError:nil];
  }
  i++;
  return nil;
}] retry] subscribeNext:^(id x) {
  NSLog(@"%@",x);
} error:^(NSError *error) {
}];
</racsubscriber></code></pre>
</li>
<li><p><code>replay</code>重放：当一个信号被多次订阅,反复播放内容</p>
<pre><code>
RACSignal *signal = [[RACSignal createSignal:^RACDisposable*(id<racsubscriber> subscriber) {
     [subscriber sendNext:@1];
     [subscriber sendNext:@2];
     return nil;
}] replay];
[signal subscribeNext:^(id x) {
     NSLog(@"第一个订阅者%@",x);
}];
[signal subscribeNext:^(id x) {
     NSLog(@"第二个订阅者%@",x);
}];
</racsubscriber></code></pre>
</li>
<li><p><code>throttle</code>节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</p>
<pre><code>
RACSubject *signal = [RACSubject subject];
_signal = signal;
// 节流，在一定时间（1秒）内，不接收任何信号内容，过了这个时间（1秒）获取最后发送的信号内容发出。
[[signal throttle:1] subscribeNext:^(id x) {
  NSLog(@"%@",x);
}];
</code></pre>




</li>
</ul>
</li>
</ul>
<h3 id="2-介绍MVVM架构思想。"><a href="#2-介绍MVVM架构思想。" class="headerlink" title="2.介绍MVVM架构思想。"></a>2.介绍MVVM架构思想。</h3><ul>
<li>2.1 程序为什么要架构：便于程序员开发和维护代码</li>
<li>2.2 常见的架构思想:<ul>
<li><code>MVC</code> M:模型 V:视图 C:控制器</li>
<li><code>MVVM</code> M:模型 V:视图+控制器 VM:视图模型</li>
<li><code>MVCS</code> M:模型 V:视图 C:控制器 C:服务类</li>
<li><code>VIPER</code> V:视图 I:交互器 P:展示器 E:实体 R:路由 (<a href="http://www.cocoachina.com/ios/20140703/9016.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20140703/9016.html</a>)</li>
</ul>
</li>
<li>2.3 MVVM介绍<ul>
<li><code>模型</code>(M):保存视图数据。</li>
<li><code>视图+控制器</code>(V):展示内容 + 如何展示</li>
<li><code>视图模型</code>(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。</li>
</ul>
</li>
</ul>
<h3 id="3-ReactiveCocoa-MVVM-实战一：登录界面"><a href="#3-ReactiveCocoa-MVVM-实战一：登录界面" class="headerlink" title="3.ReactiveCocoa + MVVM 实战一：登录界面"></a>3.ReactiveCocoa + MVVM 实战一：登录界面</h3><ul>
<li><p>3.1 需求+分析+步骤</p>
<pre><code>
  /* 需求：1.监听两个文本框的内容，有内容才允许按钮点击
      2.默认登录请求.

 用MVVM：实现，之前界面的所有业务逻辑
 分析：1.之前界面的所有业务逻辑都交给控制器做处理
      2.在MVVM架构中把控制器的业务全部搬去VM模型，也就是每个控制器对应一个VM模型.

 步骤：1.创建LoginViewModel类，处理登录界面业务逻辑.
      2.这个类里面应该保存着账号的信息，创建一个账号Account模型
      3.LoginViewModel应该保存着账号信息Account模型。
      4.需要时刻监听Account模型中的账号和密码的改变，怎么监听？
      5.在非RAC开发中，都是习惯赋值，在RAC开发中，需要改变开发思维，由赋值转变为绑定，可以在一开始初始化的时候，就给Account模型中的属性绑定，并不需要重写set方法。
      6.每次Account模型的值改变，就需要判断按钮能否点击，在VM模型中做处理，给外界提供一个能否点击按钮的信号.
      7.这个登录信号需要判断Account中账号和密码是否有值，用KVO监听这两个值的改变，把他们聚合成登录信号.
      8.监听按钮的点击，由VM处理，应该给VM声明一个RACCommand，专门处理登录业务逻辑.
      9.执行命令，把数据包装成信号传递出去
      10.监听命令中信号的数据传递
      11.监听命令的执行时刻
*/
</code></pre>
</li>
<li><p>3.2 控制器的代码</p>
<pre><code>
  @interface ViewController ()
  @property (nonatomic, strong) LoginViewModel *loginViewModel;
  @property (weak, nonatomic) IBOutlet UITextField *accountField;
  @property (weak, nonatomic) IBOutlet UITextField *pwdField;
  @property (weak, nonatomic) IBOutlet UIButton *loginBtn;
  @end
  - (LoginViewModel *)loginViewModel
  {
      if (_loginViewModel == nil) {
          _loginViewModel = [[LoginViewModel alloc] init];
      }
      return _loginViewModel;
  }
  // 视图模型绑定
  - (void)bindModel
  {
      // 给模型的属性绑定信号
      // 只要账号文本框一改变，就会给account赋值
      RAC(self.loginViewModel.account, account) = _accountField.rac_textSignal;
      RAC(self.loginViewModel.account, pwd) = _pwdField.rac_textSignal;
      // 绑定登录按钮
      RAC(self.loginBtn,enabled) = self.loginViewModel.enableLoginSignal;
     // 监听登录按钮点击
      [[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {
          // 执行登录事件
          [self.loginViewModel.LoginCommand execute:nil];
      }];
  }
</code></pre>
</li>
<li><p>3.3 VM的代码</p>
<pre><code>
  @interface LoginViewModel : NSObject
  @property (nonatomic, strong) Account *account;
  // 是否允许登录的信号
  @property (nonatomic, strong, readonly) RACSignal *enableLoginSignal;
  @property (nonatomic, strong, readonly) RACCommand *LoginCommand;
  @end
  @implementation LoginViewModel
  - (Account *)account
  {
      if (_account == nil) {
          _account = [[Account alloc] init];
      }
      return _account;
  }
  - (instancetype)init
  {
      if (self = [super init]) {
          [self initialBind];
      }
      return self;
  }
  // 初始化绑定
  - (void)initialBind
  {
      // 监听账号的属性值改变，把他们聚合成一个信号。
      _enableLoginSignal = [RACSignal combineLatest:@[RACObserve(self.account, account),RACObserve(self.account, pwd)] reduce:^id(NSString *account,NSString *pwd){
          return @(account.length && pwd.length);
      }];
      // 处理登录业务逻辑
      _LoginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {
          NSLog(@"点击了登录");
          return [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
              // 模仿网络延迟
              dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
                  [subscriber sendNext:@"登录成功"];
                  // 数据传送完毕，必须调用完成，否则命令永远处于执行状态
                  [subscriber sendCompleted];
              });
              return nil;
          }];
      }];
      // 监听登录产生的数据
      [_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) {
          if ([x isEqualToString:@"登录成功"]) {
              NSLog(@"登录成功");
          }
      }];
      // 监听登录状态
      [[_LoginCommand.executing skip:1] subscribeNext:^(id x) {
          if ([x isEqualToNumber:@(YES)]) {
              // 正在登录ing...
              // 用蒙版提示
              [MBProgressHUD showMessage:@"正在登录..."];
          }else
          {
              // 登录成功
              // 隐藏蒙版
              [MBProgressHUD hideHUD];
          }
      }];
  }
</racsubscriber></code></pre>


</li>
</ul>
<h3 id="4-ReactiveCocoa-MVVM-实战二：网络请求数据"><a href="#4-ReactiveCocoa-MVVM-实战二：网络请求数据" class="headerlink" title="4.ReactiveCocoa + MVVM 实战二：网络请求数据"></a>4.ReactiveCocoa + MVVM 实战二：网络请求数据</h3><ul>
<li>4.1 接口：这里先给朋友介绍一个免费的网络数据接口，豆瓣。可以经常用来练习一些网络请求的小Demo.</li>
<li><p>4.2 需求+分析+步骤</p>
<pre><code>
/*
  需求：请求豆瓣图书信息，url:https://api.douban.com/v2/book/search?q=基础

  分析：请求一样，交给VM模型管理

  步骤:
      1.控制器提供一个视图模型（requesViewModel），处理界面的业务逻辑
      2.VM提供一个命令，处理请求业务逻辑
      3.在创建命令的block中，会把请求包装成一个信号，等请求成功的时候，就会把数据传递出去。
      4.请求数据成功，应该把字典转换成模型，保存到视图模型中，控制器想用就直接从视图模型中获取。
      5.假设控制器想展示内容到tableView，直接让视图模型成为tableView的数据源，把所有的业务逻辑交给视图模型去做，这样控制器的代码就非常少了。
*/
</code></pre>
</li>
<li><p>4.3 控制器代码</p>
<pre><code>
  @interface ViewController ()
  @property (nonatomic, weak) UITableView *tableView;
  @property (nonatomic, strong) RequestViewModel *requesViewModel;
  @end
  @implementation ViewController
  - (RequestViewModel *)requesViewModel
  {
      if (_requesViewModel == nil) {
          _requesViewModel = [[RequestViewModel alloc] init];
      }
      return _requesViewModel;
  }
  - (void)viewDidLoad {
      [super viewDidLoad];
      // Do any additional setup after loading the view, typically from a nib.
      // 创建tableView
      UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds];
      tableView.dataSource = self.requesViewModel;
      self.requesViewModel.tableView = tableView;
      [self.view addSubview:tableView];
      // 执行请求
      [self.requesViewModel.reuqesCommand execute:nil];

  }
  @end
</code></pre>
</li>
<li><p>4.4 视图模型(VM)代码</p>
<pre><code>
  @interface RequestViewModel : NSObject<uitableviewdatasource>
  // 请求命令
  @property (nonatomic, strong, readonly) RACCommand *reuqesCommand;
  //模型数组
  @property (nonatomic, strong, readonly) NSArray *models;
  // 控制器中的view
  @property (nonatomic, weak) UITableView *tableView;
  @end
  @implementation RequestViewModel
  - (instancetype)init
  {
      if (self = [super init]) {
          [self initialBind];
      }
      return self;
  }
  - (void)initialBind
  {
      _reuqesCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {
          RACSignal *requestSignal = [RACSignal createSignal:^RACDisposable *(id<racsubscriber> subscriber) {
              NSMutableDictionary *parameters = [NSMutableDictionary dictionary];
              parameters[@"q"] = @"基础";
              // 发送请求
              [[AFHTTPRequestOperationManager manager] GET:@"https://api.douban.com/v2/book/search" parameters:parameters success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {
                  NSLog(@"%@",responseObject);
                  // 请求成功调用
                  // 把数据用信号传递出去
                  [subscriber sendNext:responseObject];
                  [subscriber sendCompleted];
              } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) {
                  // 请求失败调用
              }];
              return nil;
          }];
          // 在返回数据信号时，把数据中的字典映射成模型信号，传递出去
          return [requestSignal map:^id(NSDictionary *value) {
              NSMutableArray *dictArr = value[@"books"];
              // 字典转模型，遍历字典中的所有元素，全部映射成模型，并且生成数组
              NSArray *modelArr = [[dictArr.rac_sequence map:^id(id value) {
                  return [Book bookWithDict:value];
              }] array];
              return modelArr;
          }];
      }];
      // 获取请求的数据
      [_reuqesCommand.executionSignals.switchToLatest subscribeNext:^(NSArray *x) {
          // 有了新数据，刷新表格
          _models = x;
          // 刷新表格
          [self.tableView reloadData];
      }];
  }
  #pragma mark - UITableViewDataSource
  - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
  {
      return self.models.count;
  }
  - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
  {
      static NSString *ID = @"cell";
      UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];
      if (cell == nil) {

          cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];
      }
      Book *book = self.models[indexPath.row];
      cell.detailTextLabel.text = book.subtitle;
      cell.textLabel.text = book.title;
      return cell;
  }
  @end
</racsubscriber></uitableviewdatasource></code></pre>    


</li>
</ul>
<!-- more -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot;&gt;ReactiveCocoa&lt;/a&gt;(简称为RAC),上一篇文章，我们简单的对RAC有个初步的了解，在开发中，我们实际用到的基本都是上一篇所介绍的知识，这篇文章我们对RAC有个深入的了解。&lt;/p&gt;
    
    </summary>
    
      <category term="ReactiveCocoa" scheme="http://www.guiyongdong.com/categories/ReactiveCocoa/"/>
    
    
      <category term="ReactiveCocoa" scheme="http://www.guiyongdong.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
</feed>
