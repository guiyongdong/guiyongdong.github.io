<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>贵大头的博客</title>
  <subtitle>贵大头的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.guiyongdong.com/"/>
  <updated>2017-03-23T03:41:24.000Z</updated>
  <id>http://www.guiyongdong.com/</id>
  
  <author>
    <name>贵永冬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一天一Android之RecyclerView</title>
    <link href="http://www.guiyongdong.com/2017/03/22/%E4%B8%80%E5%A4%A9%E4%B8%80Android%E4%B9%8BRecyclerView/"/>
    <id>http://www.guiyongdong.com/2017/03/22/一天一Android之RecyclerView/</id>
    <published>2017-03-22T09:29:15.000Z</published>
    <updated>2017-03-23T03:41:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>ListView由于其强大的功能，已经能满足我们绝大功能的开发，但是，当我们的数据比较复杂，条目也比较复杂的时候，如果我们优化的不好，那么ListView的性能就会非常差。还有，ListView只能实现数据纵向滚动的效果，如果我们想实现横向滚动的话，ListView做不到。</p>
<p>为此，Android提供了一个更强大的滚动控件——RecyclerView。它可以说是一个增强版的ListView，不仅可以轻松实现和ListView同样的效果，还优化了ListView中存在的各种不足之处，目前Android官方更加推荐我们使用RecyclerView。</p>
<a id="more"></a>
<h3 id="RecyclerView的基本用法"><a href="#RecyclerView的基本用法" class="headerlink" title="RecyclerView的基本用法"></a>RecyclerView的基本用法</h3><p>和约束布局一样，RecyclerView也属于新增的控件，所以我们需要添加在build.gradle中相应的依赖库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    ...</div><div class="line">    compile <span class="string">'com.android.support:recyclerview-v7:25.3.0'</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="纵向滚动"><a href="#纵向滚动" class="headerlink" title="纵向滚动"></a>纵向滚动</h5><p>我们先来模拟一下ListView的纵向滚动</p>
<p>创建RecyclerView的布局：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.guiyongdong.recyclerviewdemo.MainActivity"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_marginRight</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">android:layout_marginTop</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">android:layout_marginBottom</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/recyclerView"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>同样的，我们创建和上一篇ListView一样的dog_item布局和Dog实体类，这里就不再贴出代码。</p>
<p>创建适配器DogAdapter:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">DogAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;Dog&gt; mDogList;</div><div class="line">    </div><div class="line">    <span class="comment">//定义一个内部类ViewHolder，它继承于RecyclerView.ViewHolder</span></div><div class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</div><div class="line">        ImageView dogImage;</div><div class="line">        TextView dogName;</div><div class="line">        <span class="comment">//构造函数，需要传入一个View</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(view);</div><div class="line">            dogImage = (ImageView) view.findViewById(R.id.dogImage);</div><div class="line">            dogName = (TextView) view.findViewById(R.id.dogName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//构造函数，需要知道数据源</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">DogAdapter</span><span class="params">(List&lt;Dog&gt; dogList)</span></span>&#123;</div><div class="line">        mDogList = dogList;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写父类方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.dog_item,parent,<span class="keyword">false</span>);</div><div class="line">        ViewHolder viewHolder = <span class="keyword">new</span> ViewHolder(view);</div><div class="line">        <span class="keyword">return</span> viewHolder;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写父类方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mDogList.size();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写父类方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        Dog dog = mDogList.get(position);</div><div class="line">        holder.dogName.setText(dog.getName());</div><div class="line">        holder.dogImage.setImageResource(dog.getImage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是看上去和我们之前写的ListView的适配器不一样，感觉好复杂啊。</p>
<ul>
<li>首先我们定义了一个内部类ViewHolder，ViewHolder继承于RecyclerView.ViewHolder。然后ViewHolder的构造函数中需要传入一个View参数，通常这个View就是我们的item条目，我们就可以使用<code>findViewById()</code>方法来获取布局中的ImageView和TextView的实例了。</li>
<li>在DogAdapter中也定义了一个构造函数，需要传入一个Dog的list集合，因为Adapter需要知道现实哪些数据。</li>
<li>由于DogAdapter是继承于RecyclerView.ViewHolder，所以我们需要重新父类的三个方法：<code>onCreateViewHolder()</code>、<code>OnBindViewHolder()</code>和<code>getItemCount()</code>。</li>
<li><code>onCreateViewHolder()</code> 这个方法是用于创建ViewHolder实例，我们在这个方法中会加载item条目布局，并创建ViewHolder实例对象，并将条目View传入到ViewHolder的构造函数中，最后返回ViewHolder。</li>
<li><code>OnBindViewHolder()</code> 这个方法是用于对item条目的数据进行赋值，这个方法会在每个条目滚动到屏幕内的时候执行，这里我们根据position获取到Dog实例，并将数据设置给ViewHolder的dogImage和dogName。</li>
<li><code>getItemCount()</code> 这个方法是告诉RecyclerView一共有多少行的item，我们这里直接返回<code>mDogList</code>的长度。</li>
</ul>
<p>我们看看在<code>MainActivity</code>中如何使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> RecyclerView mRecyclerView;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Dog&gt; mDogArrayList;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        initDogList();</div><div class="line">        mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView);</div><div class="line">        <span class="comment">//创建一个布局管理类</span></div><div class="line">        LinearLayoutManager linearLayoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</div><div class="line">        mRecyclerView.setLayoutManager(linearLayoutManager);</div><div class="line">        <span class="comment">//创建Adapter</span></div><div class="line">        DogAdapter dogAdapter = <span class="keyword">new</span> DogAdapter(mDogArrayList);</div><div class="line">        mRecyclerView.setAdapter(dogAdapter);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initDogList</span><span class="params">()</span> </span>&#123;</div><div class="line">        mDogArrayList = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</div><div class="line">            Dog dog = <span class="keyword">new</span> Dog();</div><div class="line">            dog.setName(<span class="string">"小狗"</span>+i);</div><div class="line">            dog.setImage(R.drawable.dog);</div><div class="line">            mDogArrayList.add(dog);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里和ListView有些不同，我们在这里创建了一个<code>LinearLayoutManager</code>实例对象，<code>LinearLayoutManager</code>是线性布局的意思，可以实现和ListView类似的效果。</p>
<p>最终运行效果：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android12.png?raw=true" width="375"><br></div>


<h5 id="横向滚动"><a href="#横向滚动" class="headerlink" title="横向滚动"></a>横向滚动</h5><p>我们知道ListView不能实现横向滚动，那么RecyclerView如何实现的呢？</p>
<p>这里我们需要先修改一下dog_item中的布局:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/dogImage"</span></div><div class="line">        <span class="attr">android:src</span>=<span class="string">"@drawable/dog"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/dogName"</span></div><div class="line">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"8dp"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></div><div class="line">        <span class="attr">android:gravity</span>=<span class="string">"center"</span>/&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们把布局方式改为垂直方向，并把宽度设置为根据内容的宽度调整，由于我把TextView的宽度设置为match_parent，所以item的宽度会根据图片的宽度缩放。</p>
<p>这里我们只在<code>MainActivity</code>中加入一行代码<code>linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL)</code>就可实现横向滚动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> RecyclerView mRecyclerView;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Dog&gt; mDogArrayList;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        initDogList();</div><div class="line">        mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView);</div><div class="line">        <span class="comment">//创建一个布局管理类</span></div><div class="line">        LinearLayoutManager linearLayoutManager = <span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>);</div><div class="line">        linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);</div><div class="line">        mRecyclerView.setLayoutManager(linearLayoutManager);</div><div class="line">        <span class="comment">//创建Adapter</span></div><div class="line">        DogAdapter dogAdapter = <span class="keyword">new</span> DogAdapter(mDogArrayList);</div><div class="line">        mRecyclerView.setAdapter(dogAdapter);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initDogList</span><span class="params">()</span> </span>&#123;</div><div class="line">        mDogArrayList = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</div><div class="line">            Dog dog = <span class="keyword">new</span> Dog();</div><div class="line">            dog.setName(<span class="string">"小狗"</span>+i);</div><div class="line">            dog.setImage(R.drawable.dog);</div><div class="line">            mDogArrayList.add(dog);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>LinearLayoutManager</code>的滚动方向默认是垂直方向，我们只需要调用它的<code>setOrientation</code>方法来设置布局的排列方向即可，<code>LinearLayoutManager.HORIZONTAL</code>表示横向排列，<code>LinearLayoutManager.VERTICAL</code>表示纵向排列。</p>
<p>效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android13.png?raw=true" width="375"><br></div>


<p>除了<code>LinearLayoutManager</code>外，RecyclerView还为我们提供了<code>GridLayoutManager</code>和<code>StaggeredGridLayoutManager</code>这两种内置的布局排列方式。<code>GridLayoutManager</code>可以用于实现网格布局，<code>StaggeredGridLayoutManager</code>可以用于实现瀑布流布局。</p>
<h3 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h3><p>说起瀑布流，学过iOS的都知道，实现瀑布流是多么复杂的事，需要自己实现布局类，并计算坐标。好在Android不一样，它早就给我们提供了瀑布流布局类<code>StaggeredGridLayoutManager</code>，我们来看看它是如何使用的。</p>
<p>我们在创造数据源的时候，需要把文字的多少设置为5-50的随机数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> RecyclerView mRecyclerView;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Dog&gt; mDogArrayList;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        initDogList();</div><div class="line">        mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView);</div><div class="line">        <span class="comment">//创建一个布局管理类</span></div><div class="line">        StaggeredGridLayoutManager staggeredGridLayoutManager = <span class="keyword">new</span> StaggeredGridLayoutManager(<span class="number">3</span>,StaggeredGridLayoutManager.VERTICAL);</div><div class="line">        mRecyclerView.setLayoutManager(staggeredGridLayoutManager);</div><div class="line">        <span class="comment">//创建Adapter</span></div><div class="line">        DogAdapter dogAdapter = <span class="keyword">new</span> DogAdapter(mDogArrayList);</div><div class="line">        mRecyclerView.setAdapter(dogAdapter);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initDogList</span><span class="params">()</span> </span>&#123;</div><div class="line">        mDogArrayList = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</div><div class="line">            Dog dog = <span class="keyword">new</span> Dog();</div><div class="line">            StringBuffer name = <span class="keyword">new</span> StringBuffer(<span class="string">"小狗"</span>);</div><div class="line">            <span class="keyword">int</span> len = random.nextInt(<span class="number">50</span>)+<span class="number">5</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; j++)&#123;</div><div class="line">                name.append(<span class="string">"小狗"</span>);</div><div class="line">            &#125;</div><div class="line">            dog.setName(name.toString());</div><div class="line">            dog.setImage(R.drawable.dog);</div><div class="line">            mDogArrayList.add(dog);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我创建了一个<code>StaggeredGridLayoutManager</code>的实例，<code>StaggeredGridLayoutManager</code>的构造函数需要接收两个参数，第一个参数用于指定布局的列数，传入3表示会把布局分为3列，第二个参数用于指定布局的排列方式，<code>StaggeredGridLayoutManager.VERTICAL</code>表示纵向排列，<code>StaggeredGridLayoutManager.HORIZONTAL</code>表示横向排列。</p>
<p>效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android14.png?raw=true" width="375"><br></div>


<p>想不到，Android的瀑布流实现如此的简单，我们只需要更改布局类就能实现，好方便啊，真的希望iOS也能借鉴Android的这种方式。</p>
<h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><p>RecyclerView并没有提供类似于<code>setOnItemClickListener()</code>这样的注册监听器方法，我们需要自己动手实现点击事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">DogAdapter</span>.<span class="title">ViewHolder</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;Dog&gt; mDogList;</div><div class="line"></div><div class="line">    <span class="comment">//定义一个内部类ViewHolder，它继承于RecyclerView.ViewHolder</span></div><div class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</div><div class="line">        ImageView dogImage;</div><div class="line">        TextView dogName;</div><div class="line">        <span class="comment">//新增一个成员变量 来保存当前item</span></div><div class="line">        View dogView;</div><div class="line">        <span class="comment">//构造函数，需要传入一个View</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ViewHolder</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(view);</div><div class="line">            dogView = view;</div><div class="line">            dogImage = (ImageView) view.findViewById(R.id.dogImage);</div><div class="line">            dogName = (TextView) view.findViewById(R.id.dogName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//构造函数，需要知道数据源</span></div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">DogAdapter</span><span class="params">(List&lt;Dog&gt; dogList)</span></span>&#123;</div><div class="line">        mDogList = dogList;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写父类方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.dog_item,parent,<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">final</span> ViewHolder viewHolder = <span class="keyword">new</span> ViewHolder(view);</div><div class="line">        <span class="comment">//注册item点击事件</span></div><div class="line">        viewHolder.dogView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> position = viewHolder.getAdapterPosition();</div><div class="line">                Dog dog = mDogList.get(position);</div><div class="line">                Toast.makeText(v.getContext(),dog.getName(),Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//注册图片点击事件</span></div><div class="line">        viewHolder.dogImage.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                <span class="keyword">int</span> position = viewHolder.getAdapterPosition();</div><div class="line">                Dog dog = mDogList.get(position);</div><div class="line">                Toast.makeText(v.getContext(),<span class="string">"第"</span>+position+<span class="string">"个狗的头像被点击"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> viewHolder;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写父类方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mDogList.size();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写父类方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        Dog dog = mDogList.get(position);</div><div class="line">        holder.dogName.setText(dog.getName());</div><div class="line">        holder.dogImage.setImageResource(dog.getImage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我先是在ViewHolder中心增一个成员变量<code>dogView</code>来保存当前的item，然后在<code>onCreateViewHolder</code>方法中添加事件监听。通过<code>ViewHolder</code>拿到点击的position，然后就可以获取Dog实例，接下来就可以更加业务来处理了，我们这里只是简单的吐司。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>说了这么多，也只是说了RecyclerView的基本用法，关于RecyclerView的更多用法，还是去查看Android API，好了，今天的总结就到这里。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ListView由于其强大的功能，已经能满足我们绝大功能的开发，但是，当我们的数据比较复杂，条目也比较复杂的时候，如果我们优化的不好，那么ListView的性能就会非常差。还有，ListView只能实现数据纵向滚动的效果，如果我们想实现横向滚动的话，ListView做不到。&lt;/p&gt;
&lt;p&gt;为此，Android提供了一个更强大的滚动控件——RecyclerView。它可以说是一个增强版的ListView，不仅可以轻松实现和ListView同样的效果，还优化了ListView中存在的各种不足之处，目前Android官方更加推荐我们使用RecyclerView。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.guiyongdong.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.guiyongdong.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>一天一Android之ListView</title>
    <link href="http://www.guiyongdong.com/2017/03/20/%E4%B8%80%E5%A4%A9%E4%B8%80Android%E4%B9%8BListView/"/>
    <id>http://www.guiyongdong.com/2017/03/20/一天一Android之ListView/</id>
    <published>2017-03-20T09:31:13.000Z</published>
    <updated>2017-03-22T09:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>说起<code>ListView</code>，就不得不说iOS的<code>UITableView</code>，毫不夸张的说的，放在3年前，如果你去面试的时候，你说你会用<code>UITableView</code>，知道<code>UITableView</code>的代理方法，不用说了，你可以直接来上班了。</p>
<p><code>ListView</code>在Android中开发的重要性不言而喻，学好<code>ListView</code>，我想在以后的列表开发中就不用发愁了。什么是列表开发？这么说吧，在你使用的APP中，80%的都会用到列表开发，比如微信的聊天页，QQ的个人空间页。为何要用列表开发，列表开发的优越在哪里？我今天来一探究竟。</p>
<a id="more"></a>
<h3 id="ListView初体验"><a href="#ListView初体验" class="headerlink" title="ListView初体验"></a>ListView初体验</h3><p>我们先来写个小例子，根据这个小例子我们再做进一步的介绍。我们先在xml中创建一个ListView，这里我直接使用<code>ConstraintLayout</code>约束布局。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"></div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.guiyongdong.listviewdemo2.MainActivity"</span>&gt;</div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"368dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"495dp"</span></div><div class="line">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">android:layout_marginTop</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">android:layout_marginBottom</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_marginRight</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/listView"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>MainActivity的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ListView mListView;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        mListView = (ListView) findViewById(R.id.listView);</div><div class="line">        String[] data = &#123;<span class="string">"A"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"A"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"A"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"A"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"A"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"A"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</div><div class="line"></div><div class="line">        ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> ArrayAdapter&lt;String&gt;(MainActivity.<span class="keyword">this</span>,android.R.layout.simple_list_item_1,data);</div><div class="line">        mListView.setAdapter(adapter);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android9.png?raw=true" width="375"><br></div>


<h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><p>在Android所有常用的原生控件当中，用法最复杂的应该就是ListView了，它专门用于处理那种内容元素很多，手机屏幕无法展示出所有内容的情况。ListView可以使用列表的形式来展示内容，超出屏幕部分的内容只需要通过手指滑动就可以移动到屏幕内了。</p>
<p>我们先看看ListView的继承体系：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/3278692-0d4f5b5f237acbd6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li><code>android:divider</code> 在列表条目之间显示的图片或者颜色(drawable或color)</li>
<li><code>android:dividerHeight</code> 用来指定divider的高度</li>
<li><code>android:scrollbars</code> 设置滚动条状态，不需要滚动条时，设置为none</li>
<li><code>android:listSelector</code> 设置条目选中后的颜色，可设置为#00000000或者@android:color/transparent 取消选中色</li>
<li><code>android:footerDividersEnabled</code> 当设置为false时，ListView将不会在各个footer之间绘制divider，默认为true</li>
<li><code>android:headerDividersEnabled</code> 当设为false时，ListView将不会在各个header之间绘制divider，默认为true</li>
</ul>
<p>其他继承父类的属性就不说了。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><ul>
<li><code>void addFooterView(View v)</code> 添加一个固定在列表底部的View</li>
<li><code>boolean removeFooterView(View v)</code> 删除一个之前添加的FooterView，参数为欲删除的视图，返回是否删除成功</li>
<li><code>void addHeaderView(View v)</code> 添加一个固定在列表顶部的View</li>
<li><code>boolean removeHeaderView(View v)</code> 删除一个之前添加的HeaderView，参数为欲删除的视图，返回是否删除成功</li>
<li><code>void setAdapter(ListAdapter adapter)</code> 为ListView绑定Adapter</li>
<li><code>ListAdapter getAdapter()</code> 返回ListView正在使用的Adapter</li>
<li><code>void setEmptyView(View emptyView)</code> 当数据的个数为0的时候显示一个提示视图</li>
</ul>
<p>通过上面一个简单的例子我们可以看出，ListView如果想要显示数据，必须需要一个Adapter来适配。Android为什么这么设计呢？如果学习过iOS的同学都知道，我们在使用UITableView的时候，一定会实现它的数据源代理方法，在代理方法中我们会返回条目数和条目View。这种设计方法有效的分离了UITableView和数据源的直接打交道，让数据源的显示交于用户来选择。Android也是如此。</p>
<p>ListView只承担交互和展示工作，至于这些数据来源于哪里，ListView并不关心。于是就有了Adapter这样一个机制的出现。Adapter是适配器的意思，它在ListView和数据源之间起到了一个桥梁的作用，ListView会借助Adapter这个桥梁去访问真正的数据源，因为Adapter的接口都是统一的，因此我们可以通过实现接口来定制各种类型的Adapter。另外系统也为我们实现了一些常用的Adapter，比如我们上面用到的ArrayAdapter等。</p>
<h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><p>我们先来看看继承体系：</p>
<div align="center"><br><img src="http://img.blog.csdn.net/20150626100341626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGl0Z2FveGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center"><br></div>

<p>Adapter定义的抽象函数主要包括：</p>
<ul>
<li><code>void registerDataSetObserver(DataSetObserver observer)</code> 添加数据源变化的observer，如增加、删除等将会执行</li>
<li><code>void unregisterDataSetObserver(DataSetObserver observer)</code>  取消注册的observer</li>
<li><code>int getCount()</code> 显示有多少个数据项 即adapter有多少个条目</li>
<li><code>Object getItem(int position)</code> 返回数据集中position位置所对应的数据项</li>
<li><code>long getItemId(int position)</code> 返回position位置所对应的ID号，通常即为position</li>
<li><code>View getView(int position, View convertView, ViewGroup parent)</code> 核心函数，返回position数据项对应的条目View</li>
</ul>
<p>上个示例我们使用的ArrayAdapter，他只能用来显示TextView，如果我们想显示更多的不同种类的条目，我们需要继承<code>BaseAdapter</code>，并重写相关方法，我们现在来看看如何重写。</p>
<p>先上示例图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android10.png?raw=true"><br></div>


<p>我们新建一个Dog类，有<code>name</code>和<code>imageId</code>两个成员变量，分别表示狗的名字和图片资源（这里使用本地图片）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> imageId;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> imageId)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.imageId = imageId;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">getImageId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> imageId;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在新建一个DogAdapter继承于ArrayAdapter<dog>，因为我们这里的数据不复杂，直接继承ArrayAdapter，如果我们的数据是一个更复杂的嵌套很深的模型，我们可以直接继承BaseAdapter。</dog></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> resourceId;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DogAdapter</span><span class="params">(Context context, <span class="keyword">int</span> resourceId, List&lt;Dog&gt; dogList)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, resourceId, dogList);</div><div class="line">        <span class="comment">// 记录当前布局资源</span></div><div class="line">        <span class="keyword">this</span>.resourceId = resourceId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, @Nullable View convertView, @NonNull ViewGroup parent)</span> </span>&#123;</div><div class="line">        Dog dog = getItem(position);<span class="comment">//获取当前Dog实例</span></div><div class="line">        View view;</div><div class="line">        ViewHolder viewHolder;<span class="comment">//tag缓存</span></div><div class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>)&#123;</div><div class="line">            view = LayoutInflater.from(getContext()).inflate(resourceId,parent,<span class="keyword">false</span>);</div><div class="line">            viewHolder = <span class="keyword">new</span> ViewHolder();</div><div class="line">            viewHolder.mImageView = (ImageView) view.findViewById(R.id.dogImage);</div><div class="line">            viewHolder.mTextView = (TextView) view.findViewById(R.id.dogName);</div><div class="line">            view.setTag(viewHolder);<span class="comment">//设置tag绑定</span></div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            view = convertView;</div><div class="line">            viewHolder = (ViewHolder) view.getTag();</div><div class="line">        &#125;</div><div class="line">        ImageView imageView = viewHolder.mImageView;</div><div class="line">        TextView textView = viewHolder.mTextView;</div><div class="line">        imageView.setImageResource(dog.getImageId());</div><div class="line">        textView.setText(dog.getName());</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</div><div class="line">        ImageView mImageView;</div><div class="line">        TextView mTextView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：我们都知道ListView的强大，它强大就强大在无论我们设置多少条数据源，ListView都不会完全的把这些条目都创建，而是通过复用已经消失在屏幕的条目来展示新的条目。<br>在<code>getView</code>函数中，有个<code>convertView</code>参数，如果它不为空，就表示ListView的缓存池中有可复用的条目，我们直接取来用就行。而且我们还创建了一个内部类<code>ViewHolder</code>，声明了两个属性<code>mImageView</code>和<code>mTextView</code>，我们可以给View设置tag，方便下次给View赋值的时候，不需要再次调用<code>findViewById</code>方法来重新查找属性。</p>
<p>再来看我们如何使用DogAdapter:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ListView mListView;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Dog&gt; mDogArrayList;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="comment">//初始化数据源</span></div><div class="line">        initDogArrayList();</div><div class="line">        mListView = (ListView) findViewById(R.id.listView);</div><div class="line">        DogAdapter dogAdapter = <span class="keyword">new</span> DogAdapter(<span class="keyword">this</span>,R.layout.dog_item,mDogArrayList);</div><div class="line">        mListView.setAdapter(dogAdapter);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">//模拟数据 </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDogArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">        mDogArrayList = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</div><div class="line">            Dog dog = <span class="keyword">new</span> Dog(<span class="string">"小狗"</span>+i,R.drawable.dog);</div><div class="line">            mDogArrayList.add(dog);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h5 id="触摸监听-OnTouchListener"><a href="#触摸监听-OnTouchListener" class="headerlink" title="触摸监听 OnTouchListener"></a>触摸监听 OnTouchListener</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line">mListView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (event.getAction())&#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                <span class="comment">//触摸时操作</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                <span class="comment">//移动是操作</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                <span class="comment">//手指离开时操作</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="滑动监听-OnScrollListener"><a href="#滑动监听-OnScrollListener" class="headerlink" title="滑动监听 OnScrollListener"></a>滑动监听 OnScrollListener</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//滑动监听</span></div><div class="line">mListView.setOnScrollListener(<span class="keyword">new</span> AbsListView.OnScrollListener() &#123;</div><div class="line">    <span class="comment">//滚动状态发生改变</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrollStateChanged</span><span class="params">(AbsListView view, <span class="keyword">int</span> scrollState)</span> </span>&#123;</div><div class="line">       <span class="keyword">switch</span> (scrollState)&#123;</div><div class="line">           <span class="keyword">case</span> SCROLL_STATE_IDLE:</div><div class="line">               <span class="comment">//停止滑动</span></div><div class="line">               Log.d(<span class="string">"gg"</span>,<span class="string">"停止滑动了"</span>);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> SCROLL_STATE_TOUCH_SCROLL:</div><div class="line">               <span class="comment">//正在滚动</span></div><div class="line">               Log.d(<span class="string">"gg"</span>,<span class="string">"正在滑动了"</span>);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">case</span> SCROLL_STATE_FLING:</div><div class="line">               <span class="comment">//手指快速滑动，手指离开屏幕后由于惯性继续滑动</span></div><div class="line">               Log.d(<span class="string">"gg"</span>,<span class="string">"惯性滑动了"</span>);</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">           <span class="keyword">default</span>:</div><div class="line">               <span class="keyword">break</span>;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//滚动时一直调用</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScroll</span><span class="params">(AbsListView view, <span class="keyword">int</span> firstVisibleItem, <span class="keyword">int</span> visibleItemCount, <span class="keyword">int</span> totalItemCount)</span> </span>&#123;</div><div class="line">        Log.d(<span class="string">"gg"</span>,<span class="string">"混动了"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h5 id="条目点击-OnItemClickListener"><a href="#条目点击-OnItemClickListener" class="headerlink" title="条目点击 OnItemClickListener"></a>条目点击 OnItemClickListener</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line">mListView.setOnItemClickListener(<span class="keyword">new</span> AdapterView.OnItemClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View view, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">        Log.d(<span class="string">"gg"</span>,<span class="string">"点击了第"</span>+position+<span class="string">"条目"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="仿微信聊天界面"><a href="#仿微信聊天界面" class="headerlink" title="仿微信聊天界面"></a>仿微信聊天界面</h3><p>说了这么多，再来做一个例子，仿一下微信的聊天界面。</p>
<p>先看布局，这里依旧使用约束布局：</p>
<h5 id="ListView布局"><a href="#ListView布局" class="headerlink" title="ListView布局"></a>ListView布局</h5><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.guiyongdong.listviewdemo2.WXChatActivity"</span>&gt;</div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">ListView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/wx_listView"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">android:layout_marginBottom</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">"@+id/wx_send"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/wx_send"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"44dp"</span></div><div class="line">        <span class="attr">android:layout_marginBottom</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_marginRight</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"发送"</span></div><div class="line">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/wx_editText"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"44dp"</span></div><div class="line">        <span class="attr">android:layout_marginBottom</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_marginRight</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">app:layout_constraintHorizontal_bias</span>=<span class="string">"0.501"</span></div><div class="line">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></div><div class="line">        <span class="attr">app:layout_constraintRight_toLeftOf</span>=<span class="string">"@+id/wx_send"</span></div><div class="line">        <span class="attr">android:hint</span>=<span class="string">"说些什么吧"</span></div><div class="line">        <span class="attr">android:maxLines</span>=<span class="string">"1"</span>/&gt;</div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="item布局"><a href="#item布局" class="headerlink" title="item布局"></a>item布局</h5><p>这里我们把两种布局都定义在一个xml文件中，稍后会根据代码来决定隐藏哪种类型。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">              <span class="attr">android:padding</span>=<span class="string">"10dp"</span>&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!--好友的信息--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/wx_item_left"</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"60dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"60dp"</span></div><div class="line">            <span class="attr">android:src</span>=<span class="string">"@drawable/left_item_image"</span>/&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"你打我试试"</span></div><div class="line">            <span class="attr">android:background</span>=<span class="string">"@drawable/message_left"</span></div><div class="line">            <span class="attr">android:layout_marginLeft</span>=<span class="string">"5dp"</span></div><div class="line">            <span class="attr">android:gravity</span>=<span class="string">"left|center"</span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/wx_item_left_textView"</span>/&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--我的消息--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">RelativeLayout</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/wx_item_right"</span></div><div class="line">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line"></div><div class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"60dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"60dp"</span></div><div class="line">            <span class="attr">android:src</span>=<span class="string">"@drawable/right_item_imgae"</span></div><div class="line">            <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/wx_item_right_image"</span>/&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">            <span class="attr">android:id</span>=<span class="string">"@+id/wx_item_right_textView"</span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"打你就打你"</span></div><div class="line">            <span class="attr">android:background</span>=<span class="string">"@drawable/message_right"</span></div><div class="line">            <span class="attr">android:gravity</span>=<span class="string">"center|left"</span></div><div class="line">            <span class="attr">android:paddingLeft</span>=<span class="string">"8dp"</span></div><div class="line">            <span class="attr">android:paddingRight</span>=<span class="string">"25dp"</span></div><div class="line">            <span class="attr">android:layout_toLeftOf</span>=<span class="string">"@+id/wx_item_right_image"</span></div><div class="line">            /&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<h5 id="消息实体-MSG类"><a href="#消息实体-MSG类" class="headerlink" title="消息实体 MSG类"></a>消息实体 MSG类</h5><p>我们再创建一个消息实体，来存储消息信息。这里我们定义了两种消息类型，<code>TYPE_RECEIVED</code>表示接收的消息，<code>TYPE_SENT</code>表示发送的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WXMsg</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_RECEIVED = <span class="number">0</span>; <span class="comment">//接收类型</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SENT = <span class="number">1</span>; <span class="comment">//发送类型</span></div><div class="line">    <span class="keyword">private</span> String content;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WXMsg</span><span class="params">(String content, <span class="keyword">int</span> type)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> content;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> type;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="消息适配器-WXMsgAdapter"><a href="#消息适配器-WXMsgAdapter" class="headerlink" title="消息适配器 WXMsgAdapter"></a>消息适配器 WXMsgAdapter</h5><p>重点来了，我们会根据消息的类型来决定显示哪种布局方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WXAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> resourceId;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WXAdapter</span><span class="params">(Context context, <span class="keyword">int</span> resourceId, List&lt;WXMsg&gt; msgArrayList)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, resourceId, msgArrayList);</div><div class="line">        <span class="keyword">this</span>.resourceId = resourceId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, @Nullable View convertView, @NonNull ViewGroup parent)</span> </span>&#123;</div><div class="line">        View view;</div><div class="line">        WXViewHolder wxViewHolder;</div><div class="line">        WXMsg msg = (WXMsg) getItem(position);</div><div class="line">        <span class="keyword">if</span> (convertView == <span class="keyword">null</span>)&#123;</div><div class="line">            view = LayoutInflater.from(getContext()).inflate(resourceId,<span class="keyword">null</span>);</div><div class="line">            wxViewHolder = <span class="keyword">new</span> WXViewHolder(view);</div><div class="line">            view.setTag(wxViewHolder);</div><div class="line">        &#125;<span class="keyword">else</span>  &#123;</div><div class="line">            view = convertView;</div><div class="line">            wxViewHolder = (WXViewHolder) view.getTag();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (msg.getType() == WXMsg.TYPE_RECEIVED) &#123;</div><div class="line">            <span class="comment">//如果是收到的消息  显示左边的消息布局，隐藏右边的消息布局</span></div><div class="line">            wxViewHolder.rightLinearLayout.setVisibility(View.GONE);</div><div class="line">            wxViewHolder.leftLinearLayout.setVisibility(View.VISIBLE);</div><div class="line">            wxViewHolder.leftMsg.setText(msg.getContent());</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (msg.getType() == WXMsg.TYPE_SENT) &#123;</div><div class="line">            <span class="comment">//如果是发送的消息  显示右边的消息布局，隐藏左边的消息布局</span></div><div class="line">            wxViewHolder.rightLinearLayout.setVisibility(View.VISIBLE);</div><div class="line">            wxViewHolder.leftLinearLayout.setVisibility(View.GONE);</div><div class="line">            wxViewHolder.rightMsg.setText(msg.getContent());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WXViewHolder</span> </span>&#123;</div><div class="line">        LinearLayout leftLinearLayout;</div><div class="line">        RelativeLayout rightLinearLayout;</div><div class="line">        TextView leftMsg;</div><div class="line">        TextView rightMsg;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WXViewHolder</span><span class="params">(View view)</span></span>&#123;</div><div class="line">            leftLinearLayout = (LinearLayout) view.findViewById(R.id.wx_item_left);</div><div class="line">            rightLinearLayout = (RelativeLayout) view.findViewById(R.id.wx_item_right);</div><div class="line">            leftMsg = (TextView) view.findViewById(R.id.wx_item_left_textView);</div><div class="line">            rightMsg = (TextView) view.findViewById(R.id.wx_item_right_textView);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在WXChatActivity中这样用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WXChatActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ListView mListView;</div><div class="line">    <span class="keyword">private</span> Button mSendButton;</div><div class="line">    <span class="keyword">private</span> EditText mEditText;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;WXMsg&gt; mWXMsgArrayList;</div><div class="line">    <span class="keyword">private</span> WXAdapter mWXAdapter;</div><div class="line">    </div><div class="line">    <span class="comment">//模拟一个回复消息池</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  String[] allmsgArray = &#123;<span class="string">"你信不信我打你！"</span>,<span class="string">"现在的年轻人一言不合就斗图~"</span>,<span class="string">"看过一千多部岛国成人片，从人到动物，大妈到熟妇，御姐到萝莉，会一千多种姿势，上百种插法，告诉你，不要惹我，不然你怎么怀孕的都不知道"</span></div><div class="line">                                            ,<span class="string">"你放学别走！"</span>,<span class="string">"不服是不是 不服来打我啊!"</span>&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_wxchat);</div><div class="line"></div><div class="line">        mListView = (ListView) findViewById(R.id.wx_listView);</div><div class="line">        mSendButton = (Button) findViewById(R.id.wx_send);</div><div class="line">        mEditText = (EditText) findViewById(R.id.wx_editText);</div><div class="line"></div><div class="line">        mWXMsgArrayList = <span class="keyword">new</span> ArrayList&lt;WXMsg&gt;();</div><div class="line">        <span class="comment">//先随机添加一条接收的消息</span></div><div class="line">        addReceivedMsg();</div><div class="line">        mWXAdapter = <span class="keyword">new</span> WXAdapter(<span class="keyword">this</span>,R.layout.wx_item,mWXMsgArrayList);</div><div class="line">        mListView.setAdapter(mWXAdapter);</div><div class="line"></div><div class="line">        <span class="comment">//监听按钮点击</span></div><div class="line">        mSendButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                String content = mEditText.getText().toString();</div><div class="line">                <span class="keyword">if</span> (!<span class="string">""</span>.equals(content))&#123;</div><div class="line">                    <span class="comment">//添加发送信息</span></div><div class="line">                    WXMsg msg = <span class="keyword">new</span> WXMsg(content,WXMsg.TYPE_SENT);</div><div class="line">                    mWXMsgArrayList.add(msg);</div><div class="line">                    <span class="comment">//添加接收信息</span></div><div class="line">                    addReceivedMsg();</div><div class="line">                    <span class="comment">//有消息更新 刷新界面</span></div><div class="line">                    mWXAdapter.notifyDataSetChanged();</div><div class="line">                    <span class="comment">//ListView滚动到最后一行</span></div><div class="line">                    mListView.smoothScrollToPosition(mWXMsgArrayList.size()-<span class="number">1</span>);</div><div class="line">                    <span class="comment">//清空输入框</span></div><div class="line">                    mEditText.setText(<span class="string">""</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//随机添加接收消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addReceivedMsg</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(allmsgArray.length);</div><div class="line">        String content = allmsgArray[index];</div><div class="line">        WXMsg msg = <span class="keyword">new</span> WXMsg(content,WXMsg.TYPE_RECEIVED);</div><div class="line">        mWXMsgArrayList.add(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android11.png?raw=true"><br></div>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>写完微信的小例子，心里的成就感还是很强的，ListView的强大还远不止如此，因为我知道iOS的UITableView的重要性，相信在以后的开发中我会经常和ListView打交道的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起&lt;code&gt;ListView&lt;/code&gt;，就不得不说iOS的&lt;code&gt;UITableView&lt;/code&gt;，毫不夸张的说的，放在3年前，如果你去面试的时候，你说你会用&lt;code&gt;UITableView&lt;/code&gt;，知道&lt;code&gt;UITableView&lt;/code&gt;的代理方法，不用说了，你可以直接来上班了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ListView&lt;/code&gt;在Android中开发的重要性不言而喻，学好&lt;code&gt;ListView&lt;/code&gt;，我想在以后的列表开发中就不用发愁了。什么是列表开发？这么说吧，在你使用的APP中，80%的都会用到列表开发，比如微信的聊天页，QQ的个人空间页。为何要用列表开发，列表开发的优越在哪里？我今天来一探究竟。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.guiyongdong.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.guiyongdong.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>一天一Android之布局</title>
    <link href="http://www.guiyongdong.com/2017/03/18/%E4%B8%80%E5%A4%A9%E4%B8%80Android%E4%B9%8B%E5%B8%83%E5%B1%80/"/>
    <id>http://www.guiyongdong.com/2017/03/18/一天一Android之布局/</id>
    <published>2017-03-18T07:40:40.000Z</published>
    <updated>2017-03-20T10:36:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天主要说说布局。我在看Android的任何内容的时候，心中总要和iOS进行一番比较，就说布局吧，在iOS中，我们一般直接使用<code>frame</code>计算、AutoLayout约束布局。在Android的世界中，一般使用xml布局文件来进行布局，用到的布局方式有四种：线性布局、相对布局、帧布局、百分比布局。还有一种是直接使用图形化添加约束：ConstraintLayout。为何Android的布局方式如此的多，主要是因为Android屏幕的碎片化，不像苹果就那几款手机。</p>
<a id="more"></a>
<h3 id="线性布局-LinearLayout"><a href="#线性布局-LinearLayout" class="headerlink" title="线性布局-LinearLayout"></a>线性布局-LinearLayout</h3><p>LinearLayout又称作线性布局，正如它的名字所描述的一样，这个布局会将它所包含的控件在线性方向上依次排列。线性布局的两种排法:</p>
<ul>
<li><p>从左到右 <code>android:orientation=&quot;horizontal&quot;</code></p>
</li>
<li><p>从上到下 <code>android:orientation=&quot;vertical&quot;</code></p>
</li>
</ul>
<p>默认的布局方向为：horizontal，这里需要注意，如果LinearLayout的排列方向是<code>horizontal</code>，内部的控件就绝不能将宽度指定为<code>match_parent</code>，因为这个控件会把整个水平方向占满。同理，如果排列方向为<code>vertical</code>，就不能将控件的高度设置为<code>match_parent</code>。</p>
<p><strong>layout_gravity</strong></p>
<p><code>layout_gravity</code>用于指定控件在布局中的对齐方式，当LinearLayout的排列方向是<code>vertical</code>时，只有水平方向上(center_horizontal)的对其方式才会生效，同理，当LinearLayout的排列方向是<code>horizontal</code>时，只有垂直方向上(center_vertical)的对其方式才会生效。</p>
<p><strong>layout_weight</strong></p>
<p>layout_weight这个属性允许我们使用比例的方式来指定控件的大小，例如如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"hahahaha"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>/&gt;</div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"heihei"</span></div><div class="line">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>/&gt;</div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>实现的效果：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android6.png?raw=true" width="375"><br></div>

<p>我们看到两个按钮平分了屏幕的水平空间，当然在开发的过程中，我们可以灵活的使用此属性。</p>
<h3 id="相对布局-RelativeLayout"><a href="#相对布局-RelativeLayout" class="headerlink" title="相对布局-RelativeLayout"></a>相对布局-RelativeLayout</h3><p>RelativeLayout又称为相对布局，也是一种常用的布局，能通过相对定位的方式让控件出现在布局的任何位置，所以相对布局的属性非常的多，我们看看：</p>
<ul>
<li><p>属性值是true或false</p>
<ul>
<li><code>android:layout_centerHrizontal</code> 水平居中</li>
<li><code>android:layout_centerVertical</code> 垂直居中</li>
<li><code>android:layout_centerInparent</code> 相对于父元素完全居中</li>
<li><code>android:layout_alignParentBottom</code> 位于父元素的下边缘</li>
<li><code>android:layout_alignParentTop</code> 位于父元素的上边缘</li>
<li><code>android:layout_alignParentLeft</code> 位于父元素的左边缘</li>
<li><code>android:layout_alignParentRight</code> 位于父元素的右边缘</li>
</ul>
</li>
<li><p>属性值是<code>@id/*</code></p>
<ul>
<li><code>android:layout_below</code> 在某元素的下方</li>
<li><code>android:layout_above</code> 在某元素的上方</li>
<li><code>andorid:layout_toRightOf</code> 在某元素的右方</li>
<li><code>android:layout_toLeftOf</code> 在某元素的左方</li>
<li><code>android:layout_alignBottom</code> 和某元素下方对齐</li>
<li><code>android:layout_alignTop</code> 和某元素上方对齐</li>
<li><code>android:layout_alignRight</code> 和某元素右方对齐</li>
<li><code>android:layout_alignLeft</code> 和某元素左方对齐</li>
</ul>
</li>
<li><p>属性值是数值</p>
<ul>
<li><code>android:layout_marginLeft</code> 离某元素左边缘的距离</li>
<li><code>android:layout_marginRight</code> 离某元素右边缘的距离</li>
<li><code>android:layout_marginTop</code> 离某元素上边缘的距离</li>
<li><code>android:layout_marginBottom</code> 离某元素下边缘的距离</li>
</ul>
</li>
</ul>
<p>我写了一个简单的小例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"1"</span></div><div class="line">        /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"2"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"3"</span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/button3"</span></div><div class="line">        <span class="attr">android:layout_centerInParent</span>=<span class="string">"true"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"4"</span></div><div class="line">        <span class="attr">android:layout_alignParentBottom</span>=<span class="string">"true"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"5"</span></div><div class="line">        <span class="attr">android:layout_below</span>=<span class="string">"@id/button3"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"6"</span></div><div class="line">        <span class="attr">android:layout_alignBottom</span>=<span class="string">"@id/button3"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"7"</span></div><div class="line">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"150dp"</span>/&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"8"</span></div><div class="line">        <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:layout_marginLeft</span>=<span class="string">"100dp"</span></div><div class="line">        <span class="attr">android:layout_toRightOf</span>=<span class="string">"@id/button3"</span>/&gt;</div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>运行实例如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android7.png?raw=true" width="375"><br></div>

<p><strong>注意：</strong></p>
<ul>
<li>如果没有定义左右，那么默认在左边，如果没有定义上下，默认在上边。</li>
<li>相同位置，新定义的元素会覆盖旧的元素。例：1被2覆盖了。</li>
<li>4只定义了在父元素的下部，左右没定义，于是默认就在左边了。</li>
<li><code>android:layout_below</code>，在某元素的下部并不意味着就一定是紧随某元素，只是在下部默位置。例如：5是在3的下部，但是是在下部的默认左边。</li>
<li>6为下边缘对其3，7位marginLeft=150dp。</li>
<li>8为多个属性共同定义的结果。首先是在3的右部，然后是垂直居中，然后marginLeft=100dp得到最后位置。</li>
</ul>
<h3 id="帧布局-FrameLayout"><a href="#帧布局-FrameLayout" class="headerlink" title="帧布局-FrameLayout"></a>帧布局-FrameLayout</h3><p>FrameLayout称为帧布局，它相较于前面两种布局就简单多了，这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角。我们可以使用<code>layout_gravity</code>属性来指定控件在布局中的对齐方式，和LinearLayout中的用法是相似的，由于这种布局用到的很少，这里就不说了。</p>
<h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><p>通过学习上面的三种布局，我们会发现，只有LinearLayout支持使用<code>layout_weight</code>属性来实现按比例指定控大小的功能，其他两种布局都不支持。为此，Android引入了一种全新的布局方式——百分比布局。</p>
<p>由于LinearLayout本身已经支持按比例指定控件的大小了，因此百分比布局只为FrameLayout和RelativeLayout进行了功能的扩展，提供了<strong>PercentFrameLayout</strong>和<strong>PercentRelativeLayout</strong>。</p>
<p>不同于上面的三种布局，Android团队将百分比布局定义在了support库中，我们需要在build.gradle中添加百分比布局库的依赖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile <span class="string">'com.android.support:percent:25.0.1'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在导入百分比布局的时候，我们需要把完整的包名路径写出来，然后还必须定义一个app的命名空间，这样才能使用百分比布局的自定义属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">android.support.percent.PercentFrameLayout</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.guiyongdong.layoutdemo.SecondActivity"</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"button1"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"left|right"</span></div><div class="line">        <span class="attr">app:layout_widthPercent</span>=<span class="string">"50%"</span></div><div class="line">        <span class="attr">app:layout_heightPercent</span>=<span class="string">"50%"</span></div><div class="line">        /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"button2"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"right|top"</span></div><div class="line">        <span class="attr">app:layout_widthPercent</span>=<span class="string">"50%"</span></div><div class="line">        <span class="attr">app:layout_heightPercent</span>=<span class="string">"50%"</span></div><div class="line">        /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"button3"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"left|bottom"</span></div><div class="line">        <span class="attr">app:layout_widthPercent</span>=<span class="string">"50%"</span></div><div class="line">        <span class="attr">app:layout_heightPercent</span>=<span class="string">"50%"</span></div><div class="line">        /&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"button4"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"right|bottom"</span></div><div class="line">        <span class="attr">app:layout_widthPercent</span>=<span class="string">"50%"</span></div><div class="line">        <span class="attr">app:layout_heightPercent</span>=<span class="string">"50%"</span></div><div class="line">        /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.percent.PercentFrameLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>注意，我在写这段代码的时候，IDE不会自动提示~</p>
<p>效果图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android8.png?raw=true" width="375"><br></div>



<hr>
<h3 id="约束布局-ConstraintLayout"><a href="#约束布局-ConstraintLayout" class="headerlink" title="约束布局-ConstraintLayout"></a>约束布局-ConstraintLayout</h3><p>看到这个布局我就想到了iOS的AutoLayout，他的用法和iOS的xib添加约束一样，用着也是很方便的。</p>
<p>ConstraintLayout是Android Studio2.2新添加的功能，虽然传统布局也可以使用可视化界面拖动空间布局，但是因为不够灵活，我们还是会选择xml代码来布局。而ConstraintLayout的出现将我们带入可视化布局编程的新纪元，通过建立空间之间的约束，实现布局的构建。这样做有一个很大的优点，就是减少了布局的嵌套，减少了布局渲染的层数，降低了CPU的消耗，提高了程序的性能。总之就是优点很多。</p>
<h5 id="建立依赖"><a href="#建立依赖" class="headerlink" title="建立依赖"></a>建立依赖</h5><p>在使用ConstraintLayout布局之前，我们需要在build.gradle添加依赖，但是，通常情况下不需要我们手动添加，IDE已经为我们自动添加好了。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile <span class="string">'com.android.support.constraint:constraint-layout:1.0.0-beta4'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="切换视图"><a href="#切换视图" class="headerlink" title="切换视图"></a>切换视图</h5><p>点击菜单栏的中的<code>Show Design</code>、<code>Show Blueprint</code>和<code>Show Design + Blueprint</code>按钮可以对操作视图进行切换，如下图所示：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-bef33c37ccb1d63f.gif?imageMogr2/auto-orient/strip" width="375"><br></div>


<h5 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h5><p>我们创建一个按钮，并为它添加约束：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-de183f8df27f879d.gif?imageMogr2/auto-orient/strip" width="375"><br></div>

<p>可以看到，按钮控件有四个方向的约束，如下图所示，按钮的上、下、左、右边上各有一个小圆圈，鼠标可拖动小圆圈到<code>ConstraintLayout</code>，与其添加约束。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-85ab8f622faca3a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>如将按钮下边圆圈拖至<code>ConstraintLayout</code>底部，则按钮移动至底部；再将按钮上边圆圈拖动至<code>ConstraintLayout</code>顶部，垂直方向上有两个约束的按钮控件就会实现垂直居中。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-4de51c14488859f3.gif?imageMogr2/auto-orient/strip"><br></div>

<h5 id="约束位置比例调整"><a href="#约束位置比例调整" class="headerlink" title="约束位置比例调整"></a>约束位置比例调整</h5><p>当然如果<code>ConstraintLayout</code>添加约束仅仅能实现水平、垂直居中，那么它在功能上与RelativeLayout就没有差别了。除了居中，约束还可以设置控件两边到边界之间的距离比例，通过在右侧属性面板中，拖动水平和垂直方向的进度条来调整两边距离的比例。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-5d4d3177e87d6c22.gif?imageMogr2/auto-orient/strip" width="375"><br></div>

<h5 id="控件之间添加约束"><a href="#控件之间添加约束" class="headerlink" title="控件之间添加约束"></a>控件之间添加约束</h5><p>除了与<code>ConstraintLayout</code>添加约束，控件与控件之间同样可以添加约束。如下图所示，在调整按钮宽度后，将两个按钮的左右两边添加约束，然后将下方按钮的上边与上方按钮的下边添加约束，拖动下方的按钮，可设置两个按钮之间的外边距。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-e814c547622d896e.gif?imageMogr2/auto-orient/strip" width="375"><br></div>

<p>通过控件之间添加约束和调整约束距离比例，开发者可实现较为复杂的约束。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-506a4d7ea3a560b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>


<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-02e85c6fcedd4a17.gif?imageMogr2/auto-orient/strip" width="375"><br></div>


<h5 id="调整控件外边距及尺寸"><a href="#调整控件外边距及尺寸" class="headerlink" title="调整控件外边距及尺寸"></a>调整控件外边距及尺寸</h5><p>你可能会发现，在调整控件位置的比例的时候，当进度条滑动至100时，控件未能完全贴上布局的右边界，这是因为控件存在外边距。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-6b0c81f425c3360f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600"><br></div>

<p>这时候可以修改属性面板中的数值来调整控件的外边距大小，如下图所示：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-c32ddd5ce43f0ed1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>在控件尺寸调整上，ConstraintLayout提供了三种模式，在属性面板中点击下图红色框框区域实现模式的切换。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-e1c6a34a875c7d14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>这三种分别为：</p>
<ul>
<li><strong>wrap content</strong></li>
</ul>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-b3b5528ebb36940b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>wrap content模式就是平时常用的根据内容来设定控件尺寸。</p>
<ul>
<li><strong>固定值</strong></li>
</ul>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-4314b554f154e21b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>固定值模式也是平时常用的，通过设定具体数值来确定控件的大小。如下图所示，切换为固定模式后，在下方的layout_width一栏填写具体的宽度数值。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-cac0c176f4f4f49f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<ul>
<li><strong>any size</strong></li>
</ul>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-94472c2f856e43c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>

<p>any size与match parent类似，都是充满整个范围，但是不同点在于match parent充满相对于父容器，而any size是相对于约束条件，即在约束条件下，能填充的范围全部充满，如下图所示：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-38cc760addcdd58b.gif?imageMogr2/auto-orient/strip"><br></div>

<p>这里说明一下，ConstraintLayout其实也有match parent模式，但是因为ConstraintLayout不存在多层嵌套关系，所以match parent这种相对于父容器的模式在ConstraintLayout中很少会使用。</p>
<h5 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h5><p>删除约束有三种方式：</p>
<ul>
<li><strong>删除单个约束</strong></li>
</ul>
<p>将鼠标移动到要删除的约束对应的小圆圈，待小圆圈出现闪烁的红色圈圈时，点击小圆圈即可删除约束。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-fdd60ed653b1dbaa.gif?imageMogr2/auto-orient/strip"><br></div>

<p>除了上面这种删除方法，也可以在属性面板中，将鼠标移动到下图红色框框标记的位置，待出现叉叉图标，点击可删除该约束。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-d604aedaef646425.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>


<ul>
<li><strong>删除单个控件的所有约束</strong></li>
</ul>
<p>用鼠标点击控件，在其左下方会出现一个小叉叉图标，点击小图标即可删除当前控件的所有约束。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-914f40e162960b10.gif?imageMogr2/auto-orient/strip"><br></div>

<ul>
<li><strong>删除当前界面的所有约束</strong></li>
</ul>
<p>点击工具栏中<code>删除所有约束</code>图标的按钮，即可删除当前界面所有的约束。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-99411797db6acd15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br></div>


<h5 id="Guidelines"><a href="#Guidelines" class="headerlink" title="Guidelines"></a>Guidelines</h5><p>学完基本的依赖操作，来看一下ConstraintLayout的进阶用法。这里有一个需求，要求将两个控件合在一起，实现水平居中。如果不使用ConstraintLayout，我们或许会想到用RelativeLayout嵌套LinearLayout来实现。那么在ConstraintLayout这样不存在多布局嵌套的情况下该怎么实现呢？</p>
<p>这时候就提出了Guidelines，GuideLines就如同Photoshop中参考线的概念一样。如下图，创建一个垂直方向的参考线，将其切换至百分比模式，拖动到50%的位置，再将两个控件在左右两侧分别与Guidelines添加约束，然后两个控件的底边相互添加约束即可实现合并居中的效果。此时ConstraintLayout展现了其强大的优势，通过其特性优雅地完成需求。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-a6737f34ac5ad74d.gif?imageMogr2/auto-orient/strip"><br></div>

<p>我们不仅可以创建垂直方向的引导线，还可以创建水平方向上的引导线。</p>
<h5 id="Autoconnect"><a href="#Autoconnect" class="headerlink" title="Autoconnect"></a>Autoconnect</h5><p>或许因为我们是第一次接触ConstraintLayout，所以感觉添加约束的操作很有趣，但是在项目中，当控件数量比较多时，每个控件的每条边都要一个一个添加约束，这样就会拖慢开发效率，所以ConstraintLayout提出了Autoconnect的用法。</p>
<p>如下图所示，单击打开工具栏中Autoconnect功能按钮，将控件拖至屏幕中心，然后约束就会自动添加了。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-1ced9132a90a8aa3.gif?imageMogr2/auto-orient/strip"><br></div>


<p>Autoconnect会根据我们的意图来判断是否添加相应的约束，当然自动添加的约束不一定全是想要的效果，这时候可以关闭Autoconnect，然后手动修改约束。</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-f73b47f9987ff980.gif?imageMogr2/auto-orient/strip"><br></div>


<h5 id="Inference"><a href="#Inference" class="headerlink" title="Inference"></a>Inference</h5><p>Inference与Autoconnect功能相同，都是用于自动添加约束的，但是Inference更加强大。Inference是手动添加约束后，对当前界面所有控件的位置关系添加整体约束关系，感觉和Photoshop里面不同布局中的图像调整好位置后合并可见图层很像。Inference操作如下图所示：</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/291600-72db88ec184210fa.gif?imageMogr2/auto-orient/strip"><br></div>



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Android的布局差不多就这么多，学会这些布局，我想足够能让我在以后的开发中顺利的进行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天主要说说布局。我在看Android的任何内容的时候，心中总要和iOS进行一番比较，就说布局吧，在iOS中，我们一般直接使用&lt;code&gt;frame&lt;/code&gt;计算、AutoLayout约束布局。在Android的世界中，一般使用xml布局文件来进行布局，用到的布局方式有四种：线性布局、相对布局、帧布局、百分比布局。还有一种是直接使用图形化添加约束：ConstraintLayout。为何Android的布局方式如此的多，主要是因为Android屏幕的碎片化，不像苹果就那几款手机。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.guiyongdong.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.guiyongdong.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>一天一Android之Activity</title>
    <link href="http://www.guiyongdong.com/2017/03/17/%E4%B8%80%E5%A4%A9%E4%B8%80Android%E4%B9%8BActivity/"/>
    <id>http://www.guiyongdong.com/2017/03/17/一天一Android之Activity/</id>
    <published>2017-03-17T09:30:01.000Z</published>
    <updated>2017-03-18T07:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来说一说Android四大组件之一的<code>Activity</code>，类似于iOS的<code>UIViewController</code>。当我们新建一个Android项目时，Android Studio默认会为我们创建一个主活动:<code>MainActivity</code>和一个默认的主布局:<code>activity_main.xml</code>。一个活动想要显示在屏幕上，就必须在<code>AndroidManifest.xml</code>中注册。但是这些工作都有IDE帮我们自动完成了。我们来看<code>AndroidManifest.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">          <span class="attr">package</span>=<span class="string">"com.guiyongdong.activitydemo"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">application</span></span></div><div class="line">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></div><div class="line">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></div><div class="line">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></div><div class="line">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</div><div class="line">        </div><div class="line">        <span class="comment">&lt;!--MainActivity--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Activity声明"><a href="#Activity声明" class="headerlink" title="Activity声明"></a>Activity声明</h3><p>我们首先声明了程序的包名<code>package=&quot;com.guiyongdong.listviewdemo&quot;</code>。</p>
<h5 id="lt-application-gt"><a href="#lt-application-gt" class="headerlink" title="&lt;application&gt;"></a><code>&lt;application&gt;</code></h5><p>接下来我们又声明了<code>&lt;application&gt;</code>标签，这个标签标示当前程序的配置，例如我们配置了icon（程序的图标）、label（程序的名称）等。</p>
<h5 id="lt-activity-gt"><a href="#lt-activity-gt" class="headerlink" title="&lt;activity&gt;"></a><code>&lt;activity&gt;</code></h5><p>然后我们又在<code>&lt;application&gt;</code>标签内添加了一个<code>&lt;activity&gt;</code>标签，这个标签就是声明一个活动（Avtivity）。记住，所有的活动都必须声明在<code>&lt;application&gt;</code>标签内。<code>name</code>属性表示声明的是哪个Activity，因为我们之前已经声明过了当前的包名， 所有以后声明的Activity只要在这个包中，我们只需要声明<code>.MainActivity</code>就可以了。其实它的全称还是<code>com.guiyongdong.listviewdemo. MainActivity</code>。 我们又看到在<code>&lt;activity&gt;</code>标签内，我们有声明了一个标签<code>&lt;intent-filter&gt;</code>，来看看它们是什么。</p>
<h5 id="lt-intent-filter-gt"><a href="#lt-intent-filter-gt" class="headerlink" title="&lt;intent-filter&gt;"></a><code>&lt;intent-filter&gt;</code></h5><p><code>&lt;intent-filter&gt;</code>这个标签表示intent过滤器，至于intent是什么，我们待会再说。先来看看它声明了什么类型的过滤器。<br>在<code>&lt;intent-filter&gt;</code>标签内，我们可以声明三种标签，分别是:<code>&lt;action&gt;</code>、<code>&lt;category&gt;</code>和<code>&lt;data&gt;</code>，这三个标签都是可以作为活动的过滤器。这里我们声明了一个<code>&lt;action&gt;</code>：<code>android.intent.action.MAIN</code>和一个<code>&lt;category&gt;</code>：<code>android.intent.category.LAUNCHER</code>，这两个值都是Android SDK提供给我们的，它表示当前活动为主活动，另一个表示当前活动为启动活动，注意着两种类型的过滤器必须放在一起，不让运行不起来~。当然，我们也可以自定义其他过滤器的值，这个在我们说到隐式Intent时会自定义。</p>
<h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent一般可被用于启动活动，启动服务以及发送广播等场景，当前我们主要讲解Activity,所以我们主要看Intent在活动中的应用。</p>
<p>Intent大致可以分为两种：<strong>显式Intent</strong>和<strong>隐式Intent</strong>。</p>
<p>上面我们说到了，如果一个Activity想要作为程序启动时的主Activity，必须声明声明<code>&lt;intent-filter&gt;</code>标签，而且必须在此标签下声明两个值为固定值的<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>。一般情况下我们的程序不可能只有一个活动，如果我们想要再开启一个活动时，该怎么办呢？</p>
<h5 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h5><p>开启另一个Activity的最简单的方式就是使用显式Intent，我本人没有开发过Android，也不知道这种方式在项目中的使用率，但我感觉它的使用率应该不低，因为它太简单了。</p>
<p>例如我又新建了一个Avtivity(SecondActivity)，系统默认为我们在<code>AndroidManifest.xml</code>中注册，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">          <span class="attr">package</span>=<span class="string">"com.guiyongdong.activitydemo"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">application</span></span></div><div class="line">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></div><div class="line">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></div><div class="line">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></div><div class="line">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</div><div class="line">        </div><div class="line">        <span class="comment">&lt;!--MainActivity--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="comment">&lt;!--SecondActivity--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当然，这时候我可以在<code>SecondActivity</code>的标签下声明任何的filter标签，不过现在我不需要声明，因为我现在使用的是显式Intent。我们在<code>MainActivity</code>的布局文件中添加一个按钮，并且添加按钮的点击事件，事件是去打开<code>SecondActivity</code>活动，至于如何布局，以后再说。 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        Button button = (Button) findViewById(R.id.button);</div><div class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            		<span class="comment">//显式启动SecondActivity</span></div><div class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</div><div class="line">                startActivity(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于为何这么写，刚开始我也不明白，好在我有一点java基础，这里奉劝想学习Android的同学，必须打好java基础。</p>
<p>大家可以看到，我在Intent的构造函数中传了两个值，一个是<code>MainActivity.this</code>，一个是<code>SecondActivity.class</code>，它的构造函数为:<code>Intent(Context context, Class&lt;?&gt; cls)</code>，第一个参数是表示启动活动的上下文，第二个参数Class表示指定想要启动的目标活动，通过这个构造函数，我们就能构建出Intent的<code>意图</code>（就是我要去干什么）。然后我们调用<code>startActivity</code>方法，把这个明显的意图传递过去就行了。</p>
<h5 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h5><p>相比于显式Intent，隐式Intent则含蓄很多了，它并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的<code>action</code>和<code>category</code>等信息，让系统去分析这个Intent，并找出合适的活动去启动。</p>
<p>什么叫合适的活动？我们来想一个问题，系统为什么会启动<code>MainActivity</code>作为程序的主界面，是因为我们声明了如下代码:<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在<code>&lt;action&gt;</code>标签中我们指明了当前活动可以响应<code>android.intent.action.MAIN</code>这个action,而<code>&lt;category&gt;</code>标签则包含了一些附加信息，指明当前活动可以响应<code>android.intent.category.LAUNCHER</code>这个category，只有这两个配置同时匹配，这个活动才是合适的活动。</p>
<p>例如我们为<code>SecondActivity</code>添加如下filter：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.guiyongdong.activitydemo.second"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后我修改MainActivity中按钮的点击方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">    		<span class="comment">//隐式启动Intent</span></div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.guiyongdong.activitydemo.second"</span>);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们看到，我直接将action的字符串传了过去，表明想要启动能响应<code>com.guiyongdong.activitydemo.second</code>这个action的活动，我们之前说过，只有action和category同时匹配才能响应，但是这里我们并没有指定category，那是因为<code>android.intent.category.DEFAULT</code>是一种默认的category，在我们调用<code>startActivity</code>方法的时候，会自动的添加这个默认的category到Intent中。</p>
<p>当然，现在我们也可以添加任意自定义的category：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.guiyongdong.activitydemo.second"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.guiyongdong.category.my_second"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在MainActivity中添加如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.guiyongdong.activitydemo.second"</span>);</div><div class="line">        intent.addCategory(<span class="string">"com.guiyongdong.category.my_second"</span>);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们依然能够启动<code>SecondActivity</code>。</p>
<p>当然，我们前面也说到了<code>&lt;data&gt;</code>这个标签，它用于更精确地指定当前活动能响应什么类型的数据，<code>&lt;data&gt;</code>标签中主要可以匹配一下内容：</p>
<ul>
<li>android:scheme 用于指定数据协议部分，如http</li>
<li>android:host 用于指定数据的主机名部分，如www.baidu.com</li>
<li>android:port 用于指定数据的端口部分</li>
<li>android:path 用于指定主机名和端口之后的部分</li>
<li>android:mimeType 用于指定可以处理的数据类型</li>
</ul>
<p>至于详细的该怎么用，大家可以去试试。这里列一下打电话的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</div><div class="line">        intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然，前提是我们在<code>AndroidManifest.xml</code>添加打电话的权限<br><code>&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;</code></p>
<h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><p>当我们启动一个新的Activity的时候，它覆盖在了原来的Activity上，我们想一想，Android是通过上面来管理这些Activity的呢？</p>
<p>这里要说明一种数据结构：栈，栈是一种先进后出的数据结构。我们发现，当我们点击返回键时，最先消失的活动是我们最新添加显示的活动。</p>
<p>Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称为返回栈(Back Stack)。</p>
<h5 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h5><ul>
<li><p>运行状态<br>  当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动。</p>
</li>
<li><p>暂停状态<br>  当一个活动不再处于栈顶位置，但仍是可见的，这时活动就进入了暂停状态，因为有时候开启一个新的活动，这个活动并不是占满整个屏幕的。处于暂停状态的活动仍然是完全活着的，系统也不愿意去回收这种活动，只有在内存极低的情况下，系统才会去考虑回收这种活动。</p>
</li>
<li><p>停止状态<br>  当一个活动不再处于栈顶位置，并且完全不可见时，活动就进入了暂停状态，系统仍然会为此活动保存相应的状态和成员变量，但是，这并不是完全可靠，当内存不足，处于停止状态的活动有可能被系统回收。</p>
</li>
<li><p>销毁状态<br>  当一个活动从返回栈中移除后就成了销毁状态。系统最倾向于回收处于这种状态的活动。</p>
</li>
</ul>
<h5 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h5><p>Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。</p>
<ul>
<li><p>onCreate()<br>  这个方法我们已经见过很多次了，每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。我们应该在这个方法中完成活动的初始化操作，比如加载布局，绑定事件等。</p>
</li>
<li><p>onStart()<br>  这个方法在活动由不可见变为可见的时候调用。</p>
</li>
<li><p>onResume()<br>  这个方法在活动准备好喝用户交互的时候调用。此时活动一定位于返回栈的栈顶，并且处于运行状态。</p>
</li>
<li><p>onPause()<br>  这个方法在系统准备去启动或者恢复另外一个活动的时候调用。通常会在这个方法中奖一些消耗CPU的资源释放掉，但是这个方法的执行速度一定要快，不然会影响到新的活动的使用。</p>
</li>
<li><p>onStop()<br>  这个方法在活动完全不可见的时候调用。它和onPause()方法的区别主要在于，如果启动的新活动是一个对话框式的活动，那么OnPause()方法会得到执行，而onStop()方法并不会执行。</p>
</li>
<li><p>onDestory()<br>  这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</p>
</li>
<li><p>onRestart()<br>  这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</p>
</li>
</ul>
<p>看完以上的7个方法（发现这些方法和iOS好相似啊），可以将活动分为3种生存期。</p>
<ul>
<li><p>完整生存期。活动在onCreate()方法和onDestroy()方法之间所经历的，就是完整生存期。一般情况下，都是在onCreate()中完成各种初始化，在onDestroy()中完成释放内存的操作。</p>
</li>
<li><p>可见生存期。活动在onStart()方法和onStop()方法之间所经历的，就是可见生存期。我们可以通过这两个方法，合理的管理那些对用户可见的资源。</p>
</li>
<li><p>前台生存期。活动在onResume()方法和onPause()方法之间所经历的就是前台生存期。</p>
</li>
</ul>
<p>如图，完整的描述了Activity的整个生命周期：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android5.jpg?raw=true"><br></div>

<h3 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h3><p>活动的启动模式一共有4种，分别是standard、singleTop、singleTask和singleInstance。可以在<code>AndroidManifest.xml</code>通过给<code>&lt;activity&gt;</code>标签指定<code>android:launchMode</code>属性来选择启动模式。</p>
<h5 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h5><p>standard是活动的默认启动模式，每当启动一个新的活动，它都会在返回栈中如栈，每次启动都会创建该活动的一个新的实例。</p>
<h5 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h5><p>加入我们在<code>SecondActivity</code>活动中再启动一个<code>SecondActivity</code>，这时候系统是不会再去创建一个新的<code>SecondActivity</code>活动的。singleTop模式下，当启动活动时如果发现返回栈的栈顶已经是该类型的活动，则认为可以直接使用它，不会再去创建新的活动实例。</p>
<h5 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h5><p>使用singleTask可以很好的解决重复创建栈顶活动的问题，每次启动该活动时系统首先会在返回栈中检查是否有存在该活动的实例，如果发现已经存在则直接使用该实例，并把这个活动之上的所有活动统统出栈，如果没有发现，就会创建一个新的活动实例。</p>
<h5 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h5><p>singleInstance不同于上面的三种模式，它表示活动会启用一个新的返回栈来管理这个活动，因为程序中可以存在多个返回栈。一般情况下，我们希望几个程序共享某个活动时会使用到此模式。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于Activity的知识还有很多，只有在开发中才能遇到各种问题，继续吧，骚年~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来说一说Android四大组件之一的&lt;code&gt;Activity&lt;/code&gt;，类似于iOS的&lt;code&gt;UIViewController&lt;/code&gt;。当我们新建一个Android项目时，Android Studio默认会为我们创建一个主活动:&lt;code&gt;MainActivity&lt;/code&gt;和一个默认的主布局:&lt;code&gt;activity_main.xml&lt;/code&gt;。一个活动想要显示在屏幕上，就必须在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中注册。但是这些工作都有IDE帮我们自动完成了。我们来看&lt;code&gt;AndroidManifest.xml&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;manifest&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns:android&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;attr&quot;&gt;package&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;com.guiyongdong.activitydemo&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:allowBackup&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:icon&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@mipmap/ic_launcher&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:label&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@string/app_name&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:roundIcon&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@mipmap/ic_launcher_round&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:supportsRtl&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:theme&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@style/AppTheme&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--MainActivity--&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;activity&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;.MainActivity&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;android.intent.action.MAIN&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;android.intent.category.LAUNCHER&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;activity&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.guiyongdong.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.guiyongdong.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>一天一Android之Android系统初窥</title>
    <link href="http://www.guiyongdong.com/2017/03/15/%E4%B8%80%E5%A4%A9%E4%B8%80Android%E4%B9%8BAndroid%E7%B3%BB%E7%BB%9F%E5%88%9D%E7%AA%A5/"/>
    <id>http://www.guiyongdong.com/2017/03/15/一天一Android之Android系统初窥/</id>
    <published>2017-03-15T09:08:17.000Z</published>
    <updated>2017-03-17T09:35:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于前段时间使用ReactNative开发过一个项目，在开发的过程中，会使用到大量的非ReactNative提供的组件和功能。这时候就必须写原生桥接，iOS还好说，毕竟是靠这个吃饭的，可是android就捉襟见肘了。为了向大前端的目标更进一步，我计划开始学习android，为期6个月，我的目标是6个月内起码自己公司的android项目可以上手，当然，如果想成为真正的android开发者，光靠这6个月是不行。还需要大量的实际项目才能锻炼。</p>
<p>值得庆幸的是我在大学主攻的就是java(哈哈，现在也基本上忘的差不多了)。为了打好基础，我买了两本书，一本是《java编程思想》，一本是京东上销量很好的《第二行代码Android》，希望这两本书能够帮到我。另外我也会专门开一个专栏，讲解我学习java的过程。可能在接下来的博客中，我总结的都是基础知识，大神莫嘲笑。</p>
<a id="more"></a>
<h3 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h3><p>Android大概可以分为四层架构：Linux内核层、系统运行库层、应用框架层和应用层。</p>
<p><strong>Linux内核层</strong></p>
<p>Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。</p>
<p><strong>系统运行时库层</strong></p>
<p>这一层通过一些C/C++库来为Android系统提供了主要的特性支持。如SQLite库提供了数据库的支持，OpenGL|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。</p>
<p>同样在这一层还要Android运行时库，主要提供了一些核心库，能是开发者可以使用java来编写Android应用。另外，Android运行时库还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它能让每一个Android应用都能运行在独立的进程中，并且拥有一个自己的Dalvik虚拟机实例。</p>
<p><strong>应用框架层</strong></p>
<p>这一层主要提供了构建应用程序时可能用到的各种API，Android自带的一些核心应用就是使用这些API完成的，我们也是通过这些API来完成我们的应用。</p>
<p><strong>应用层</strong></p>
<p>普通用户主要就是和这一层打交道，我们自己开发的应用都是属于这一层的，当然，系统自带的应用也是这一层的。</p>
<p>系统架构图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android1.jpg?raw=true"><br></div>


<h3 id="Android版本"><a href="#Android版本" class="headerlink" title="Android版本"></a>Android版本</h3><p>可能现在应用最低的适配都是从4.0版本开始，目前最高版本是7.1.1，而且谷歌对Android版本的命名都是以甜点命名的。什么牛轧糖、棒棒糖。</p>
<h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>在我没接触Android之前，我的同学都是使用MyEclipse开发的，至于是如何开发的，我不知道，因为当我开始学Android的时候，已经普及了另一个开发工具：<strong>Android Studio</strong>。当然，只有IDE是不行的，还得有<strong>JDK</strong>、<strong>Android SDK</strong>。</p>
<p>如果使用Android Studio，你也可以使用studio自带的工具进行下载各个版本的SDK。如图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android2.png?raw=true"><br></div>

<p>当然，SDK的目录你可以随便选。</p>
<h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p>至于该如何创建项目，我就不说了。创建完项目以后切换到Project模式下，就是项目的真实目录了。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android3.png?raw=true"><br></div>

<p>下面来看看这些目录或者文件都是干什么的：</p>
<p><strong>.gradle和.idea</strong> </p>
<p>这两个目录下放置的都是Android Studio自动生成的一些文件，我们无须关心，也不要去编辑。</p>
<p><strong>app</strong></p>
<p>这个目录才是我们以后经常使用和编辑的，一会再说它。</p>
<p><strong>build</strong></p>
<p>这个目录也不需要关心，它主要包含了一些在编译时自动生成的文件。</p>
<p><strong>gradle</strong></p>
<p>这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认没有启动gradle wrapper的方式，如果需要打开，可以点击 File-&gt;Other Settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Gradle 进行配置。</p>
<p><strong>.gitignore</strong></p>
<p>设置git忽略哪些文件</p>
<p><strong>build.gradle</strong></p>
<p>这个文件时全局的gradle构建脚本，通常这个文件中的内容是不需要修改的，我只知道gradle是构建工具，至于gradle更多的信息，我还得再研究一下。</p>
<p><strong>gradle.properties</strong></p>
<p>这个文件时全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。</p>
<p><strong>gradlew和gradlew.bat</strong></p>
<p>这两个文件时用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用，gradlew.bat是在Windows系统中使用的。</p>
<p><strong>ListViewDemo.iml</strong></p>
<p>这个文件的名字和我们的项目名字是一样的，不固定。一般不用动。</p>
<p><strong>local.properties</strong></p>
<p>这个文件用于指定Android SDK路径，一般我们不动，除非你的SDK本地路径改变了。</p>
<p><strong>settings.gradle</strong></p>
<p>这个文件用于指定项目中所引入的模块，因为当前项目就一个模块：app，在以后可能我们还会引入其他模块，一般IDE帮我们自动导入。</p>
<h4 id="app"><a href="#app" class="headerlink" title="app"></a>app</h4><p>看了整个工程的目录，感觉有用的不是很多，好多都是和gradle或者配置有关。其实，真正需要我们关心的只有app这个目录。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android4.png?raw=true"><br></div>

<p><strong>build</strong></p>
<p>这个目录和外层的build目录类似，主要也是包含了一些在编译时生成的文件，不过它里面的内容更复杂，也不需要管。</p>
<p><strong>libs</strong></p>
<p>如果项目中使用到了第三方的jar包，就需要把这些jar包都放在libs录下，放在这个目录下的jar包都会被自动添加到构建路径中去。</p>
<p><strong>androidTest</strong></p>
<p>这个一看就是用来编写测试用例的，一些小公司可能也不写测试代码的。</p>
<p><strong>java</strong></p>
<p>毫无疑问，java目录是放置我们所有java代码的地方，以后所有的代码都在里面。</p>
<p><strong>res</strong></p>
<p>这个目录下的内容比较多，简单所，就是放各种资源的，图片，布局，字符串等资源。图片放到drawable文件下，布局放置layout下，字符串放在values下。</p>
<p><strong>AndroidMainfest.xml</strong></p>
<p>这个文件很重要，是整个Android的配置文件，包括程序中使用到的所有四大组件都需要在这个文件注册，另外还有权限声明等。</p>
<p><strong>test</strong></p>
<p>它是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。</p>
<p><strong>.gitignore</strong></p>
<p>忽略文件</p>
<p><strong>app.iml</strong></p>
<p>不需要关心</p>
<p><strong>build.gradle</strong></p>
<p>这个文件也很重要，是app模块的gradle构建脚本，里面会有好多的配置，以后研究到了再说。</p>
<p><strong>proguard-rules.pro</strong></p>
<p>代码混淆规则，主要混淆代码，放在人家破解你的项目。</p>
<p>好了， android项目的大概工程目录就是这样，其实我们会发现，重要的没几个，而且重要的好多都和gradle有关，看来真得好好研究下gradle是什么了。</p>
<h3 id="build-gradle文件"><a href="#build-gradle文件" class="headerlink" title="build.gradle文件"></a>build.gradle文件</h3><p>在整个项目中，一共有连个build.gradle文件。我们先来看看最外层的build.gradle文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.3.0'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些代码都是自动生成的，我们发现在两个闭包中都声明了<code>jcenter()</code>，它是一个代码托管仓库，很多android开源项目都会托管到jcenter上。只要声明它，就可以引用jcenter上的托管的项目。</p>
<p>在<code>dependencies</code>闭包中，还声明了<code>classpath</code>，这个主要是声明gradle插件的，因为gradle不仅仅为android工作，还为java等项目工作，所有我们要声明使用哪个包中的gradle工具。例如我们声明了<code>com.android.tools.build:gradle:2.3.0</code>，2.3.0是此插件的版本号。</p>
<p>再来看看app下的<code>build.gradle</code>文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">apply plugin: <span class="string">'com.android.application'</span></div><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion <span class="number">25</span></div><div class="line">    buildToolsVersion <span class="string">"25.0.1"</span></div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId <span class="string">"com.guiyongdong.listviewdemo"</span></div><div class="line">        minSdkVersion <span class="number">15</span></div><div class="line">        targetSdkVersion <span class="number">25</span></div><div class="line">        versionCode <span class="number">1</span></div><div class="line">        versionName <span class="string">"1.0"</span></div><div class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            <span class="function">minifyEnabled <span class="keyword">false</span></span></div><div class="line">            proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></div><div class="line">    <span class="title">androidTestCompile</span><span class="params">(<span class="string">'com.android.support.test.espresso:espresso-core:2.2.2'</span>, &#123;</span></div><div class="line">        exclude group: <span class="string">'com.android.support'</span>, <span class="keyword">module</span>: <span class="string">'support-annotations'</span></div><div class="line">    &#125;)</div><div class="line">    compile 'com.android.support:appcompat-v7:25.0.1'</div><div class="line">    compile 'com.android.support.constraint:constraint-layout:1.0.0-beta4'</div><div class="line">    compile 'com.android.support:recyclerview-v7:25.0.1'</div><div class="line">    testCompile 'junit:junit:4.12'</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咋一看，这个文件好复杂啊，别急，我们一行一行的看。</p>
<p><code>com.android.application</code> 表示这是一个应用程序模块，<code>com.android.library</code> 表示这是一个库模块，他俩最大的区别就是，一个可以直接运行，一个只能作为代码库依附于别的应用程序模块来运行。</p>
<p>接下来是一个大的android闭包，我们看看它都代表什么。</p>
<p><code>compileSdkVersion</code>: 用于指定项目的编译版本，我们这里指定25，表示使用Android 7.1.1来编译，如果你不知道具体使用哪个版本来编译，你可以直接看此文章的第一张图，或者你也可以在Android Studio-&gt;Preferences 直接搜索Android SDK 来查看版本情况。</p>
<p><code>buildToolsVersion</code>: 用来指定项目构建工具的版本，如果有新版本时，Android Studio会进行提升。</p>
<p><code>applicationId</code>: 当前项目的包名</p>
<p><code>minSdkVersion</code>: 最低支持的Android系统版本</p>
<p><code>targetSdkVersion</code>: 这个表示你在该目标版本上已经做过充分的测试，系统将会为你的应用程序启用一些最新的功能和特性，比如你设置成23或者更高，系统会为你的应用程序启用运行时权限，如果你设置成22，那么Android 6.0的功能你就用不了。</p>
<p><code>versionCode</code>: 当前版本号</p>
<p><code>versionName</code>: 当前项目的版本名 </p>
<p><code>testInstrumentationRunner</code>: 测试的一些东西</p>
<p>我们再来看看<code>buildTypes</code>闭包，buildTypes闭包用于指定生成安装文件的相关配置，通常他包含两个子包：<code>release</code>和<code>debug</code>。一个表示生成环境，一个表示测试环境，debug默认可以不写。我们看看<code>release</code>包下的具体内容</p>
<p><code>minifyEnabled</code>: 用于指定是否对代码进行混淆<br><code>proguardFiles</code>: 混淆时使用的文件</p>
<p>我们再来看看<code>dependencies</code>包，它表示当前项目所有的依赖关系，通常Android Studio项目一共有3种依赖方式：<strong>本地依赖</strong>、<strong>库依赖</strong>、<strong>远程依赖</strong>。本地依赖就是jar包依赖，库依赖是在项目中添加模块，远程依赖是对jcenter库上开源项目的依赖。</p>
<p><code>compile fileTree</code>: 它就是一个本地依赖声明，表示将libs目录下的所有的.jar后缀的文件都添加到构建路径中去。</p>
<p><code>compile</code>: 这个则是远程依赖，</p>
<p>还有一种库依赖，写法为<code>compile project(&#39;:helper&#39;)</code>，它表示添加一个名叫helper库的依赖，当然，前提是这个库已经添加到你的项目中。</p>
<p>关于build.gradle的配置还有很多，我想在以后项目复杂了，会遇到的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于前段时间使用ReactNative开发过一个项目，在开发的过程中，会使用到大量的非ReactNative提供的组件和功能。这时候就必须写原生桥接，iOS还好说，毕竟是靠这个吃饭的，可是android就捉襟见肘了。为了向大前端的目标更进一步，我计划开始学习android，为期6个月，我的目标是6个月内起码自己公司的android项目可以上手，当然，如果想成为真正的android开发者，光靠这6个月是不行。还需要大量的实际项目才能锻炼。&lt;/p&gt;
&lt;p&gt;值得庆幸的是我在大学主攻的就是java(哈哈，现在也基本上忘的差不多了)。为了打好基础，我买了两本书，一本是《java编程思想》，一本是京东上销量很好的《第二行代码Android》，希望这两本书能够帮到我。另外我也会专门开一个专栏，讲解我学习java的过程。可能在接下来的博客中，我总结的都是基础知识，大神莫嘲笑。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.guiyongdong.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.guiyongdong.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>转场动画详解</title>
    <link href="http://www.guiyongdong.com/2017/03/06/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.guiyongdong.com/2017/03/06/转场动画详解/</id>
    <published>2017-03-06T02:02:31.000Z</published>
    <updated>2017-03-09T07:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中，页面之间的跳转无外乎由<code>UINavigationController</code>管理的<code>push</code>或者<code>pop</code>操作、以及由<code>UIViewController</code>管理的<code>present</code>和<code>dismiss</code>操作，无论何种操作，iOS原生系统都为我们提供了页面之间的基础跳转动画。但是往往在开发中，由于各种功能需求，iOS原生系统提供的跳转动画并不能满足我们的需求，好在iOS早就给我们提供了一套自定义转场动画的解决方案，这篇文章就来详细了解一下转场动画。在了解这篇文章之前，先看看iOS提供的整个转场框架</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/transition.png?raw=true"><br></div>

<a id="more"></a>
<h2 id="present-dismiss"><a href="#present-dismiss" class="headerlink" title="present/dismiss"></a>present/dismiss</h2><p>首先，我们先来了解一下<code>模态跳转</code>。开发中，假如在A界面需要模态跳转到B界面，通常会这么写：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    PresentBViewController *bVC = [[PresentBViewController alloc] init];</div><div class="line">    [<span class="keyword">self</span> presentViewController:bVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>模态消失当前界面则是这么写：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a>UIViewControllerTransitioningDelegate</h4><p>使用模态跳转时，系统已经为我们写好的跳转的动画，而要想自定义模态跳转动画，则需要一个实现<code>UIViewControllerTransitioningDelegate</code>协议、并实现协议部分方法的对象。在<code>UIViewController.h</code>头文件中，我们可以发现如下定义：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewControllerTransitioningDelegate</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewController</span>(<span class="title">UIViewControllerTransitioning</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerTransitioningDelegate</span>&gt; transitioningDelegate <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>如此，我们则需要定义一个对象，并实现<code>UIViewControllerTransitioningDelegate</code>协议方法，赋值给将要模态跳转的控制器(<code>PresentBViewController</code>)，如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PresentAViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) PresentManager *presentManager;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PresentAViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    PresentBViewController *bVC = [[PresentBViewController alloc] init];</div><div class="line">    <span class="keyword">self</span>.presentManager = [[PresentManager alloc] init];</div><div class="line">    bVC.transitioningDelegate = <span class="keyword">self</span>.presentManager;</div><div class="line">    [<span class="keyword">self</span> presentViewController:bVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>我们先来看看<code>UIViewControllerTransitioningDelegate</code>有哪些协议方法:<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//当使用模态弹出时 会调用此方法 返回一个实现 UIViewControllerAnimatedTransitioning 协议的对象 </span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                                            presentingController:(<span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                                sourceController:(<span class="built_in">UIViewController</span> *)source;</div><div class="line"><span class="comment">//当使用模态消失时 会调用此方法 返回一个实现 UIViewControllerAnimatedTransitioning 协议的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed;</div><div class="line"><span class="comment">// 当使用模态弹出时 会调用此方法 返回一个实现 UIViewControllerInteractiveTransitioning协议的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForPresentation:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</div><div class="line"><span class="comment">// 当使用模态消失时 会调用此方法 返回一个实现 UIViewControllerInteractiveTransitioning协议的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIPresentationController</span> *)presentationControllerForPresentedViewController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                               presentingViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                   sourceViewController:(<span class="built_in">UIViewController</span> *)source;</div></pre></td></tr></table></figure></p>
<p>先来看这两个代理方法：<code>animationControllerForPresentedController:presentingController:sourceController:(UIViewController *)source</code>和<code>animationControllerForDismissedController:(UIViewController *)dismissed</code>他们都返回了一个实现<code>UIViewControllerAnimatedTransitioning</code>协议的对象。<code>UIViewControllerAnimatedTransitioning</code>协议的方法就是我们实现动画的地方。关于此协议我们等会再说。</p>
<p>再来看如下两个方法:<br><code>interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator</code>和<code>interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator</code>，他们都返回了一个实现<code>UIViewControllerInteractiveTransitioning</code>协议的对象，而此协议主要用于交互式转场动画。关于此协议我们等会再说。</p>
<h2 id="push-pop"><a href="#push-pop" class="headerlink" title="push/pop"></a>push/pop</h2><p>在使用<code>UINavigationController</code>进行页面之间的导航管理时，系统也是默认为我们实现了<code>push</code>和<code>pop</code>动画的，而如果想自定义<code>push/pop</code>动画，则需要一个实现<code>UINavigationControllerDelegate</code>协议的对象。如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PushAViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) PushManager *pushManager;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PushAViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    PushBViewController *bVC = [[PushBViewController alloc] init];</div><div class="line">    <span class="keyword">self</span>.pushManager = [[PushManager alloc] init];</div><div class="line">    bVC.navigationController.delegate = <span class="keyword">self</span>.pushManager;</div><div class="line">    [<span class="keyword">self</span>.navigationController pushViewController:bVC animated:<span class="literal">YES</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h4 id="UINavigationControllerDelegate"><a href="#UINavigationControllerDelegate" class="headerlink" title="UINavigationControllerDelegate"></a>UINavigationControllerDelegate</h4><p>我们再来看看<code>UINavigationControllerDelegate</code>协议的相关方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//返回真正执行交互式动画的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController</div><div class="line">                                   interactionControllerForAnimationController:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;) animationController;</div><div class="line"></div><div class="line"><span class="comment">//返回由谁去执行动画的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController</div><div class="line">                                            animationControllerForOperation:(<span class="built_in">UINavigationControllerOperation</span>)operation</div><div class="line">                                                         fromViewController:(<span class="built_in">UIViewController</span> *)fromVC</div><div class="line">                                                           toViewController:(<span class="built_in">UIViewController</span> *)toVC;</div></pre></td></tr></table></figure></p>
<p>我们会发现 此两种方法分别返回了实现了<code>UIViewControllerInteractiveTransitioning</code>协议的对象和实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象。我们不难发现，无论是<code>push/pop</code>还是<code>present/dismiss</code>真正的执行动画都是一个实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象，而真正执行交互式动画的都是一个实现了<code>UIViewControllerInteractiveTransitioning</code>协议的对象。既然如此，那我们就来研究一下<code>UIViewControllerAnimatedTransitioning</code>和<code>UIViewControllerInteractiveTransitioning</code>协议</p>
<h2 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a>UIViewControllerAnimatedTransitioning</h2><p>先来看此协议的方法:<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//动画执行的时间</span></div><div class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext;</div><div class="line"><span class="comment">//执行动画</span></div><div class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext;</div></pre></td></tr></table></figure></p>
<p>此协议的两个方法必须实现。<code>transitionDuration:</code>方法返回动画执行的时间。通常情况下，系统执行<code>present/dismiss</code>和<code>push/pop</code>动画的时间为0.5秒左右。<code>animateTransition</code>方法就是真正执行动画的地方。这个方法系统会给我们传过来一个实现了<code>UIViewControllerContextTransitioning</code>协议的对象（转场上下文），在执行动画之前，我们先来了解一下<code>UIViewControllerContextTransitioning</code>协议。</p>
<p>先来看<code>UIViewControllerContextTransitioning</code>协议的定义<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//上下文的view 对做动画的view需要添加到此上下文的view中</span></div><div class="line">- (<span class="built_in">UIView</span> *)containerView;</div><div class="line"><span class="comment">//是否动画正在进行</span></div><div class="line">- (<span class="built_in">BOOL</span>)isAnimated;</div><div class="line"><span class="comment">//是否是交互式动画</span></div><div class="line">- (<span class="built_in">BOOL</span>)isInteractive; </div><div class="line"><span class="comment">//是否取消</span></div><div class="line">- (<span class="built_in">BOOL</span>)transitionWasCancelled;</div><div class="line"><span class="comment">//获取当前模态跳转的方式</span></div><div class="line">- (<span class="built_in">UIModalPresentationStyle</span>)presentationStyle;</div><div class="line"><span class="comment">//根据系数来更新交互式动画 0~1</span></div><div class="line">- (<span class="keyword">void</span>)updateInteractiveTransition:(<span class="built_in">CGFloat</span>)percentComplete;</div><div class="line"><span class="comment">//完成交互式动画</span></div><div class="line">- (<span class="keyword">void</span>)finishInteractiveTransition;</div><div class="line"><span class="comment">//取消交互式动画</span></div><div class="line">- (<span class="keyword">void</span>)cancelInteractiveTransition;</div><div class="line"><span class="comment">//iOS10新加入的方法 暂停交互式动画</span></div><div class="line">- (<span class="keyword">void</span>)pauseInteractiveTransition <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div><div class="line"><span class="comment">//当动画结束时 要调用此方法告诉上下文</span></div><div class="line">- (<span class="keyword">void</span>)completeTransition:(<span class="built_in">BOOL</span>)didComplete;</div><div class="line"><span class="comment">//获取当前上下文的控制器，使用UITransitionContextFromViewControllerKey获取fromVC 使用UITransitionContextToViewControllerKey获取toVC</span></div><div class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UIViewController</span> *)viewControllerForKey:(<span class="built_in">UITransitionContextViewControllerKey</span>)key;</div><div class="line"><span class="comment">//iOS8之后的方法 返回此上下文控制器的view ，通常情况下，尽可能不直接使用controller的view属性，因为有时候我们直接使用controller的view并不是我们真正要做动画的view。我们应该直接使用UITransitionContextFromViewKey来获取fromView，使用UITransitionContextToViewKey来获取toView。</span></div><div class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UIView</span> *)viewForKey:(<span class="built_in">UITransitionContextViewKey</span>)key <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="comment">//目标view的transform</span></div><div class="line">- (<span class="built_in">CGAffineTransform</span>)targetTransform <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="comment">//返回初始位置的frame 即fromView的frame</span></div><div class="line">- (<span class="built_in">CGRect</span>)initialFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</div><div class="line"><span class="comment">//返回动画结束位置的frame 即toView得frame</span></div><div class="line">- (<span class="built_in">CGRect</span>)finalFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</div></pre></td></tr></table></figure></p>
<p>了解完<code>UIViewControllerContextTransitioning</code>协议后，我们就可以实现自定义转场动画了。</p>
<p>第一节中，我们定义了类<code>PresentManager</code>并实现了<code>UIViewControllerAnimatedTransitioning</code>和<code>UIViewControllerTransitioningDelegate</code>,我们先来看<code>UIViewControllerTransitioningDelegate</code>协议的具体实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                                            presentingController:(<span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                                sourceController:(<span class="built_in">UIViewController</span> *)source &#123;</div><div class="line">    <span class="comment">//标记此动画为Present 并使用自身为动画的最终执行者</span></div><div class="line">    <span class="keyword">self</span>.transitionStyle = TransitionStylePresent;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed &#123;</div><div class="line">    <span class="comment">//标记此动画为Dismiss 并使用自身为动画的最终执行者</span></div><div class="line">    <span class="keyword">self</span>.transitionStyle = TransitionStyleDismiss;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看看<code>UIViewControllerAnimatedTransitioning</code>协议的具体实现：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</div><div class="line">	<span class="comment">//返回动画的执行时间</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1.0</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</div><div class="line">    <span class="comment">//1. 首先获取上下文的view</span></div><div class="line">    <span class="built_in">UIView</span>  *containerView = [transitionContext containerView];</div><div class="line">    <span class="keyword">if</span> (!containerView) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.transitionStyle == TransitionStylePresent) &#123;</div><div class="line">        <span class="comment">//present 动画</span></div><div class="line">        </div><div class="line">        <span class="comment">//2. 获取 fromViewController 和 toViewController</span></div><div class="line">        <span class="built_in">UIViewController</span> *fromViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</div><div class="line">        <span class="built_in">UIViewController</span> *toViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//3. 获取fromView和toView</span></div><div class="line">        <span class="built_in">UIView</span> *fromView, *toView;</div><div class="line">        <span class="keyword">if</span> ([transitionContext respondsToSelector:<span class="keyword">@selector</span>(viewForKey:)]) &#123;</div><div class="line">            fromView = [transitionContext viewForKey:<span class="built_in">UITransitionContextFromViewKey</span>];</div><div class="line">            toView = [transitionContext viewForKey:<span class="built_in">UITransitionContextToViewKey</span>];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            fromView = fromViewController.view;</div><div class="line">            toView = toViewController.view;</div><div class="line">        &#125;</div><div class="line">        fromView.frame = [transitionContext initialFrameForViewController:fromViewController];</div><div class="line">        toView.frame = [transitionContext finalFrameForViewController:toViewController];</div><div class="line">        </div><div class="line">        <span class="comment">//4. 设置toView动画初始frame 这里 模仿一下从屏幕左边模态跳转</span></div><div class="line">        toView.frame = <span class="built_in">CGRectMake</span>(-toView.frame.size.width, toView.frame.origin.y, toView.frame.size.width, toView.frame.size.height);</div><div class="line">        </div><div class="line">        <span class="comment">//5. 添加到上下文的view上</span></div><div class="line">        [containerView addSubview:fromView];</div><div class="line">        [containerView addSubview:toView];</div><div class="line">        </div><div class="line">        <span class="comment">//6. 执行动画</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] animations:^&#123;</div><div class="line">            toView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, toView.frame.origin.y, toView.frame.size.width, toView.frame.size.height);</div><div class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            <span class="comment">//7. 一定要告诉上下文 动画执行结束</span></div><div class="line">            [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</div><div class="line">        &#125;];</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// pop动画</span></div><div class="line">        <span class="comment">//2. 获取 fromViewController 和 toViewController</span></div><div class="line">        <span class="built_in">UIViewController</span> *fromViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</div><div class="line">        <span class="built_in">UIViewController</span> *toViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//3. 获取fromView和toView</span></div><div class="line">        <span class="built_in">UIView</span> *fromView, *toView;</div><div class="line">        <span class="keyword">if</span> ([transitionContext respondsToSelector:<span class="keyword">@selector</span>(viewForKey:)]) &#123;</div><div class="line">            fromView = [transitionContext viewForKey:<span class="built_in">UITransitionContextFromViewKey</span>];</div><div class="line">            toView = [transitionContext viewForKey:<span class="built_in">UITransitionContextToViewKey</span>];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            fromView = fromViewController.view;</div><div class="line">            toView = toViewController.view;</div><div class="line">        &#125;</div><div class="line">        fromView.frame = [transitionContext initialFrameForViewController:fromViewController];</div><div class="line">        toView.frame = [transitionContext finalFrameForViewController:toViewController];</div><div class="line">        </div><div class="line">        <span class="comment">//4. 添加到上下文的view上</span></div><div class="line">        [containerView addSubview:toView];</div><div class="line">        [containerView addSubview:fromView];</div><div class="line">        </div><div class="line">        <span class="comment">//5. 执行动画</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] animations:^&#123;</div><div class="line">            fromView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, -fromView.frame.size.height, fromView.frame.size.width, fromView.frame.size.height);</div><div class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            <span class="comment">//7. 一定要告诉上下文 动画执行结束</span></div><div class="line">            [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我这里只是做一个简单的动画，至于该如何做更复杂的动画，那就开动大家的大脑吧。</p>
<p>同样的，自定义<code>push/pop</code>动画也是如此，这里不再详解。</p>
<h2 id="交互式动画"><a href="#交互式动画" class="headerlink" title="交互式动画"></a>交互式动画</h2><p>在前面，我们一直提到一个协议<code>UIViewControllerInteractiveTransitioning</code>，实现此协议，我们就能使用交互式转场动画。iOS7为我们提供了已经实现好此协议的类<code>UIPercentDrivenInteractiveTransition</code>，我们只需继承此类，便可实现交互式动画。为了方便，下面的例子依旧在<code>present/dismiss</code>转场基础上讲解，我们让<code>PresentManager</code>继承<code>UIPercentDrivenInteractiveTransition</code>，并且在<code>PresentBViewController</code>上添加<code>pan</code>手势，具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//这里为了方便  当A控制器present B控制器的时候 直接在B控制器上添加pan手势，并且强引用B控制器。</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                                            presentingController:(<span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                                sourceController:(<span class="built_in">UIViewController</span> *)source &#123;</div><div class="line">    <span class="comment">//标记此动画为Present 并使用自身为动画的最终执行者</span></div><div class="line">    <span class="keyword">self</span>.transitionStyle = TransitionStylePresent;</div><div class="line">    <span class="comment">//添加手势</span></div><div class="line">    [<span class="keyword">self</span> addGesture:presented];</div><div class="line">    <span class="keyword">self</span>.presentingVC = presented;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在代理方法中返回`PresentManager`自己作为交互式代理</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.interacting) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//添加手势</span></div><div class="line">- (<span class="keyword">void</span>)addGesture:(<span class="built_in">UIViewController</span> *)viewController &#123;</div><div class="line">    <span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(panGesture:)];</div><div class="line">    [viewController.view addGestureRecognizer:pan];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//监听手势变化</span></div><div class="line">- (<span class="keyword">void</span>)panGesture:(<span class="built_in">UIPanGestureRecognizer</span> *)gesture &#123;</div><div class="line">    <span class="built_in">CGPoint</span> translation = [gesture translationInView:gesture.view];</div><div class="line">    <span class="keyword">switch</span> (gesture.state) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</div><div class="line">        		<span class="comment">//标记当前模态消失为手势调用</span></div><div class="line">            <span class="keyword">self</span>.interacting = <span class="literal">YES</span>;</div><div class="line">            [<span class="keyword">self</span>.presentingVC dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>: &#123;</div><div class="line">        		<span class="comment">//根据手势的滑动距离 更新状态</span></div><div class="line">            <span class="built_in">CGFloat</span> fraction = translation.x / gesture.view.frame.size.width;</div><div class="line">            [<span class="keyword">self</span> updateInteractiveTransition:fraction];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateCancelled</span>: &#123;</div><div class="line">        		<span class="comment">//如果划过50% dismiss掉 否则恢复</span></div><div class="line">            <span class="keyword">self</span>.interacting = <span class="literal">NO</span>;</div><div class="line">            <span class="built_in">CGFloat</span> fraction = translation.x / gesture.view.frame.size.width;</div><div class="line">            <span class="keyword">if</span> (fraction&lt;<span class="number">0.5</span> || gesture.state == <span class="built_in">UIGestureRecognizerStateCancelled</span>) &#123;</div><div class="line">                [<span class="keyword">self</span> cancelInteractiveTransition];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                [<span class="keyword">self</span> finishInteractiveTransition];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，<code>push/pop</code>亦是如此。</p>
<h2 id="UIPresentationController"><a href="#UIPresentationController" class="headerlink" title="UIPresentationController"></a>UIPresentationController</h2><p>在第一节，我们说到<code>UIViewControllerTransitioningDelegate</code>协议的时候，还有个方法没有说，它是iOS8以后才有的，此方法为：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIPresentationController</span> *)presentationControllerForPresentedViewController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                               presentingViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                   sourceViewController:(<span class="built_in">UIViewController</span> *)source</div></pre></td></tr></table></figure></p>
<p>此方法返回一个<code>UIPresentationController</code>对象，这个对象是做什么的呢？</p>
<p><code>UIViewController</code>有一个属性<code>modalPresentationStyle</code>，我们来看看它有哪些值：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalPresentationStyle</span>) &#123;</div><div class="line">        <span class="built_in">UIModalPresentationFullScreen</span> = <span class="number">0</span>,</div><div class="line">        <span class="built_in">UIModalPresentationPageSheet</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">3</span>_2) __TVOS_PROHIBITED,</div><div class="line">        <span class="built_in">UIModalPresentationFormSheet</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">3</span>_2) __TVOS_PROHIBITED,</div><div class="line">        <span class="built_in">UIModalPresentationCurrentContext</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">3</span>_2),</div><div class="line">        <span class="built_in">UIModalPresentationCustom</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0),</div><div class="line">        <span class="built_in">UIModalPresentationOverFullScreen</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">        <span class="built_in">UIModalPresentationOverCurrentContext</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">        <span class="built_in">UIModalPresentationPopover</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0) __TVOS_PROHIBITED,</div><div class="line">        <span class="built_in">UIModalPresentationNone</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0) = <span class="number">-1</span>,         </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>平常开发中，我们使用最多的就是<code>UIModalPresentationCustom</code>，如果我们不使用<code>UIModalPresentationCustom</code>，默认的系统会在我们调用“上下文”的<code>completeTransition</code>方法后会把fromVC移除掉。</p>
<p>如果我们想在<code>present/pop</code>执行动画的生命周期过程中，任意的在上下文中插入视图或者更改最终视图的大小等，使用<code>UIPresentationController</code>便可实现。我们来看<code>UIPresentationController</code>类的定义：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//上下文的view</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *containerView;</div><div class="line"></div><div class="line"><span class="comment">//即将布局</span></div><div class="line">- (<span class="keyword">void</span>)containerViewWillLayoutSubviews;</div><div class="line"><span class="comment">//正在布局</span></div><div class="line">- (<span class="keyword">void</span>)containerViewDidLayoutSubviews;</div><div class="line"></div><div class="line"><span class="comment">//返回模态跳转后的view（B控制器View）的最终frame  通常情况下要重写此方法</span></div><div class="line">- (<span class="built_in">CGRect</span>)frameOfPresentedViewInContainerView;</div><div class="line"></div><div class="line"><span class="comment">//周期方法</span></div><div class="line">- (<span class="keyword">void</span>)presentationTransitionWillBegin;</div><div class="line">- (<span class="keyword">void</span>)presentationTransitionDidEnd:(<span class="built_in">BOOL</span>)completed;</div><div class="line">- (<span class="keyword">void</span>)dismissalTransitionWillBegin;</div><div class="line">- (<span class="keyword">void</span>)dismissalTransitionDidEnd:(<span class="built_in">BOOL</span>)completed;</div></pre></td></tr></table></figure></p>
<p>如此，我们便可在视图周期方法中任意的添加和删除视图，以满足我们的需求。也可以在布局过程中，改变弹出视图的frame。切记，视图的添加和删除都是在上下文的view中进行的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>了解完整个转场动画的框架，我们合理的使用框架中的协议和类，便能尽可能的满足我们的开发需求。至于该如何实现，大家可以动脑了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发中，页面之间的跳转无外乎由&lt;code&gt;UINavigationController&lt;/code&gt;管理的&lt;code&gt;push&lt;/code&gt;或者&lt;code&gt;pop&lt;/code&gt;操作、以及由&lt;code&gt;UIViewController&lt;/code&gt;管理的&lt;code&gt;present&lt;/code&gt;和&lt;code&gt;dismiss&lt;/code&gt;操作，无论何种操作，iOS原生系统都为我们提供了页面之间的基础跳转动画。但是往往在开发中，由于各种功能需求，iOS原生系统提供的跳转动画并不能满足我们的需求，好在iOS早就给我们提供了一套自定义转场动画的解决方案，这篇文章就来详细了解一下转场动画。在了解这篇文章之前，先看看iOS提供的整个转场框架&lt;/p&gt;
&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/guiyongdong/Resource/blob/master/hexoImage/transition.png?raw=true&quot;/&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="动画" scheme="http://www.guiyongdong.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking源码解析</title>
    <link href="http://www.guiyongdong.com/2017/02/15/AFNetworking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.guiyongdong.com/2017/02/15/AFNetworking源码解析/</id>
    <published>2017-02-15T06:15:04.000Z</published>
    <updated>2017-03-01T02:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络是APP开发中非常重要的一部分，除非这个APP是本地自玩，否则就离不开网络。在iOS开发中，我们一般都会去使用别人造好的轮子，其中最有名也最常用的非<code>AFNetworking</code>莫属。这篇文章就深入探讨一下<code>AFNetworking</code>是如何工作的。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>我们先来看看<code>AFNetworking</code>整个架构体系：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/af2.png?raw=true"><br></div>

<p>首先，我们有两个问题需要了解：</p>
<ul>
<li>如何使用NSURLSession发出HTTP请求</li>
<li>如何使用AFNetworking发出HTTP请求</li>
</ul>
<a id="more"></a>
<h4 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h4><hr>
<p><code>NSURLSession</code>以及与它相关的类为我们提供了下载内容的API，这个API提供了一系列的代理方法来支持身份认证，并且支持后台下载。</p>
<p>使用<code>NSURLSession</code>来运行HTTP请求并且获得数据总共有五个步骤：</p>
<ol>
<li>实例化一个<code>NSURLRequest/NSMutableURLRequest</code>,设置URL</li>
<li>通过<code>- shareSession</code>方法获取<code>NSURLSession</code></li>
<li>在session上调用<code>- dataTaskWithRequest:completionHandler:</code>方法返回一个<code>NSURLSessionDataTask</code></li>
<li>调用dataTask的<code>- resume</code>,开始执行任务</li>
<li>在completionHandler中将数据编码，返回字符串</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:[[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"https://github.com"</span>]];</div><div class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request</div><div class="line">                                       completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">                                           <span class="built_in">NSString</span> *dataStr = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">                                           <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, dataStr);</div><div class="line">                                       &#125;];</div><div class="line">[task resume];</div></pre></td></tr></table></figure>
<p>这一段代码可以说是使用<code>NSURLSession</code>发送请求最简单的一段代码了，当你运行这段代码会在控制台看到github首页的html</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang="en" class=""&gt;</div><div class="line">  &lt;head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# object: http://ogp.me/ns/object# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#"&gt;</div><div class="line">    &lt;meta charset='utf-8'&gt;</div><div class="line">        ...</div><div class="line">    &lt;/head&gt;</div><div class="line">    ...</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>想对<code>NSURLSession</code>有更深的了解，<a href="http://www.guiyongdong.com/2016/11/18/NSURLSession%E4%B8%8ENSURLConnection%E5%8C%BA%E5%88%AB/">请点这里</a></p>
<h4 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h4><hr>
<p>AFNetworking的使用也比较简单的，使用它来发送HTTP请求有两个步骤</p>
<ol>
<li>以服务器的主机地址或者域名生成一个<code>AFHTTPSessionManager</code>的实例</li>
<li>调用<code>- GET:parameters:progress:success:failure:</code>方法</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"hostname"</span>]];</div><div class="line">[manager GET:<span class="string">@"relative_url"</span> parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span></div><div class="line">    success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span> ,responseObject);</div><div class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：在iOS9中，苹果默认全局HTTPS，如果你要发送不安全的HTTP请求，需要在info.plist中加入如下键值对才能发出不安全的HTTP请求<br><span></span><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/af3.jpeg?raw=true"><br>还有一件事情是要注意的是，AFNetworking默认接收json格式的响应（因为这是在iOS平台上的框架，一般不需要text/html）,如果想要返回html,需要设置<code>acceptableContentTypes</code>。</p>
</blockquote>
<h4 id="AFNetworking的调用栈"><a href="#AFNetworking的调用栈" class="headerlink" title="AFNetworking的调用栈"></a>AFNetworking的调用栈</h4><hr>
<p>刚才我们写了一个简单的网络请求，接下来，我们来看看<code>AFHTTPSessionManager</code>的初始化方法<code>- initWithBaseURL:</code>的调用栈：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- [AFHTTPSessionManager initWithBaseURL:]</div><div class="line">    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]</div><div class="line">        - [AFURLSessionManager initWithSessionConfiguration:]</div><div class="line">            - [<span class="built_in">NSURLSession</span> sessionWithConfiguration:delegate:delegateQueue:]</div><div class="line">            - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></div><div class="line">            - [AFSecurityPolicy defaultPolicy] <span class="comment">// 负责身份认证</span></div><div class="line">            - [AFNetworkReachabilityManager sharedManager] <span class="comment">// 查看网络连接情况</span></div><div class="line">        - [AFHTTPRequestSerializer serializer] <span class="comment">// 负责序列化请求</span></div><div class="line">        - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></div></pre></td></tr></table></figure>
<p>从这个初始化方法的调用栈，我们可以非常清晰地了解这个架构的结构：</p>
<ul>
<li>其中<code>AFURLSessionManager</code>是<code>AFHTTPSessionManager</code>的父类</li>
<li><code>AFURLSessionManager</code>负责生成<code>NSURLSession</code>的实例，管理<code>AFSecurityPolicy</code>和<code>AFNetworkReachabilityManager</code>,来保证请求的安全和查看网络连接情况，它有一个<code>AFJSONResponseSerializer</code>的实例来序列化HTTP响应</li>
<li><code>AFHTTPSessionManager</code>有着自己的<code>AFHTTPRequestSerialier</code>和<code>AFJSONResponseSerializer</code>来管理请求和响应的序列化，同时依赖父类提供的接口保证安全、监控网络状态，实现发出HTTP请求这一核心功能</li>
</ul>
<p>初始化方法很好地揭示了AFNetworking整个框架的架构，接下来我们要通过分析另一个方法<code>- GET:parameters:process:success:failure:</code>的调用栈，看一下HTTP请求是如何发出的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- [AFHTTPSessionManager GET:parameters:process:success:failure:]</div><div class="line">    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] <span class="comment">// 返回 NSURLSessionDataTask #1</span></div><div class="line">        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] <span class="comment">// 返回 NSMutableURLRequest</span></div><div class="line">        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] <span class="comment">// 返回 NSURLSessionDataTask #2</span></div><div class="line">            - [<span class="built_in">NSURLSession</span> dataTaskWithRequest:] <span class="comment">// 返回 NSURLSessionDataTask #3</span></div><div class="line">            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</div><div class="line">                - [AFURLSessionManagerTaskDelegate init]</div><div class="line">                - [AFURLSessionManager setDelegate:forTask:]</div><div class="line">    - [<span class="built_in">NSURLSessionDataTask</span> resume]</div></pre></td></tr></table></figure>
<p>在这里 <code>#1</code> <code>#2</code> <code>#3</code>处返回的是同一个dataTask，我们可以看到，在<code>#3</code>出调用的方法<code>- [NSURLSession dataTaskWithRequest:]</code>和只使用<code>NSURLSession</code>发出HTTP请求时调用的方法<code>- [NSURLSession dataTaskWithRequest:completionHandler:]</code>差不多。在这个地方返回dataTask之后，我们再调用<code>- resume</code>方法执行请求，并在某些事件执行时通知代理<code>AFURLSessionManagerTaskDelegate</code></p>
<h3 id="AFNetworking的核心AFURLSessionManager"><a href="#AFNetworking的核心AFURLSessionManager" class="headerlink" title="AFNetworking的核心AFURLSessionManager"></a>AFNetworking的核心AFURLSessionManager</h3><hr>
<p><code>AFURLSessionManager</code>绝对可以称得上是AFNetworking的核心</p>
<ul>
<li>负责创建和管理NSURLSession</li>
<li>管理NSURLSessionTask</li>
<li>实现NSURLSessionDelegate等协议中的代理方法</li>
<li>使用_AFURLSessionTaskSwizzling调剂方法</li>
<li>引入AFSecurityPolicy保证请求的安全</li>
<li>引入AFNetworkingReachabilityManager监控网络状态</li>
</ul>
<p>这一节将会着重介绍上面七个功能中的前五个，分析它是如何包装<code>NSURLSession</code>以及众多代理方法的。</p>
<h4 id="创建和管理NSURLSession"><a href="#创建和管理NSURLSession" class="headerlink" title="创建和管理NSURLSession"></a>创建和管理NSURLSession</h4><hr>
<p>使用<code>AFURLSessionManager</code>时，第一件要做的事情一定是初始化：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!configuration) &#123;</div><div class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.sessionConfiguration = configuration;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line"></div><div class="line"><span class="meta">#if !TARGET_OS_WATCH</span></div><div class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</div><div class="line">    <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</div><div class="line">    <span class="comment">//为已有的task设置代理</span></div><div class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</div><div class="line">            [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</div><div class="line">            [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</div><div class="line">            [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在初始化方法中，需要完成初始化一些自己持有的特例：</p>
<ol>
<li>初始化 <strong>会话配置</strong> (NSURLSessionConfiguration)，默认为<code>defaultSessionConfiguration</code></li>
<li>初始化 <strong>会话</strong> (session)，并设置会话的代理以及代理列队</li>
<li>初始化管理 <strong>响应序列化</strong> (AFJSONResponseSerializer)，<strong>安全认证</strong> (AFSecurityPolicy) 以及 <strong>监控网络状态</strong> (AFNetworkReachabilityManager) 的实例</li>
<li>初始化保存data task的字典(mutableTaskDelegatesKeysByTaskIdentifier)</li>
</ol>
<h4 id="管理NSURLSessionTask"><a href="#管理NSURLSessionTask" class="headerlink" title="管理NSURLSessionTask"></a>管理NSURLSessionTask</h4><hr>
<p>接下来，在获得了<code>AFURLSessionManager</code>的实例之后，我们可以通过以下方法创建<code>NSURLSessionDataTask</code>的实例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                                         fromFile:(<span class="built_in">NSURL</span> *)fileURL</div><div class="line">                                         progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</div><div class="line">                                completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span>  * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                                             progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</div><div class="line">                                          destination:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</div><div class="line">                                    completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>这里省略了一些返回NSURLSessionTask的方法，因为这些接口的形式都是差不多的。</p>
<p>我们将以 <code>[AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code>方法的实现为例，分析它是如何实例化并返回一个<code>NSURLSessionTask</code>的实例的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>- [NSURLSession dataTaskWithRequest:]</code>方法传入<code>NSURLRequest</code></li>
<li>调用<code>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</code>方法返回一个<code>AFURLSessionManagerTaskDelegate</code>对象</li>
<li>将<code>completionHandler</code> <code>uploadProgressBlock</code>和<code>downloadProgressBlock</code>传入该对象并在相应事件发生时进行回调</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = <span class="keyword">self</span>;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</div><div class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中同时调用了另一个方法<code>- [AFURLSessionManager setDelegate:forTask:]</code>来设置代理：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(task);</div><div class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span>.lock lock];</div><div class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</div><div class="line">    [<span class="keyword">self</span>.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如上面所提到的，<code>AFURLSessionManager</code>就是通过字典<code>mutableTaskDelegatesKeyedByTaskIdentifier</code>来存储并管理每一个<code>NSURLSessionTask</code>，它以<code>taskIdentifier</code>为键存储task。</p>
<p>该方法使用<code>NSLock</code>来保证不同线程使用<code>mutableTaskDelegatesKeyedByTaskIdentifier</code>时，不会出现线程竞争的问题。</p>
<p>同时调用<code>-setupProgressForTask</code>，我们会在下面具体介绍这个方法。</p>
<h4 id="实现NSURLSessionDelegate等协议中的代理方法"><a href="#实现NSURLSessionDelegate等协议中的代理方法" class="headerlink" title="实现NSURLSessionDelegate等协议中的代理方法"></a>实现NSURLSessionDelegate等协议中的代理方法</h4><hr>
<p>在<code>AFURLSessionManager</code>的头文件中可以看到，它遵循了多个协议，其中包括：</p>
<ul>
<li>NSURLSessionDelegate</li>
<li>NSURLSessionTaskDelegate</li>
<li>NSURLSessionDataDelegate</li>
<li>NSURLSessionDownloadDelegate</li>
</ul>
<p>它的初始化方法<code>- [AFURLSessionManager initWithSessionConfiguration:]</code>将<code>NSURLSession</code>的代理指向self，然后实现这些方法，提供更简洁的block的接口：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block;</div><div class="line">- (<span class="keyword">void</span>)setSessionDidReceiveAuthenticationChallengeBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>它为所有的代理协议都提供了对应的block接口，方法实现的思路都是相似的，我们以<code>- [AFNRLSessionManager setSessionDidBecomeInvalidBlock:]</code>为例。</p>
<p>首先调用setter方法，将block存入<code>sessionDidBecomeInvalid</code>属性中：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block &#123;</div><div class="line">    <span class="keyword">self</span>.sessionDidBecomeInvalid = block;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当代理方法调用时，如果存在对应的block，会执行对应的block:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error  </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</div><div class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他相似的接口实现也都差不多，这里直接跳过了。</p>
<h4 id="使用AFURLSessionManagerTaskDelegate管理进度"><a href="#使用AFURLSessionManagerTaskDelegate管理进度" class="headerlink" title="使用AFURLSessionManagerTaskDelegate管理进度"></a>使用AFURLSessionManagerTaskDelegate管理进度</h4><hr>
<p>在上面我们提到过<code>AFURLSessionManagerTaskDelegate</code>类，它主要为task提供进度管理功能，并在task结束时回调，也就是调用在<code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code>等方法中传入的<code>completionHandler</code>。</p>
<p>我们首先分析一下<code>AFURLSessionManagerTaskDelegate</code>是如何对进度进行跟踪的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setupProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</div><div class="line"></div><div class="line">    <span class="meta">#1：设置在上传进度或者下载进度状态改变时的回调</span></div><div class="line"></div><div class="line">    <span class="meta">#2：KVO</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的实现有两个部分，一部分是对代理持有的两个属性<code>uploadProgress</code>和<code>downloadProgress</code>设置回调</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">__<span class="keyword">weak</span> __typeof__(task) weakTask = task;</div><div class="line"></div><div class="line"><span class="keyword">self</span>.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;  </div><div class="line">[<span class="keyword">self</span>.uploadProgress setCancellable:<span class="literal">YES</span>];</div><div class="line">[<span class="keyword">self</span>.uploadProgress setCancellationHandler:^&#123;</div><div class="line">   __typeof__(weakTask) strongTask = weakTask;</div><div class="line">   [strongTask cancel];</div><div class="line">&#125;];</div><div class="line">[<span class="keyword">self</span>.uploadProgress setPausable:<span class="literal">YES</span>];</div><div class="line">[<span class="keyword">self</span>.uploadProgress setPausingHandler:^&#123;</div><div class="line">   __typeof__(weakTask) strongTask = weakTask;</div><div class="line">   [strongTask suspend];</div><div class="line">&#125;];</div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.uploadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;  </div><div class="line">   [<span class="keyword">self</span>.uploadProgress setResumingHandler:^&#123;</div><div class="line">       __typeof__(weakTask) strongTask = weakTask;</div><div class="line">       [strongTask resume];</div><div class="line">   &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只有对<code>uploadProgress</code>设置回调的代码，设置<code>downloadProgress</code>与这里完全相同</p>
<blockquote>
<p>主要目的是在对应<code>NSProgress</code>的状态改变时，调用<code>resume</code> <code>suspend</code>等方法改变task的状态。</p>
</blockquote>
<p>第二部分是对task和<code>NSProgress</code>属性进行键值观测：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[task addObserver:<span class="keyword">self</span></div><div class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))</div><div class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">         context:<span class="literal">NULL</span>];</div><div class="line">[task addObserver:<span class="keyword">self</span></div><div class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))</div><div class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">         context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">[task addObserver:<span class="keyword">self</span></div><div class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))</div><div class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">         context:<span class="literal">NULL</span>];</div><div class="line">[task addObserver:<span class="keyword">self</span></div><div class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))</div><div class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">         context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.downloadProgress addObserver:<span class="keyword">self</span></div><div class="line">                       forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</div><div class="line">                          options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                          context:<span class="literal">NULL</span>];</div><div class="line">[<span class="keyword">self</span>.uploadProgress addObserver:<span class="keyword">self</span></div><div class="line">                     forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</div><div class="line">                        options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                        context:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure>
<p>在<code>observeValueForKeypath:ofObject:change:context:</code>方法中改变进度，并调用block</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSURLSessionTask</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))]) &#123;</div><div class="line">            <span class="keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="string">@"new"</span>] longLongValue];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;</div><div class="line">            <span class="keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="string">@"new"</span>] longLongValue];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))]) &#123;</div><div class="line">            <span class="keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="string">@"new"</span>] longLongValue];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;</div><div class="line">            <span class="keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="string">@"new"</span>] longLongValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对象的某些属性改变时更新<code>NSProgress</code>对象或使用block传递<code>NSProgress</code>对象<br><code>self.uploadProgressBlock(object)</code>。</p>
<h4 id="代理方法-URLSession-task-didCompleteWithError"><a href="#代理方法-URLSession-task-didCompleteWithError" class="headerlink" title="代理方法 URLSession:task:didCompleteWithError:"></a>代理方法 URLSession:task:didCompleteWithError:</h4><hr>
<p>在每一个<code>NSURLSessionTask</code>结束时，都会在代理方法<code>URLSession:task:didCompleteWithError:</code>中：</p>
<ol>
<li>调用传入的<code>completionHander</code>block</li>
<li>发出<code>AFNetworkingTaskDidCompleteNotification</code>通知</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</div><div class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error  </div><div class="line">&#123;</div><div class="line">    <span class="meta">#1：获取数据, 存储 `responseSerializer` 和 `downloadFileURL`</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="meta">#2：在存在错误时调用 `completionHandler`</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="meta">#3：调用 `completionHandler`</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是整个代理方法的骨架，先看一下最简单的第一部分代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">__block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];  </div><div class="line">userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line"><span class="comment">//Performance Improvement from #2672</span></div><div class="line"><span class="built_in">NSData</span> *data = <span class="literal">nil</span>;  </div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;  </div><div class="line">   data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</div><div class="line">   <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></div><div class="line">   <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;  </div><div class="line">   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</div><div class="line">   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码从<code>mutableData</code>中取出数据，设置了<code>userInfo</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;  </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">        <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果当前manager持有<code>completionGroup</code>或者<code>completionQueue</code>就是用它们。否则会创建一个<code>dispatch_group_t</code>并在主线程中调用<code>completionHandler</code>并发送通知（在主线程中）。</p>
<p>如果在执行当前task时没有遇到错误，那么先对数据进行序列化，然后同样调用block并发送通知。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;  </div><div class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">    responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</div><div class="line">        responseObject = <span class="keyword">self</span>.downloadFileURL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (responseObject) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">            <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="代理方法URLSession-dataTask-didReceiveData-和URLSession-downloadTask-didFinishDownloadingToURL-这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为mutableData追加数据和处理下载的文件："><a href="#代理方法URLSession-dataTask-didReceiveData-和URLSession-downloadTask-didFinishDownloadingToURL-这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为mutableData追加数据和处理下载的文件：" class="headerlink" title="代理方法URLSession:dataTask:didReceiveData:和URLSession:downloadTask:didFinishDownloadingToURL: 这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为mutableData追加数据和处理下载的文件："></a>代理方法URLSession:dataTask:didReceiveData:和URLSession:downloadTask:didFinishDownloadingToURL: 这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为mutableData追加数据和处理下载的文件：</h4><hr>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</div><div class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location  </div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.downloadFileURL = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        <span class="keyword">self</span>.downloadFileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</div><div class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span>.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (fileManagerError) &#123;</div><div class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-AFURLSessionTaskSwizzling-调剂方法"><a href="#使用-AFURLSessionTaskSwizzling-调剂方法" class="headerlink" title="使用 _AFURLSessionTaskSwizzling 调剂方法"></a>使用 _AFURLSessionTaskSwizzling 调剂方法</h4><hr>
<p><code>_AFURLSessionTaskSwizzling</code>的唯一功能就是修改<code>NSURLSessionTask</code>的<code>resume</code>和<code>suspend</code>方法，使用下面的方法替换原有的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)af_resume &#123;</div><div class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</div><div class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</div><div class="line">    [<span class="keyword">self</span> af_resume];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)af_suspend &#123;</div><div class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</div><div class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</div><div class="line">    [<span class="keyword">self</span> af_suspend];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做的目的是为了在方法<code>resume</code>或者<code>suspend</code>被调用时发送通知。</p>
<p>具体方法调剂的过程是在<code>+load</code>方法中进行的</p>
<p><code>load</code>方法只会在整个文件被引入时调用一次</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"NSURLSessionTask"</span>)) &#123;</div><div class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</div><div class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</div><div class="line"><span class="meta">#pragma GCC diagnostic push</span></div><div class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wnonnull"</span></span></div><div class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</div><div class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</div><div class="line">            Class superClass = [currentClass superclass];</div><div class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</div><div class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</div><div class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</div><div class="line">                originalAFResumeIMP != classResumeIMP) &#123;</div><div class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</div><div class="line">            &#125;</div><div class="line">            currentClass = [currentClass superclass];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [localDataTask cancel];</div><div class="line">        [session finishTasksAndInvalidate];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>首先用<code>NSClassFromString(@&quot;NSURLSessionTask&quot;)</code>判断当前部署的iOS版本是否含有类<code>NSURLSessionTask</code></li>
<li>因为iOS7和iOS8上对于<code>NSURLSesionTask</code>的实现不同，所以会通过<code>- [NSURLSession dataTaskWithURL:]</code>方法返回一个<code>NSURLSessionTask</code>实例</li>
<li>取得当前类<code>_AFURLSessionTaskSwizzling</code>中的实现<code>af_resume</code></li>
<li>判断当前类<code>currentClass</code>有<code>resume</code>方法</li>
<li>使用<code>swizzleResumeAndSuspendMethodForClass:</code>调剂该类的<code>resume</code>和<code>suspend</code>方法</li>
<li>currentClass = [currentClass superclass]</li>
</ol>
<h4 id="引入AFSecurityPolicy保证请求的安全"><a href="#引入AFSecurityPolicy保证请求的安全" class="headerlink" title="引入AFSecurityPolicy保证请求的安全"></a>引入AFSecurityPolicy保证请求的安全</h4><hr>
<p><code>AFSecurityPolicy</code>是<code>AFNetworking</code>用来保证HTTP请求安全的类，它被<code>AFURLSessionManager</code>持有，如果你在<code>AFURLSessionManager</code>的实现文件中搜索self.securityPolicy，你只会得到三条结果：</p>
<ol>
<li>初始化<code>self.securityPolicy = [AFSecurityPolicy defaultPolicy]</code></li>
<li>收到连接层的验证请求时</li>
<li>任务接收到验证请求时</li>
</ol>
<p>在API调用上，后两者都调用了<code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code>方法来判断当前服务器是否被信任，我们会在接下来的文章中具体介绍这个方法的实现的作用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</div><div class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</div><div class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</div><div class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">                <span class="keyword">if</span> (credential) &#123;</div><div class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (completionHandler) &#123;</div><div class="line">        completionHandler(disposition, credential);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有传入<code>taskDidReceiveAuthenticationChallenge</code> block，只有在上述方法返回YES时，才会获得认证凭证<code>credential</code>。</p>
<h4 id="引入AFNetworkingReachabilityManager监控网络状态"><a href="#引入AFNetworkingReachabilityManager监控网络状态" class="headerlink" title="引入AFNetworkingReachabilityManager监控网络状态"></a>引入AFNetworkingReachabilityManager监控网络状态</h4><hr>
<p>与<code>AFSecurityPolicy</code>相同，<code>AFURLSessionManager</code>对网络状态的监控是由<code>AFNetworkReachabilityManager</code>来负责的，它仅仅是持有一个<code>AFNetworkReachabilityManager</code>的对象。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><hr>
<ul>
<li><code>AFURLSessionManager</code>是对<code>NSURLSession</code>的封装</li>
<li>它通过<code>- [AFURLSessionManager dataTaskWithRequest:completionHandler:]</code>等接口创建<code>NSURLSessionDataTask</code>的实例</li>
<li>持有一个字典<code>mutableTaskDelegatesKeyedByTaskIdentifier</code>管理这些data task 实例</li>
<li>引入<code>AFURLSessionManagerTaskDelegate</code>来对传入的<code>uploadProgressBlock</code>        <code>downloadProgressBlock</code> <code>completionHandler</code> 在合适的时间进行调用</li>
<li>实现了全部的代理方法来提供block接口</li>
<li>通过方法调剂在data task 状态改变时，发出通知</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络是APP开发中非常重要的一部分，除非这个APP是本地自玩，否则就离不开网络。在iOS开发中，我们一般都会去使用别人造好的轮子，其中最有名也最常用的非&lt;code&gt;AFNetworking&lt;/code&gt;莫属。这篇文章就深入探讨一下&lt;code&gt;AFNetworking&lt;/code&gt;是如何工作的。&lt;/p&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;我们先来看看&lt;code&gt;AFNetworking&lt;/code&gt;整个架构体系：&lt;/p&gt;
&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/guiyongdong/Resource/blob/master/hexoImage/af2.png?raw=true&quot;/&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;首先，我们有两个问题需要了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用NSURLSession发出HTTP请求&lt;/li&gt;
&lt;li&gt;如何使用AFNetworking发出HTTP请求&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.guiyongdong.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://www.guiyongdong.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码分析</title>
    <link href="http://www.guiyongdong.com/2017/01/15/SDWebImage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.guiyongdong.com/2017/01/15/SDWebImage源码分析/</id>
    <published>2017-01-15T07:14:25.000Z</published>
    <updated>2017-02-05T11:34:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage是一个开源的第三方库，它提供了UIImageView的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：</p>
<ol>
<li>提供UIImageView的一个分类，以支持网络图片的加载与缓存管理</li>
<li>一个异步的图片加载器</li>
<li>一个异步的内存+磁盘图片缓存</li>
<li>支持GIF图片</li>
<li>支持WebP图片</li>
<li>后台图片解压缩处理</li>
<li>确保同一个URL不会被反复加载</li>
<li>确保下载及缓存时，主线程不被堵塞</li>
</ol>
<p>从github上对SDWebImage使用情况可以看出，SDWebImage在图片下载及缓存的处理还是被认可的。在本文中，我们主要从源码的角度来分析一下SDWebImage的实现机制。讨论的内容将主要集中在图片的下载及缓存，而不包含对GIF图片及WebP图片的支持操作。不过在3.8.2版本以后，SDWebImage将会使用NSURLSession代替原来的NSURLConnection，主要是更新的是下载功能部分。具体变化可以看:<a href="https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImage-4.0-Migration-guide.md" target="_blank" rel="external">点这里</a>。目前截止到当前时间，最新的版本为4.0.0-beta2,这篇文章是在4.0.0-beta2基础上进行剖析。</p>
<a id="more"></a>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>在下载的过程中，程序会根据设置的不同的下载选项，执行不同的操作。下载选项由枚举<code>SDWebImageDownloaderOptions</code>定义，具体如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageDownloaderOptions) &#123;</div><div class="line">    SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下请求不使用NSURLCache，如果设置该选项，则以默认的缓存策略来使用NSURLCache</span></div><div class="line">    SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 如果从NSURLCache缓存中读取图片，则使用nil作为参数来调用完成block</span></div><div class="line">    SDWebImageDownloaderIgnoreCachedResponse = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    </div><div class="line">	<span class="comment">// 在iOS 4+系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外的时间来完成后台下载。如果后台任务终止，则操作会被取消</span></div><div class="line">    SDWebImageDownloaderContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie</span></div><div class="line">    SDWebImageDownloaderHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 允许不受信任的SSL证书。主要用于测试目的。</span></div><div class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 将图片下载放到高优先级队列中</span></div><div class="line">    SDWebImageDownloaderHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看出，这些选项主要涉及到下载的优先级、缓存、后台任务执行、cookie处理以及认证几个方面.</p>
<h4 id="下载顺序"><a href="#下载顺序" class="headerlink" title="下载顺序"></a>下载顺序</h4><p>SDWebImage的下载操作是按一定顺序来处理的，它定义了两种下载顺序，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SDWebImageDownloaderExecutionOrder) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 以队列的方式，按照先进先出的顺序下载。这是默认的下载顺序</span></div><div class="line">    SDWebImageDownloaderFIFOExecutionOrder,</div><div class="line">    </div><div class="line">    <span class="comment">// 以栈的方式，按照后进先出的顺序下载。</span></div><div class="line">    SDWebImageDownloaderLIFOExecutionOrder</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="下载管理器"><a href="#下载管理器" class="headerlink" title="下载管理器"></a>下载管理器</h4><p>SDWebImageDownloader下载管理器是一个单例5类，它主要负责图片的下载操作的管理。图片的下载是放在一个NSOperationQueue操作队列中来完成的，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;</div></pre></td></tr></table></figure>
<p>默认情况下，队列最大并发数是6.如果需要的话，我们可以通过SDWebImageDownloader类的<code>maxConcurrentDownloads</code>属性来修改。</p>
<p>所有下载操作的网络响应序列化处理是放在一个自定义的并行调度队列中来处理的，其声明及定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;</div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        ...</div><div class="line">        _barrierQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageDownloaderBarrierQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个图片的下载都会对应一些回调操作，如下载进度回调，下载完成回调等，这些回调操作是以block形式来呈现，为此在<code>SDWebImageDownloader.h</code>中定义了几个block，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 下载进度</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageDownloaderProgressBlock)(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize);</div><div class="line"><span class="comment">// 下载完成</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageDownloaderCompletedBlock)(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished);</div><div class="line"><span class="comment">// Header过滤</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span> *(^SDWebImageDownloaderHeadersFilterBlock)(<span class="built_in">NSURL</span> *url, <span class="built_in">NSDictionary</span> *headers);</div></pre></td></tr></table></figure>
<p>图片下载的这些回调信息存储在SDWebImageDownloader类的<code>URLOperations</code>属性中，该属性是一个字典，key是图片的URL地址，value则是一个<code>SDWebImageDownloaderOperation</code>对象，包含每个图片的多组回调信息。由于我们允许多个图片同时下载，因此可能会有多个线程同时操作<code>URLOperations</code>属性。为了保证<code>URLOperations</code>操作（添加、删除）的线程安全性，SDWebImageDownloader将这些操作作为一个个任务放到barrierQueue队列中，并设置屏障来确保同一时间只有一个线程操作<code>URLOperations</code>属性，我们以添加操作为例，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123;</div><div class="line">    </div><div class="line">	...</div><div class="line">	</div><div class="line">    <span class="comment">// 1. 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLOperations进行操作</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];</div><div class="line">        <span class="keyword">if</span> (!operation) &#123;</div><div class="line">        	<span class="comment">//2. 处理第一次URL的下载</span></div><div class="line">            operation = createCallback();</div><div class="line">            <span class="keyword">self</span>.URLOperations[url] = operation;</div><div class="line"></div><div class="line">            __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</div><div class="line">            operation.completionBlock = ^&#123;</div><div class="line">              SDWebImageDownloaderOperation *soperation = woperation;</div><div class="line">              <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</div><div class="line">              <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</div><div class="line">                  [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</div><div class="line">              &#125;;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. 处理同一URL的同步下载请求的单个下载</span></div><div class="line">        <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line"></div><div class="line">        token = [SDWebImageDownloadToken new];</div><div class="line">        token.url = url;</div><div class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个下载管理器对于下载请求的管理都是放在<code>downloadImageWithURL:options:progress:completed:</code>方法里面来处理的，该方法调用了上面所提到的<code>addProgressCallback:andCompletedBlock:forURL:createCallback:</code>方法来将请求的信息存入管理器中，同时在创建回调的block中创建新的操作，配置之后将其放入<code>downloadQueue</code>操作队列中，最后方法返回新创建的操作。其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">        <span class="comment">//超时时间</span></div><div class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</div><div class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">            timeoutInterval = <span class="number">15.0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 1. 创建请求对象，并根据options参数设置其属性</span></div><div class="line">        <span class="comment">// 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作</span></div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. 将操作加入到操作队列downloadQueue中</span></div><div class="line">        <span class="comment">// 如果是LIFO顺序，则将新的操作作为原队列中最后一个操作的依赖，然后将新操作设置为最后一个操作</span></div><div class="line">        [sself.downloadQueue addOperation:operation];</div><div class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，每个下载操作的超时时间可以通过downloadTimeout属性来设置，默认值为15秒。</p>
<h4 id="下载操作"><a href="#下载操作" class="headerlink" title="下载操作"></a>下载操作</h4><p>每个图片的下载操作都是一个Operation操作。。我们在上面分析过这个操作的创建及加入操作队列的过程。现在我们来看看单个操作的具体实现。</p>
<p>SDWebImage定义了一个协议，即SDWebImageOperation作为图片下载操作的基础协议。它只声明了一个cancel方法，用于取消操作。协议的具体声明如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageOperation</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)cancel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>SDWebImage还定义了一个下载协议，即SDWebImageDownloaderOperationInterface，它允许用户自定义下载操作，当然，SDWebImage也提供了自己的下载类，即<code>SDWebImageDownloaderOperation</code>，它继承自NSOperation，并采用了<code>SDWebImageOperation</code>和<code>SDWebImageDownloaderOperationInterface</code>协议。并且实现他们的代理方法。</p>
<p>对于图片的下载，SDWebImageDownloaderOperation完全依赖于URL加载系统中的NSURLSession类。我们先来分析一下SDWebImageDownloaderOperation类中对于图片实际数据的下载处理，即NSURLSessionDataDelegate和NSURLSessionDataDelegate各个代理方法的实现。(ps 有关NSURLSession类的具体介绍<a href="http://www.guiyongdong.com/2016/11/18/NSURLSession%E4%B8%8ENSURLConnection%E5%8C%BA%E5%88%AB/">请戳这里</a>)</p>
<p>我们前面说过SDWebImageDownloaderOperation类是继承自NSOperation类。它没有简单的实现main方法，而是采用更加灵活的start方法，以便自己管理下载的状态。</p>
<p>在start方法中，创建了我们下载所使用的NSURLSession对象，开启了图片的下载，同时抛出一个下载开始的通知。当然，如果我们期望下载在后台处理，则只需要配置我们的下载选项，使其包含SDWebImageDownloaderContinueInBackground选项。start方法的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    	<span class="comment">// 管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">            [<span class="keyword">self</span> reset];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">		...</div><div class="line"></div><div class="line">        <span class="built_in">NSURLSession</span> *session = <span class="keyword">self</span>.unownedSession;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.unownedSession) &#123;</div><div class="line">        		<span class="comment">//如果session为空，创建session</span></div><div class="line">            <span class="built_in">NSURLSessionConfiguration</span> *sessionConfig = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">            sessionConfig.timeoutIntervalForRequest = <span class="number">15</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.ownedSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfig</div><div class="line">                                                              delegate:<span class="keyword">self</span></div><div class="line">                                                         delegateQueue:<span class="literal">nil</span>];</div><div class="line">            session = <span class="keyword">self</span>.ownedSession;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//创建下载任务</span></div><div class="line">        <span class="keyword">self</span>.dataTask = [session dataTaskWithRequest:<span class="keyword">self</span>.request];</div><div class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//开启下载任务</span></div><div class="line">    [<span class="keyword">self</span>.dataTask resume];</div><div class="line">	</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</div><div class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">            progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>, <span class="keyword">self</span>.request.URL);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. 在主线程抛出下载开始通知</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先看看NSURLSessionDataDelegate代理的具体实现：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</div><div class="line">    <span class="comment">//接收到服务器响应</span></div><div class="line">    <span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] || (((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode &lt; <span class="number">400</span> &amp;&amp; ((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode != <span class="number">304</span>)) &#123;</div><div class="line">    	<span class="comment">//如果服务器状态码正常，并且不是304，(因为304表示远程图片并没有改变，当前缓存的图片就可以使用)拿到图片的大小。并进度回调</span></div><div class="line">        <span class="built_in">NSInteger</span> expected = response.expectedContentLength &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)response.expectedContentLength : <span class="number">0</span>;</div><div class="line">        <span class="keyword">self</span>.expectedSize = expected;</div><div class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">            progressBlock(<span class="number">0</span>, expected, <span class="keyword">self</span>.request.URL);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//根据返回数据大小创建一个数据Data容器</span></div><div class="line">        <span class="keyword">self</span>.imageData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];</div><div class="line">        <span class="keyword">self</span>.response = response;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        		<span class="comment">//发送接收到服务器响应通知</span></div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">    	<span class="comment">//状态码错误</span></div><div class="line">        <span class="built_in">NSUInteger</span> code = ((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode;</div><div class="line">        </div><div class="line">        <span class="comment">//判断是不是304</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">304</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> cancelInternal];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [<span class="keyword">self</span>.dataTask cancel];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        		<span class="comment">//发出停止下载通知</span></div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//错误回调</span></div><div class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode userInfo:<span class="literal">nil</span>]];</div><div class="line">			<span class="comment">//重置</span></div><div class="line">        [<span class="keyword">self</span> done];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (completionHandler) &#123;</div><div class="line">        completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    <span class="comment">//1. 接收服务器返回数据 往容器中追加数据</span></div><div class="line">    [<span class="keyword">self</span>.imageData appendData:data];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//2. 获取已下载数据总大小</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = <span class="keyword">self</span>.imageData.length;</div><div class="line"></div><div class="line">        <span class="comment">// 3. 更新数据源，我们需要传入所有数据，而不仅仅是新数据</span></div><div class="line">        <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span>.imageData, <span class="literal">NULL</span>);</div><div class="line">        <span class="comment">// 4. 首次获取到数据时，从这些数据中获取图片的长、宽、方向属性值</span></div><div class="line">        <span class="keyword">if</span> (width + height == <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            <span class="keyword">if</span> (properties) &#123;</div><div class="line">                <span class="built_in">NSInteger</span> orientationValue = <span class="number">-1</span>;</div><div class="line">                <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;height);</div><div class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelWidth);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;width);</div><div class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyOrientation);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberNSIntegerType, &amp;orientationValue);</div><div class="line">                <span class="built_in">CFRelease</span>(properties);</div><div class="line"></div><div class="line">                <span class="comment">// 5. 当绘制到Core Graphics时，我们会丢失方向信息，这意味着有时候由initWithCGIImage创建的图片</span></div><div class="line">                <span class="comment">//    的方向会不对，所以在这边我们先保存这个信息并在后面使用。</span></div><div class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></div><div class="line">                orientation = [[<span class="keyword">self</span> <span class="keyword">class</span>] orientationFromPropertyValue:(orientationValue == <span class="number">-1</span> ? <span class="number">1</span> : orientationValue)];</div><div class="line"><span class="meta">#endif</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 6. 图片还未下载完成</span></div><div class="line">        <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; totalSize &lt; <span class="keyword">self</span>.expectedSize) &#123;</div><div class="line">            <span class="comment">// 7. 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张</span></div><div class="line">            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></div><div class="line">            <span class="comment">// 8. 适用于iOS变形图像的解决方案。我的理解是由于iOS只支持RGB颜色空间，所以在此对下载下来的图片做个颜色空间转换处理。</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);</div><div class="line">                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</div><div class="line">                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">                <span class="keyword">if</span> (bmContext) &#123;</div><div class="line">                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>)&#123;.origin.x = <span class="number">0.0</span>f, .origin.y = <span class="number">0.0</span>f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);</div><div class="line">                    <span class="built_in">CGContextRelease</span>(bmContext);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="literal">nil</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">            <span class="comment">// 9. 对图片进行缩放、解码操作</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></div><div class="line">                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:partialImageRef scale:<span class="number">1</span> orientation:orientation];</div><div class="line"><span class="meta">#elif SD_MAC</span></div><div class="line">                <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:partialImageRef size:<span class="built_in">NSZeroSize</span>];</div><div class="line"><span class="meta">#endif</span></div><div class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">                <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">                    image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    image = scaledImage;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                </div><div class="line">                [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="literal">NO</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">CFRelease</span>(imageSource);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">        progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize, <span class="keyword">self</span>.request.URL);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，在下载完成或下载失败后，会调用NSURLSessionTaskDelegate的<code>- (void)URLSession: task: didCompleteWithError:</code>代理方法，并清除连接，并抛出下载停止的通知。如果下载成功，则会处理完整的图片数据，对其进行适当的缩放与解压缩操作，以提供给完成回调使用。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>下载的核心其实就是利用NSURLSession对象来加载数据。每个图片的下载都由一个Operation操作来完成，并将这些操作放到一个操作队列中。这样可以实现图片的并发下载。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>为了减少网络流量的消耗，我们都希望下载下来的图片缓存到本地，下次再去获取同一张图片时，可以直接从本地获取，而不再从远程服务器获取。这样做的一个好处是提升了用户体验，用户第二次查看同一幅图片时，能快速从本地获取图片直接呈现给用户。</p>
<p>SDWebImage提供了对图片缓存的支持，而该功能是由SDImageCache类完成的。该类负责处理内存缓存及一个可选的磁盘缓存。其中磁盘缓存的写操作是异步的，这样就不会对UI操作造成影响。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>另外说明，在4.0以后新添加一个缓存配置类<code>SDImageCacheConfig</code> ,主要是一些缓存策略的配置。其头文件定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">是否在缓存的时候解压缩，默认是YES 可以提高性能 但是会耗内存。 当使用SDWebImage 因为内存而崩溃 可以将其设置为NO</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 是否禁用 iCloud 备份 默认YES</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDisableiCloud;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 内存缓存  默认YES</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldCacheImagesInMemory;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 最大磁盘缓存时间 默认一周 单位秒</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxCacheAge;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 最大缓存容量 0 表示无限缓存  单位字节</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxCacheSize;</div></pre></td></tr></table></figure>
<h4 id="内存缓存及磁盘缓存"><a href="#内存缓存及磁盘缓存" class="headerlink" title="内存缓存及磁盘缓存"></a>内存缓存及磁盘缓存</h4><p>内存缓存的处理使用NSCache对象来实现的。NSCache是一个类似与集合的容器。它存储key-value对，这一点类似于NSDictionary类。我们通常使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序员来说不是紧要的，在内存紧张时会被丢弃。</p>
<p>磁盘缓存的处理则是使用NSFileManager对象来实现的。图片存储的位置是位于Caches文件夹中的default文件夹下。另外，SDImageCache还定义了一个串行队列，来异步存储图片。</p>
<p>内存缓存与磁盘缓存相关变量的声明及定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDImageCache</span> ()</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Properties</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSCache</span> *memCache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;</div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> ioQueue;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDImageCache</span> </span>&#123;</div><div class="line">    <span class="built_in">NSFileManager</span> *_fileManager;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns</div><div class="line">                       diskCacheDirectory:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)directory &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        <span class="built_in">NSString</span> *fullNamespace = [<span class="string">@"com.hackemist.SDWebImageCache."</span> stringByAppendingString:ns];</div><div class="line">        </div><div class="line">        <span class="comment">// 队列</span></div><div class="line">        _ioQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageCache"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">        <span class="comment">//缓存配置</span></div><div class="line">        _config = [[SDImageCacheConfig alloc] init];</div><div class="line">        </div><div class="line">        <span class="comment">// 内存缓存</span></div><div class="line">        _memCache = [[AutoPurgeCache alloc] init];</div><div class="line">        _memCache.name = fullNamespace;</div><div class="line"></div><div class="line">        <span class="comment">// 初始化磁盘缓存路径</span></div><div class="line">        <span class="keyword">if</span> (directory != <span class="literal">nil</span>) &#123;</div><div class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> makeDiskCachePath:ns];</div><div class="line">            _diskCachePath = path;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">dispatch_sync</span>(_ioQueue, ^&#123;</div><div class="line">            _fileManager = [<span class="built_in">NSFileManager</span> new];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>SDImageCache提供了大量方法来缓存、获取、移除、及清空图片。而对于每一个图片，为了方便地在内存或磁盘中对它进行这些操作，我们需要一个key值来索引它。在内存中，我们将其作为NSCache的key值，而在磁盘中，我们用作这个key作为图片的文件名。对于一个远程服务器下载的图片，其url实作为这个key的最佳选择了。我们在后面会看到这个key值得重要性。</p>
<h4 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h4><p>我们先来看看图片的缓存操作，该操作会在内存中放置一份缓存，而如果确定需要缓存到磁盘，则将磁盘缓存操作作为一个task放到串行队列中处理。在iOS中，会先检测图片是PNG还是JPEG，并将其转换为相应的图片数据，最后将数据写入到磁盘中(文件名是对key值做MD5摘要后的串)。缓存操作的基础方法是：<code>-storeImage:imageData:forKey:toDisk:completion:</code>,它的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</div><div class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</div><div class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</div><div class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</div><div class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</div><div class="line">    <span class="keyword">if</span> (!image || !key) &#123;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 内存缓存 将其存入NSCache中，同时传入图片的消耗值</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</div><div class="line">        [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入ioQueue中</span></div><div class="line">    <span class="keyword">if</span> (toDisk) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">            <span class="built_in">NSData</span> *data = imageData;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (!data &amp;&amp; image) &#123;</div><div class="line">            		<span class="comment">//如果imageData为nil 需要确定图片是PNG还是JPEG。PNG图片容易检测，因为有一个唯一签名。PNG图像的前8个字节总是包含以下值：137 80 78 71 13 10 26 10	</span></div><div class="line">            		<span class="comment">//判断 图片是何种类型 使用 sd_imageFormatForImageData 来判断</span></div><div class="line">            		<span class="comment">// SDImageFormat 是一个枚举  其定义如下：</span></div><div class="line"><span class="comment">//                typedef NS_ENUM(NSInteger, SDImageFormat) &#123;</span></div><div class="line"><span class="comment">//                    SDImageFormatUndefined = -1,</span></div><div class="line"><span class="comment">//                    SDImageFormatJPEG = 0,</span></div><div class="line"><span class="comment">//                    SDImageFormatPNG,</span></div><div class="line"><span class="comment">//                    SDImageFormatGIF,</span></div><div class="line"><span class="comment">//                    SDImageFormatTIFF,</span></div><div class="line"><span class="comment">//                    SDImageFormatWebP</span></div><div class="line"><span class="comment">//                &#125;;</span></div><div class="line">                SDImageFormat imageFormatFromData = [<span class="built_in">NSData</span> sd_imageFormatForImageData:data];</div><div class="line">                <span class="comment">//根据图片类型 转成data</span></div><div class="line">                data = [image sd_imageDataAsFormat:imageFormatFromData];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 4. 创建缓存文件并存储图片</span></div><div class="line">            [<span class="keyword">self</span> storeImageDataToDisk:data forKey:key];</div><div class="line">            <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    completionBlock();</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="查询图片"><a href="#查询图片" class="headerlink" title="查询图片"></a>查询图片</h4><p>如果我们想在内存或磁盘中查询是否有key指定的图片，则可以分别使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//快速查询图片是否已经磁盘缓存 不返回图片 只做快速查询 异步操作</span></div><div class="line">- (<span class="keyword">void</span>)diskImageExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock;</div><div class="line"><span class="comment">//异步查询图片 不管是内存缓存还是磁盘缓存</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</div><div class="line"><span class="comment">//从内存中查询图片</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//从磁盘中查询图片</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//同步查询图片，不管是内存缓存还是磁盘缓存</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure>
<p>其实<code>- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key</code>内部实现是调用了<code>- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key</code>和<code>- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key</code>方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">// 从缓存中查找图片</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 从磁盘中查找图片</span></div><div class="line">    image = [<span class="keyword">self</span> imageFromDiskCacheForKey:key];</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再来看看异步查询图片的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// 1. 首先查看内存缓存，如果查找到，则直接回调doneBlock并返回</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//进行了是否是GIF的判断</span></div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2. 如果内存中没有，则在磁盘中查找。如果找到，则将其放到内存缓存，并调用doneBlock回调</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// do not call the completion if cancelled</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                <span class="comment">//进行内存缓存</span></div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="移除图片"><a href="#移除图片" class="headerlink" title="移除图片"></a>移除图片</h4><p>图片的移除操作则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//从内存和磁盘中移除图片</span></div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion;</div><div class="line"><span class="comment">//从内存 或 可选磁盘中移除图片</span></div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion;</div></pre></td></tr></table></figure>
<p>我们可以选择同时移除内存及磁盘上的图片,或者只移除内存中的图片。</p>
<h4 id="清理图片"><a href="#清理图片" class="headerlink" title="清理图片"></a>清理图片</h4><p>磁盘缓存图片的操作可以分为完全清空和部分清理。完全清空操作是直接把缓存的文件夹移除，部分清理是清理掉过时的旧图片，清空操作有以下方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//清除内存缓存</span></div><div class="line">- (<span class="keyword">void</span>)clearMemory;</div><div class="line"></div><div class="line"><span class="comment">//完全清空磁盘缓存</span></div><div class="line">- (<span class="keyword">void</span>)clearDiskOnCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion;</div><div class="line"></div><div class="line"><span class="comment">//清空旧图片</span></div><div class="line">- (<span class="keyword">void</span>)deleteOldFilesWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</div></pre></td></tr></table></figure>
<p>而部分清理则是根据我们设定的一些参数来移除一些文件，这里主要有两个指标：文件的缓存有效期及最大缓存空间大小。文件的缓存有效期可以通过<code>SDImageCacheConfig</code>类的<code>maxCacheAge</code>属性来设置，默认是1周的时间。如果文件的缓存时间超过这个时间值，则将其移除。而最大缓存空间大小是通过<code>maxCacheSize</code>属性来设置的，如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。清理的操作在<code>-deleteOldFilesWithCompletionBlock:</code>方法中，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)deleteOldFilesWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line"></div><div class="line">        <span class="comment">// 1. 该枚举器预先获取缓存文件的有用的属性</span></div><div class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                                   includingPropertiesForKeys:resourceKeys</div><div class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></div><div class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.config.maxCacheAge];</div><div class="line">        <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *&gt; *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 2. 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作</span></div><div class="line">        <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</div><div class="line">            <span class="built_in">NSError</span> *error;</div><div class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</div><div class="line"></div><div class="line">            <span class="comment">// 3. 跳过文件夹</span></div><div class="line">            <span class="keyword">if</span> (error || !resourceValues || [resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 4. 移除早于有效期的老文件</span></div><div class="line">            <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</div><div class="line">            <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">                [urlsToDelete addObject:fileURL];</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 5. 存储文件的引用并计算所有文件的总大小，以备后用</span></div><div class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</div><div class="line">            cacheFiles[fileURL] = resourceValues;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</div><div class="line">            [_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//6.如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最老的文件</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.config.maxCacheSize) &#123;</div><div class="line">            <span class="comment">// 7. 以设置的最大缓存大小的一半作为清理目标</span></div><div class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.config.maxCacheSize / <span class="number">2</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 8. 按照最后修改时间来排序剩下的缓存文件</span></div><div class="line">            <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></div><div class="line">                                                                     usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</div><div class="line">                                                                         <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</div><div class="line">                                                                     &#125;];</div><div class="line"></div><div class="line">            <span class="comment">// 9. 删除文件，直到缓存总大小降到我们期望的大小</span></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</div><div class="line">                <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</div><div class="line">                    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = cacheFiles[fileURL];</div><div class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>以上分析了图片缓存操作，当然，除了上面讲的几个操作，SDWebImage类还提供了一些辅助方法。如获取缓存大小、缓存中图片的数量、判断缓存中是否存在某个key指定的图片。另外，SDWebImage类提供了一个单例方法的实现，所以我们可以将其当做单例对象来处理。</p>
<h3 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h3><p>在实际的运用中，我们并不直接使用SDWebImageDownloader类及SDImageCache类来执行图片的下载及缓存。为了方便用户的使用，SDWebImage提供了SDWebImageManager对象来管理图片的下载与缓存。而我们经常用到的诸如<code>UIImageView+WebCache</code>等控件的分类都是基于SDWebImageManager对象的，该对象将一个下载器和一个图片缓存绑定在一起，并对外提供两个只读属性来获取它们，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageManager</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> &lt;SDWebImageManagerDelegate&gt; delegate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDImageCache *imageCache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloader *imageDownloader;</div><div class="line">...</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从上面的代码中我们还可以看到一个delegate属性，它是一个<code>id &lt;SDWebImageManagerDelegate&gt;</code>对象。<code>SDWebImageManagerDelegate</code>声明了两个可选实现的方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 控制当图片在缓存中没有找到时，应该下载哪个图片</span></div><div class="line">- (<span class="built_in">BOOL</span>)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="built_in">NSURL</span> *)imageURL;</div><div class="line"><span class="comment">// 允许在图片已经被下载完成且被缓存到磁盘或内存前立即转换</span></div><div class="line">- (<span class="built_in">UIImage</span> *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(<span class="built_in">UIImage</span> *)image withURL:(<span class="built_in">NSURL</span> *)imageURL;</div></pre></td></tr></table></figure>
<p>这两个代理方法会在SDWebImageManager的<code>-downloadImageWithURL:options:progress:completed:</code>方法中调用，而这个方法是SDWebImageManager类的核心所在。我们来看看它具体的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 前面省略n行。主要作了如下处理：</span></div><div class="line">    <span class="comment">// 1. 判断url的合法性</span></div><div class="line">    <span class="comment">// 2. 创建SDWebImageCombinedOperation对象</span></div><div class="line">    <span class="comment">// 3. 查看url是否是之前下载失败过的</span></div><div class="line">    <span class="comment">// 4. 如果url为nil，或者在不可重试的情况下是一个下载失败过的url，则直接返回操作对象并调用完成回调</span></div><div class="line"></div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//先去缓存中查找图片，如果图片不存在  或者 当前图片的下载模式是 SDWebImageRefreshCached 开始下载</span></div><div class="line">        <span class="keyword">if</span> ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</div><div class="line">            ...</div><div class="line">            </div><div class="line">            <span class="comment">//下载</span></div><div class="line">            SDWebImageDownloadToken *subOperationToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    <span class="comment">// 操作被取消，则不做任务事情</span></div><div class="line">                    </div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                    <span class="comment">// 如果出错，则调用完成回调，并将url放入下载失败url数组中	</span></div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    ...</div><div class="line">                    </div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        <span class="comment">// 在全局队列中并行处理图片的缓存</span></div><div class="line">                        <span class="comment">// 首先对图片做个转换操作，该操作是代理对象实现的</span></div><div class="line">                        <span class="comment">// 然后对图片做缓存处理</span></div><div class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? <span class="literal">nil</span> : downloadedData) forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            ...</div><div class="line">                        &#125;);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                        &#125;</div><div class="line">                        ...</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 下载完成并缓存后，将操作从队列中移除</span></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">                [<span class="keyword">self</span>.imageDownloader cancel:subOperationToken];</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            &#125;;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这个方法，我们没有做过多的解释。其主要就是下载图片并根据操作选项缓存图片。上面这个下载方法的操作选项参数是由枚举<code>SDWebImageOptions</code>来定义的，这个操作中的一些选项是与<code>SDWebImageDownloaderOptions</code>中的选项对应的，我们来看看这个<code>SDWebImageOptions</code>选项都有哪些：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageOptions) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，当URL下载失败时，URL会被列入黑名单，导致库不会再去重试，该标记用于禁用黑名单</span></div><div class="line">    SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，图片下载开始于UI交互，该标记禁用这一特性，这样下载延迟到UIScrollView减速时</span></div><div class="line">    SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 该标记禁用磁盘缓存</span></div><div class="line">    SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 该标记启用渐进式下载，图片在下载过程中是渐渐显示的，如同浏览器一下。</span></div><div class="line">    <span class="comment">// 默认情况下，图像在下载完成后一次性显示</span></div><div class="line">    SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 即使图片缓存了，也期望HTTP响应cache control，并在需要的情况下从远程刷新图片。</span></div><div class="line">    <span class="comment">// 磁盘缓存将被NSURLCache处理而不是SDWebImage，因为SDWebImage会导致轻微的性能下载。</span></div><div class="line">    <span class="comment">// 该标记帮助处理在相同请求URL后面改变的图片。如果缓存图片被刷新，则完成block会使用缓存图片调用一次</span></div><div class="line">    <span class="comment">// 然后再用最终图片调用一次</span></div><div class="line">    SDWebImageRefreshCached = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 在iOS 4+系统中，当程序进入后台后继续下载图片。这将要求系统给予额外的时间让请求完成</span></div><div class="line">    <span class="comment">// 如果后台任务超时，则操作被取消</span></div><div class="line">    SDWebImageContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;来处理存储在NSHTTPCookieStore中的cookie</span></div><div class="line">    SDWebImageHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 允许不受信任的SSL认证</span></div><div class="line">    SDWebImageAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，图片下载按入队的顺序来执行。该标记将其移到队列的前面，</span></div><div class="line">    <span class="comment">// 以便图片能立即下载而不是等到当前队列被加载</span></div><div class="line">    SDWebImageHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，占位图片在加载图片的同时被加载。该标记延迟占位图片的加载直到图片已以被加载完成</span></div><div class="line">    SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通常我们不调用动画图片的transformDownloadedImage代理方法，因为大多数转换代码可以管理它。</span></div><div class="line">    <span class="comment">// 使用这个票房则不任何情况下都进行转换。</span></div><div class="line">    SDWebImageTransformAnimatedImage = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>大家再看<code>-downloadImageWithURL:options:progress:completed:</code>，可以看到两个<code>SDWebImageOptions</code>与<code>SDWebImageDownloaderOptions</code>中的选项是如何对应起来的，在此不多做解释。</p>
<h3 id="视图扩展"><a href="#视图扩展" class="headerlink" title="视图扩展"></a>视图扩展</h3><p>我们在使用SDWebImage的时候，使用最多的是<code>UIImageView+WebCache</code>中的针对<code>UIImageView</code>的扩展方法，这些扩展方法将<code>UIImageView</code>与<code>WebCache</code>集成在一起，来让<code>UIImageView</code>对象拥有异步下载和缓存远程图片的能力。在4.0.0版本以后，给UIView新增了好多方法，其中最之前<code>UIImageView+WebCache</code>最核心的方法<code>-sd_setImageWithURL:placeholderImage:options:progress:completed:</code>，现在使用的是<code>UIView+WebCache</code>中新增的方法<code>sd_internalSetImageWithURL:placeholderImage:options:operationKey:setImageBlock:progress:completed:</code>,其使用<code>SDWebImageManager</code>单例对象下载并缓存图片，完成后将图片赋值给<code>UIImageView</code>对象的image属性，以使图片显示出来，其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</div><div class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock &#123;</div><div class="line">    </div><div class="line">	...</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (url) &#123;</div><div class="line">        <span class="comment">// check if activityView is enabled or not</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> sd_showActivityIndicatorView]) &#123;</div><div class="line">            [<span class="keyword">self</span> sd_addActivityIndicator];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line">        <span class="comment">// 使用SDWebImageManager单例对象来下载图片</span></div><div class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">            [sself sd_removeActivityIndicator];</div><div class="line">            <span class="keyword">if</span> (!sself) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            dispatch_main_async_safe(^&#123;</div><div class="line">                <span class="keyword">if</span> (!sself) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                    <span class="comment">// 图片下载完后显示图片</span></div><div class="line">                    [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                    [sself sd_setNeedsLayout];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                        [sself sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                        [sself sd_setNeedsLayout];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了扩展<code>UIImageView</code>之外，SDWebImage还扩展了<code>UIView</code>、<code>UIButton</code>、<code>MKAnnotationView</code>等视图类，大家可以参考源码。</p>
<p>当然，如果不想使用这些扩展，则可以直接使用SDWebImageManager来下载图片，这也是很OK的。</p>
<h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><p>SDWebImage的主要任务就是图片的下载和缓存。为了支持这些操作，它主要使用了以下知识点：</p>
<ul>
<li><code>dispatch_barrier_sync</code>函数：该方法用于对操作设置等待，确保在执行完任务后才会执行后续操作。该方法常用于确保类的线程安全性操作。</li>
<li><code>NSMutableURLRequest</code>：用于创建一个网络请求对象，我们可以根据需要来配置请求报头等信息。</li>
<li><code>NSOperation</code>及<code>NSOperationQueue</code>：操作队列是Objective-C中一种高级的并发处理方法，现在它是基于GCD来实现的。相对于GCD来说，操作队列的优点是可以取消在任务处理队列中的任务，另外在管理操作间的依赖关系方面也容易一些。对SDWebImage中我们就看到了如何使用依赖将下载顺序设置成后进先出的顺序。(有兴趣的同学可以看看我这篇博客-&gt;<a href="http://www.guiyongdong.com/2016/09/18/%E8%81%8A%E4%B8%80%E8%81%8ANSOperation%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/">聊一聊NSOperation的那些事</a>)</li>
<li>NSURLSession：用于网络请求及响应处理。在iOS7.0后，苹果推出了一套新的网络请求接口，即NSURLSession类。(有兴趣的同学可以看看我这篇博客-&gt;<a href="http://www.guiyongdong.com/2016/11/18/NSURLSession%E4%B8%8ENSURLConnection%E5%8C%BA%E5%88%AB/">NSURLSession与NSURLConnection区别</a>)</li>
<li>开启一个后台任务。</li>
<li><code>NSCache</code>类：一个类似于集合的容器。它存储key-value对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</li>
<li>清理缓存图片的策略：特别是最大缓存空间大小的设置。如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</li>
<li>对图片的解压缩操作：这一操作可以查看<code>SDWebImageDecoder.m</code>中<code>+decodedImageWithImage</code>方法的实现。</li>
<li>对GIF图片的处理</li>
<li>对WebP图片的处理</li>
<li>对cell的重用机制的解决，利用runtime的关联对象，会为imageView对象关联一个下载列表，当tableView滑动时，imageView重设数据源（url）时，会cancel掉下载列表中所有的任务，然后开启一个新的下载任务。这样子就保证了只有当前可见的cell对象的imageView对象关联的下载任务能够回调，不会发生image错乱。</li>
</ul>
<p>感兴趣的同学可以深入研究一下这些知识点。当然，这只是其中一部分，更多的知识还有待大家去发掘。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDWebImage是一个开源的第三方库，它提供了UIImageView的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供UIImageView的一个分类，以支持网络图片的加载与缓存管理&lt;/li&gt;
&lt;li&gt;一个异步的图片加载器&lt;/li&gt;
&lt;li&gt;一个异步的内存+磁盘图片缓存&lt;/li&gt;
&lt;li&gt;支持GIF图片&lt;/li&gt;
&lt;li&gt;支持WebP图片&lt;/li&gt;
&lt;li&gt;后台图片解压缩处理&lt;/li&gt;
&lt;li&gt;确保同一个URL不会被反复加载&lt;/li&gt;
&lt;li&gt;确保下载及缓存时，主线程不被堵塞&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从github上对SDWebImage使用情况可以看出，SDWebImage在图片下载及缓存的处理还是被认可的。在本文中，我们主要从源码的角度来分析一下SDWebImage的实现机制。讨论的内容将主要集中在图片的下载及缓存，而不包含对GIF图片及WebP图片的支持操作。不过在3.8.2版本以后，SDWebImage将会使用NSURLSession代替原来的NSURLConnection，主要是更新的是下载功能部分。具体变化可以看:&lt;a href=&quot;https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImage-4.0-Migration-guide.md&quot;&gt;点这里&lt;/a&gt;。目前截止到当前时间，最新的版本为4.0.0-beta2,这篇文章是在4.0.0-beta2基础上进行剖析。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.guiyongdong.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://www.guiyongdong.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 运行时之六：拾遗</title>
    <link href="http://www.guiyongdong.com/2017/01/03/Objective-C-Runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E5%85%AD%EF%BC%9A%E6%8B%BE%E9%81%97/"/>
    <id>http://www.guiyongdong.com/2017/01/03/Objective-C-Runtime-运行时之六：拾遗/</id>
    <published>2017-01-03T07:08:47.000Z</published>
    <updated>2017-03-09T07:03:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇基本介绍了runtime中的大部分功能，包括对类与对象、成员变量与属性、方法与消息、分类与协议的处理。runtime大部分的功能都是围绕这几点来实现的。</p>
<p>本章的内容并不算重点，主要针对前文中对Objective-C Runtime Reference内容遗漏的地方做些补充。当然这并不能包含所有的内容。runtime还有许多内容。</p>
<a id="more"></a>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>在Objective-C中，如果我们需要在类的方法中调用父类的方法时，通常都会用到<code>super</code>，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span>	<span class="title">MyViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">	[<span class="keyword">super</span> viewDidLoad];</div><div class="line">	<span class="comment">// do something</span></div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>如何使用super我们都知道。现在的问题是，它是如何工作的呢？</p>
<p>首先我们需要知道的是super与self不同。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。为了理解这一点，我们先来看看super的定义</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_super &#123; <span class="keyword">id</span> receiver; Class superClass; &#125;;</div></pre></td></tr></table></figure>
<p>这个结构体有两个成员：</p>
<ul>
<li>receiver：即消息的实际接收者</li>
<li>superClass：指针当前类的父类</li>
</ul>
<p>当我们使用super来接收消息时，编译器会生成一个objc_super结构体。就上面的例子而言，这个结构体的receiver就是MyViewController对象，与self相同；superClass指向MyViewController的父类UIViewController。</p>
<p>接下来，发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> objc_msgSendSuper ( <span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ... );</div></pre></td></tr></table></figure>
<p>该函数第一个参数即为前面生成的objc_super结构体，第二个参数是方法的selector。该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找viewDidLoad的selector，找到后以objc-&gt;receiver去调用这个selector，而此时的操作流程就是如下方式了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">objc_msgSend(objc_super-&gt;receiver, <span class="keyword">@selector</span>(viewDidLoad))</div></pre></td></tr></table></figure>
<p>由于objc_super-&gt;receiver就是self本身，所以该方法实际与下面这个调用是相同的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">objc_msgSend(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewDidLoad))</div></pre></td></tr></table></figure>
<p>为了便于理解，我们看以下实例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self class: %@"</span>, <span class="keyword">self</span>.class);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super class: %@"</span>, <span class="keyword">super</span>.class);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>调用MyClass的test方法后，其输出是：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">03.256</span> [<span class="number">824</span>:<span class="number">209297</span>] <span class="keyword">self</span> <span class="keyword">class</span>: MyClass</div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">03.256</span> [<span class="number">824</span>:<span class="number">209297</span>] <span class="keyword">super</span> <span class="keyword">class</span>: MyClass</div></pre></td></tr></table></figure>
<p>从上例中可以看到，两者的输出都是MyClass。</p>
<h4 id="库相关操作"><a href="#库相关操作" class="headerlink" title="库相关操作"></a>库相关操作</h4><p>库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取所有加载的Objective-C框架和动态库的名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyImageNames ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取指定类所在动态库</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getImageName ( Class cls );</div><div class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyClassNamesForImage ( <span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<p>通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"获取指定类所在动态库"</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"UIView's Framework: %s"</span>, class_getImageName(<span class="built_in">NSClassFromString</span>(<span class="string">@"UIView"</span>)));</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"获取指定库或框架中所有类的类名"</span>);</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** classes = objc_copyClassNamesForImage(class_getImageName(<span class="built_in">NSClassFromString</span>(<span class="string">@"UIView"</span>)), &amp;outCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, classes[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">2014-11-08 12:57:32.689 [747:184013] 获取指定类所在动态库</div><div class="line">2014-11-08 12:57:32.690 [747:184013] UIView's Framework: /System/Library/Frameworks/UIKit.framework/UIKit</div><div class="line">2014-11-08 12:57:32.690 [747:184013] 获取指定库或框架中所有类的类名</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: UIKeyboardPredictiveSettings</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: _UIPickerViewTopFrame</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: _UIOnePartImageView</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewSelectionBar</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerWheelView</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewTestParameters</div><div class="line">......</div></pre></td></tr></table></figure>
<h4 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h4><p>我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></div><div class="line">IMP imp_implementationWithBlock ( <span class="keyword">id</span> block );</div><div class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></div><div class="line"><span class="keyword">id</span> imp_getBlock ( IMP anImp );</div><div class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></div><div class="line"><span class="built_in">BOOL</span> imp_removeBlock ( IMP anImp );</div></pre></td></tr></table></figure>
<ul>
<li>imp_implementationWithBlock函数：参数block的签名必须是method_return_type ^(id self, method_args …)形式的。该方法能让我们使用block作为IMP。如下代码所示：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyRuntimeBlock</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span>	</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyRuntimeBlock</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">// 测试代码</span></div><div class="line">IMP imp = imp_implementationWithBlock(^(<span class="keyword">id</span> obj, <span class="built_in">NSString</span> *str) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</div><div class="line">&#125;);</div><div class="line">class_addMethod(MyRuntimeBlock.class, <span class="keyword">@selector</span>(testBlock:), imp, <span class="string">"v@:@"</span>);</div><div class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</div><div class="line">[runtime performSelector:<span class="keyword">@selector</span>(testBlock:) withObject:<span class="string">@"hello world!"</span>];</div></pre></td></tr></table></figure>
<p>输出结果是</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-09</span> <span class="number">14</span>:<span class="number">03</span>:<span class="number">19.779</span> [<span class="number">1172</span>:<span class="number">395446</span>] hello world!</div></pre></td></tr></table></figure>
<h4 id="弱引用操作"><a href="#弱引用操作" class="headerlink" title="弱引用操作"></a>弱引用操作</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 加载弱引用指针引用的对象并返回</span></div><div class="line"><span class="keyword">id</span> objc_loadWeak ( <span class="keyword">id</span> *location );</div><div class="line"><span class="comment">// 存储__weak变量的新值</span></div><div class="line"><span class="keyword">id</span> objc_storeWeak ( <span class="keyword">id</span> *location, <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure>
<ul>
<li>objc_loadWeak函数：该函数加载一个弱指针引用的对象，并在对其做retain和autoreleasing操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用__weak变量的表达式中使用。</li>
<li>objc_storeWeak函数：该函数的典型用法是用于__weak变量做为赋值对象时。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此，本系列对runtime的整理已完结。当然这只是对runtime的一些基础知识的归纳，力图起个抛砖引玉的作用。还有许多关于runtime有意思东西还需要读者自己去探索发现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几篇基本介绍了runtime中的大部分功能，包括对类与对象、成员变量与属性、方法与消息、分类与协议的处理。runtime大部分的功能都是围绕这几点来实现的。&lt;/p&gt;
&lt;p&gt;本章的内容并不算重点，主要针对前文中对Objective-C Runtime Reference内容遗漏的地方做些补充。当然这并不能包含所有的内容。runtime还有许多内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C-Runtime运行时之五：协议与分类</title>
    <link href="http://www.guiyongdong.com/2016/12/18/Objective-C-Runtime%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%BA%94%EF%BC%9A%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E7%B1%BB/"/>
    <id>http://www.guiyongdong.com/2016/12/18/Objective-C-Runtime运行时之五：协议与分类/</id>
    <published>2016-12-18T06:25:59.000Z</published>
    <updated>2017-03-09T07:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C中的分类允许我们通过一个类添加方法来扩充它（但是通过category不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。</p>
<p>Objective-C中的协议是普遍存在的接口定义方式，即在一个类中通过<code>@protocol</code>定义接口，在另外类中实现接口，这种接口定义方式也成为“delegation”模式，<code>@protocol</code>声明了可以被其他任何类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。</p>
<p>在本章中，我们来看看runtime对分类与协议的支持。</p>
<a id="more"></a>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><h5 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h5><p>Category是表示一个指向分类的结构体的指针，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</div><div class="line"><span class="keyword">struct</span> objc_category &#123;</div><div class="line">    <span class="keyword">char</span> *category_name                          OBJC2_UNAVAILABLE;	<span class="comment">// 分类名</span></div><div class="line">    <span class="keyword">char</span> *class_name                             OBJC2_UNAVAILABLE;	<span class="comment">// 分类所属的类名</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list *instance_methods    OBJC2_UNAVAILABLE;	<span class="comment">// 实例方法列表</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list *class_methods       OBJC2_UNAVAILABLE;	<span class="comment">// 类方法列表</span></div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols         OBJC2_UNAVAILABLE;	<span class="comment">// 分类所实现的协议列表</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个结构体主要包含了分类定义的实例方法与类方法，其中<code>instance_methods</code>列表是元类方法列表的一个子集。</p>
<h5 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h5><p>Protocol的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object Protocol;</div></pre></td></tr></table></figure>
<p>我们可以看到，Protocol其实就是一个对象结构体。</p>
<h5 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h5><p>Runtime并没有在<code>&lt;objc/runtime.h&gt;</code>头文件中提供针对分类的操作函数。因为这些分类中的信息都包含在<code>objc_class</code>中，我们可以通过针对<code>objc_class</code>的操作函数来获取分类的信息。如下里所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)method1;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span></span></div><div class="line">- (<span class="keyword">void</span>)method1 &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"测试objc_class中的方法列表是否包含分类中的方法"</span>);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">    Method method = methodList[i];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_getName(method_getName(method));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"RuntimeCategoryClass's method: %s"</span>, name);</div><div class="line">    <span class="keyword">if</span> (strcmp(name, sel_getName(<span class="keyword">@selector</span>(method2)))) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"分类方法method2在objc_class的方法列表中"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其输出是：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">2014-11-08 10:36:39.213 [561:151847] 测试objc_class中的方法列表是否包含分类中的方法</div><div class="line">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method2</div><div class="line">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method1</div><div class="line">2014-11-08 10:36:39.215 [561:151847] 分类方法method2在objc_class的方法列表中</div></pre></td></tr></table></figure>
<p>而对于Protocol，runtime提供了一系列函数来对其进行操作，这些函数包括：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回指定的协议</span></div><div class="line">Protocol * objc_getProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></div><div class="line">Protocol ** objc_copyProtocolList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 创建新的协议实例</span></div><div class="line">Protocol * objc_allocateProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 在运行时中注册新创建的协议</span></div><div class="line"><span class="keyword">void</span> objc_registerProtocol ( Protocol *proto );</div><div class="line"><span class="comment">// 为协议添加方法</span></div><div class="line"><span class="keyword">void</span> protocol_addMethodDescription ( Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></div><div class="line"><span class="keyword">void</span> protocol_addProtocol ( Protocol *proto, Protocol *addition );</div><div class="line"><span class="comment">// 为协议添加属性</span></div><div class="line"><span class="keyword">void</span> protocol_addProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"><span class="comment">// 返回协议名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * protocol_getName ( Protocol *p );</div><div class="line"><span class="comment">// 测试两个协议是否相等</span></div><div class="line"><span class="built_in">BOOL</span> protocol_isEqual ( Protocol *proto, Protocol *other );</div><div class="line"><span class="comment">// 获取协议中指定条件的方法的方法描述数组</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></div><div class="line"><span class="keyword">struct</span> objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"><span class="comment">// 获取协议中的属性列表</span></div><div class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取协议的指定属性</span></div><div class="line">objc_property_t protocol_getProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"><span class="comment">// 获取协议采用的协议</span></div><div class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></div><div class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</div></pre></td></tr></table></figure>
<ul>
<li><code>objc_getProtocol</code>函数，需要注意的是如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是nil。</li>
<li><code>objc_copyProtocolList</code>函数，获取的数值需要使用free来释放。</li>
<li><code>objc_allcateProtocol</code>函数，如果同名的协议已经存在，则返回nil.</li>
<li><code>objc_registerProtocol</code>函数，创建一个新的协议后，必须调用该函数以在运行时钟注册新的协议。协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议。</li>
</ul>
<p>需要强调的是，协议一旦注册后就不能修改，即无法再通过调用<code>protocol_addMethodDescription</code>、<code>protocol_addProtocol</code>和<code>protocol_addProperty</code>往协议中添加方法等。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Runtime并没有提供过多的函数来处理分类。对于协议，我们可以动态地创建协议，并向其添加方法、属性及继承的协议，并在运行时动态地获取这些信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C中的分类允许我们通过一个类添加方法来扩充它（但是通过category不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。&lt;/p&gt;
&lt;p&gt;Objective-C中的协议是普遍存在的接口定义方式，即在一个类中通过&lt;code&gt;@protocol&lt;/code&gt;定义接口，在另外类中实现接口，这种接口定义方式也成为“delegation”模式，&lt;code&gt;@protocol&lt;/code&gt;声明了可以被其他任何类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。&lt;/p&gt;
&lt;p&gt;在本章中，我们来看看runtime对分类与协议的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 运行时之四：Method Swizzling</title>
    <link href="http://www.guiyongdong.com/2016/12/09/Objective-C-Runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E5%9B%9B%EF%BC%9AMethod-Swizzling/"/>
    <id>http://www.guiyongdong.com/2016/12/09/Objective-C-Runtime-运行时之四：Method-Swizzling/</id>
    <published>2016-12-09T05:02:51.000Z</published>
    <updated>2017-03-09T07:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>理解<code>Method Swizzling</code>是学习Runtime机制的一个很好的机会。<code>Method Swizzling</code>是改变一个<code>selector</code>的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中<code>selector</code>对应的函数，来修改方法的实现。</p>
<a id="more"></a>
<p>例如，我们想跟踪在程序中每一个ViewController展示给用户的次数：当然，我们可以在每个ViewController的viewDidAppear中添加跟踪代码，但是这太过麻烦，需要在每个ViewController中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController，UITableController，UINavigationController及其他UIKit中ViewController的子类，这样会产生许多重复的代码。</p>
<p>这种情况下，我们就可以使用<code>Method Swizzling</code>，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];         </div><div class="line">        <span class="comment">// When swizzling a class method, use the following:</span></div><div class="line">        <span class="comment">// Class class = object_getClass((id)self);</span></div><div class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</div><div class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</div><div class="line">        <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</div><div class="line">                originalSelector,</div><div class="line">                method_getImplementation(swizzledMethod),</div><div class="line">                method_getTypeEncoding(swizzledMethod));</div><div class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</div><div class="line">            class_replaceMethod(<span class="keyword">class</span>,</div><div class="line">                swizzledSelector,</div><div class="line">                method_getImplementation(originalMethod),</div><div class="line">                method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark - Method Swizzling</span></div><div class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这里，我们通过<code>Method Swizzling</code>修改了UIViewController的<code>@selector(viewWillAppear:)</code>对应的函数指针，使其实现指向了我们自定义的<code>xxx_viewWillAppear</code>的实现。这样，当UIViewController及其子类的对象调用<code>viewWillAppear</code>时，都会打印一条日志信息。</p>
<p>上面的例子很好地展示了使用<code>Method Swizlling</code>来一个类中注入一些我们新的操作。当然，还有许多场景可以使用<code>Mehtod Swizlling</code>，在此不多举例。在此我们说说使用<code>method Swizlling</code>需要注意的一些问题。</p>
<h3 id="Swizzling应该总是在-load中执行"><a href="#Swizzling应该总是在-load中执行" class="headerlink" title="Swizzling应该总是在+load中执行"></a>Swizzling应该总是在+load中执行</h3><p>在Objective-C中，运行时会自动调用每个类的两个方法。<code>+load</code><em>会在类初始加载时调用</em>，<code>+initialize</code><em>会在第一次调用类的类方法或实例方法之前被调用</em>。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>
<h3 id="Swizzling应该总是在dispatch-once中执行"><a href="#Swizzling应该总是在dispatch-once中执行" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a>Swizzling应该总是在dispatch_once中执行</h3><p>与上面相同，因为<code>swizzling</code>会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的<code>dispatch_once</code>可以确保这种行为，我们应该将其作为<code>method swizzling</code>的最佳实践。</p>
<h3 id="选择器、方法与实现"><a href="#选择器、方法与实现" class="headerlink" title="选择器、方法与实现"></a>选择器、方法与实现</h3><p>在Objective-C中，选择器(<code>selector</code>)、方法(<code>method</code>)和实现(<code>implementation</code>)是运行时中一个特殊点，虽然在一般情况下，这些术语更多的是用在消息发送的过程描述中。</p>
<p>以下是<code>Objective-C Runtime Reference</code>中的对这几个术语一些描述：</p>
<ul>
<li><code>Selector(typedef struct objc_selector *SEL)</code>：用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。</li>
<li><code>Method(typedef struct objc_method *Method)</code>：在类定义中表示方法的类型</li>
<li><code>Implementation(typedef id (*IMP)(id, SEL, ...))</code>：这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。</li>
</ul>
<p>理解这几个术语之间的关系最好的方式是：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(Method)，其中key是一个特定名称，即选择器(SEL)，其对应一个实现(IMP)，即指向底层C函数的指针。</p>
<p>为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。</p>
<h3 id="调用-cmd"><a href="#调用-cmd" class="headerlink" title="调用_cmd"></a>调用_cmd</h3><p>我们回过头来看看前面新的方法的实现代码：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的<code>[self xxx_viewWillAppear:animated]</code>已经被重新指定到UIViewController类的<code>-viewWillAppear:</code>中。在这种情况下，不会产生无限循环。不过如果我们调用的是<code>[self viewWillAppear:animated]</code>，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为<code>xxx_viewWillAppear:</code>了。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Swizzling通常被称作是一种黑魔法，容易产生不可预知的行为和无法预见的后果。虽然它不是最安全的，但如果遵从以下几点预防措施的话，还是比较安全的：</p>
<ol>
<li>总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。</li>
<li>避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。</li>
<li>明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读<code>Objective-C Runtime Reference</code>和查看<code>&lt;objc/runtime.h&gt;</code>头文件以了解事件是如何发生的。</li>
<li>小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解&lt;code&gt;Method Swizzling&lt;/code&gt;是学习Runtime机制的一个很好的机会。&lt;code&gt;Method Swizzling&lt;/code&gt;是改变一个&lt;code&gt;selector&lt;/code&gt;的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中&lt;code&gt;selector&lt;/code&gt;对应的函数，来修改方法的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 运行时之三：方法与消息</title>
    <link href="http://www.guiyongdong.com/2016/11/25/Objective-C-Runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B6%88%E6%81%AF/"/>
    <id>http://www.guiyongdong.com/2016/11/25/Objective-C-Runtime-运行时之三：方法与消息/</id>
    <published>2016-11-25T06:05:08.000Z</published>
    <updated>2017-03-09T07:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。</p>
<a id="more"></a>
<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>SEL又叫选择器，是表示一个方法的<code>selector</code>的指针，其定义如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure></p>
<p><code>objc_selector</code>结构体的详细定义没有在<code>&lt;objc/runtime.h&gt;</code>头文件中找到。方法的<code>selector</code>用于表示运行时方法的名字。Objective-C在编译时，会根据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的标识)，这个标识就是<code>SEL</code>。如下代码所示:<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">SEL sel1 = <span class="keyword">@selector</span>(method1);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"sel : %p"</span>, sel1);</div></pre></td></tr></table></figure></p>
<p>上面的输出结果为：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-30</span> <span class="number">18</span>:<span class="number">40</span>:<span class="number">07.518</span> RuntimeTest[<span class="number">52734</span>:<span class="number">466626</span>] sel : <span class="number">0x100002d72</span></div></pre></td></tr></table></figure></p>
<p>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的，每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如果某个类中定义以下两个方法：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">int</span>)width;</div><div class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)width;</div></pre></td></tr></table></figure></p>
<p>这样的定义被认为是一种编译错误，所以我们不能像C++,C#那样。而是需要像下面这样来声明：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)setWidthIntValue:(<span class="keyword">int</span>)width;</div><div class="line">-(<span class="keyword">void</span>)setWidthDoubleValue:(<span class="keyword">double</span>)width;</div></pre></td></tr></table></figure></p>
<p>当然，不同的类可以拥有相同的Selector，这个没有问题。不同的类的实例对象执行相同的Selector时，会在各自的方法列表中根据Selector去寻找自己对应的IMP。</p>
<p>工程中的所有SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无与伦比！但是，一个问题，就是数据增多会增大hash冲突而导致的性能下降(或是没有冲突，因为也可能用的是prefecthash)。但不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL）。那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。</p>
<p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>
<p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL：</p>
<ul>
<li><code>sel_registerName</code>函数</li>
<li>Objective-C编译器提供的<code>@selector()</code></li>
<li><code>NSSelectorFromString()</code>方法</li>
</ul>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...)</div></pre></td></tr></table></figure></p>
<p>这个函数使用当前CPU架构实现的标准C调用约定。第一个参数是指向self的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针），第二个参数是方法选择器（selector），接下来是方法的实际参数列表。</p>
<p>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每一个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<p>通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>介绍完SEL和IMP，我们就可以来讲讲Method了。Method用于表示类定义的方法，定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"><span class="keyword">struct</span> objc_method &#123;</div><div class="line">    SEL method_name                	OBJC2_UNAVAILABLE;	<span class="comment">// 方法名</span></div><div class="line">    <span class="keyword">char</span> *method_types                	OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp             			OBJC2_UNAVAILABLE;	<span class="comment">// 方法实现</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有个SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。具体的操作流程我们将在下面讨论。</p>
<h5 id="objc-method-description"><a href="#objc-method-description" class="headerlink" title="objc_method_description"></a>objc_method_description</h5><p><code>objc_method_description</code>定义了一个Objective-C方法，其定义如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_method_description &#123; SEL name; <span class="keyword">char</span> *types; &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="方法相关操作函数"><a href="#方法相关操作函数" class="headerlink" title="方法相关操作函数"></a>方法相关操作函数</h3><p>Runtime提供了一系列的方法来处理与方法相关的操作。包括方法本身及SEL。本节我们介绍一下这些函数。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法操作相关函数包括以下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 调用指定方法的实现</span></div><div class="line"><span class="keyword">id</span> method_invoke ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></div><div class="line"><span class="keyword">void</span> method_invoke_stret ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 获取方法名</span></div><div class="line">SEL method_getName ( Method m );</div><div class="line"><span class="comment">// 返回方法的实现</span></div><div class="line">IMP method_getImplementation ( Method m );</div><div class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * method_getTypeEncoding ( Method m );</div><div class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyReturnType ( Method m );</div><div class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index );</div><div class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getReturnType ( Method m, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回方法的参数的个数</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments ( Method m );</div><div class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * method_getDescription ( Method m );</div><div class="line"><span class="comment">// 设置方法的实现</span></div><div class="line">IMP method_setImplementation ( Method m, IMP imp );</div><div class="line"><span class="comment">// 交换两个方法的实现</span></div><div class="line"><span class="keyword">void</span> method_exchangeImplementations ( Method m1, Method m2 );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数<code>receiver</code>不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><code>method_getName</code>函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li>
<li><code>method_getReturnType</code>函数，类型字符串会被拷贝到dst中。</li>
<li><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</li>
</ul>
<h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h4><p>选择器相关的操作函数包括：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * sel_getName ( SEL sel );</div><div class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></div><div class="line">SEL sel_registerName ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法</span></div><div class="line">SEL sel_getUid ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"><span class="comment">// 比较两个选择器</span></div><div class="line"><span class="built_in">BOOL</span> sel_isEqual ( SEL lhs, SEL rhs );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>sel_registerName</code>函数：在我们将一个方法添加到类定义时，我们必须在<code>Objective Runtime</code>系统中注册一个方法名以获取方法的选择器。</li>
</ul>
<h3 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h3><p>在Objective-C中，消息直到运行时在绑定到方法实现上。编译器会将消息表达式<code>[receiver message]</code>转化为一个消息函数的调用，即<code>objc_msgSend</code>。这个函数将消息接收者和方法名作为其基础参数，如以下所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure></p>
<p>如果消息中还有其他参数，则该方法的形式如下所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure></p>
<p>这个函数完成了动态绑定的所有事情：</p>
<ol>
<li>首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以需要依赖接收者的类来找到确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ol>
<p>消息的关键在于我们前面章节讨论过的结构体<code>Objc_class</code>，这个结构体有两个字段是我们在消息分发的关注的：</p>
<ol>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即<code>methodLists</code></li>
</ol>
<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。</p>
<p>下图演示了这样一个消息的基本框架：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/runtime1.png?raw=true"><br></div>

<p>当消息发送给一个对象时，<code>objc_msgSend</code>通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过<code>objc_msgSend</code>结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿用类的继承体系到达NSObject类。一旦定位到selector，函数就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程，这个我们在后面讨论。</p>
<p>为了加速消息的处理，运行时系统缓存使用过的selector及对应的方法的地址。这点我们在前面讨论对，不再重复。</p>
<h4 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h4><p><code>objc_msgSend</code>有两个隐藏参数：</p>
<ol>
<li>消息接收对象</li>
<li>方法的selector</li>
</ol>
<p>这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。它们是在编译器被插入实现代码的。</p>
<p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用self来引用接收者对象，使用<code>_cmd</code>来引用选择器。代码如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span>  target = getTheReceiver();</div><div class="line">    SEL method = getTheMethod();</div><div class="line">    <span class="keyword">if</span> ( target == <span class="keyword">self</span> || method == _cmd )</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，这两个参数我们用的比较多的是self,<code>_cmd</code>在实际中用的比较少。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>Runtime中方法的动态绑定让我们写代码时更具灵活性。如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来的那么直接。当然，方法的缓存一定程度上解决了这一问题。</p>
<p>我们上面提到过，我们想要避开这种动态绑定方法，我们可以获取方法实现的地址，然后想调用函数一样来直接调用它。特别是当我们需要一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>
<p>NSObject类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p>
<p>我们通过以下代码来看看<code>methodForSelector:</code>的使用：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++)</div><div class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure></p>
<p>这里需要注意的就是函数指针的前两个参数必须是id和SEL。</p>
<p>当然这种方式只适合于在类似于for循环这种情况下频繁调用同一方法，以提高性能的情况。另外，<code>methodForSelector:</code>是由Cocoa运行时提供的；它不是Objective-C语言的特性。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>当一个对象能接收到一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定的消息时，又会发生什么事呢？默认情况下，如果是以<code>[object message]</code>的方式调用方法，如果<code>object</code>无法响应<code>message</code>消息时，编译器会报错。但如果是以<code>perfrom...</code>的形式来调用，则需要等到运行时才能确定object是否能接收<code>message</code>消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(method)]) &#123;</div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method)];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过，我们这边想讨论下不使用<code>respondsToSelector:</code>判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓’<em>消息转发(message forwarding)</em>‘机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940</div><div class="line">*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940'</div></pre></td></tr></table></figure></p>
<p>这段异常信息实际上是由NSObject的<code>doesNotRecognizeSelector</code>方法抛出来的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>下面我们详细讨论一下这三个步骤。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>对象在接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)。在这个方法中，我们有机会为该未知消息新增一个“处理方法”。不过使用该方法的前提是我们已经实现了该“处理方法”，只需要在运行时通过<code>class_addMethod</code>函数动态添加到类里面就可以了。如下代码所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</div><div class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method1"</span>]) &#123;</div><div class="line">        class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">"@:"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过这种方案更多的是为了实现<code>@dynamic</code>属性。</p>
<h4 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h4><p>如果在上一步无法处理消息，则Runtime会继续调用以下方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>
<p>如果一个对象实现了这个方法，并返回一个非nil得结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是<code>self</code>吱声，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理<code>aSelector</code>，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其他对象处理该消息，我们便可以用这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethodHelper</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethodHelper</span></span></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethod</span> () </span>&#123;</div><div class="line">    SUTRuntimeMethodHelper *_helper;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethod</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)object &#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</div><div class="line">        _helper = [[SUTRuntimeMethodHelper alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method2)];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</div><div class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(aSelector);</div><div class="line">    <span class="comment">// 将消息转发给_helper来处理</span></div><div class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method2"</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> _helper;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这一步适合于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h4 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h4><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</div></pre></td></tr></table></figure></p>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其他对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在<code>anInvocation</code>中，包括<code>selector</code>,目标（<code>target</code>）和参数。我们可以在<code>forwardInvocation</code>方法中选择将消息转发给其他对象。</p>
<p><code>forwardInvocation</code>方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在<code>anInvocation</code>中的消息对象。这个对象不需要能处理所有未知消息。</li>
<li>使用<code>anInvocation</code>作为参数，将消息发送给选中的对象。<code>anInvocation</code>将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去出发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重新写以下方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>
<p>消息转发机制使用从这个方法中获取的信息来创建<code>NSInvocation</code>对象。因此我们必须重写这个方法，为给定的selector提供一个合适的签名方法。</p>
<p>完整的示例如下所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">        <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</div><div class="line">            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</div><div class="line">    <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:_helper];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NSObject的<code>forwardInvocation:</code>方法实现只是简单调用了<code>doesNotRecognizeSelector:</code>方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>从某种意义上来讲，<code>forwardInvocation:</code>就像一个未知消息的分发中心，将这些未知的消息转发给其他对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>
<h4 id="消息转发与多重继承"><a href="#消息转发与多重继承" class="headerlink" title="消息转发与多重继承"></a>消息转发与多重继承</h4><p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</p>
<p>不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如<code>respondsToSelector:</code>和<code>isKindOfClass:</code>只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector])</div><div class="line">		<span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">/* Here, test whether the aSelector message can     *</span></div><div class="line">		 * be forwarded to another object and whether that  *</div><div class="line">		 * object can respond to it. Return YES if it can.  */</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">NO</span>; 	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在此，我们已经了解了Runtime中消息发送和转发的基本机制。这也是Runtime的强大之处，通过它，我们可以为程序增加很多动态的行为，虽然我们在实际开发中很少直接使用这些机制(如直接调用objc_msgSend)，但了解它们有助于我们更多地去了解底层的实现。其实在实际的编码过程中，我们也可以灵活地使用这些机制，去实现一些特殊的功能，如hook操作等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime运行时之二：成员变量与属性</title>
    <link href="http://www.guiyongdong.com/2016/11/24/Objective-C-Runtime%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%BA%8C-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.guiyongdong.com/2016/11/24/Objective-C-Runtime运行时之二-成员变量与属性/</id>
    <published>2016-11-24T07:39:47.000Z</published>
    <updated>2017-03-09T07:03:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面一篇文章中，我们介绍了Runtime中与类和对象相关的内容，从这章开始，我们将讨论类实现细节相关的内容，主要包括类中成员变量，属性，方法，协议与分类的实现。</p>
<p>本章的主要内容将聚集在Runtime对成员变量与属性的处理。在讨论之前，我们先介绍一个重要的概念：类型编码。</p>
<a id="more"></a>
<h3 id="类型编码-Type-Encoding"><a href="#类型编码-Type-Encoding" class="headerlink" title="类型编码(Type Encoding)"></a>类型编码(Type Encoding)</h3><p>作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起。这种编码方案在其他情况下也是非常有用的，因此我们可以使用@encode编译器指令来获取它。当给定一个类型时，@encode返回这个类型的字符串编码。这些类型可以是诸如int、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为sizeof()操作参数的类型都可以    用于@encode()。</p>
<p>一个数组的类型编码位于方括号中；其中包含数组元素的个数及元素类型。如下所示：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">float</span> a[] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"array encoding type: %s"</span>, <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(a)));</div></pre></td></tr></table></figure></p>
<p>输出是：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">54.731</span> RuntimeTest[<span class="number">942</span>:<span class="number">50791</span>] array encoding type: [<span class="number">3</span>f]</div></pre></td></tr></table></figure></p>
<p>其他类型可参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encoding</a>,在此不细说。</p>
<p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、retain等等，详情可以参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="external">Property Type String</a></p>
<h3 id="成员变量、属性"><a href="#成员变量、属性" class="headerlink" title="成员变量、属性"></a>成员变量、属性</h3><p>Runtime中关于成员变量和属性的相关数据结构并不多，只有三个，并且都很简单。不过还有个非常实用但可能经常被忽视的特性，即关联对象，我们将在这小节中详细讨论。</p>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><h5 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h5><p>Ivar是表示实例变量的类型，其实际是指向objc_ivar结构体的指针，其定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line">    <span class="keyword">char</span> *ivar_name              OBJC2_UNAVAILABLE;	<span class="comment">// 变量名</span></div><div class="line">    <span class="keyword">char</span> *ivar_type             	OBJC2_UNAVAILABLE;	<span class="comment">// 变量类型</span></div><div class="line">    <span class="keyword">int</span> ivar_offset            		OBJC2_UNAVAILABLE;	<span class="comment">// 基地址偏移字节</span></div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                 		OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h5><p>objc_property_t是表示Objective-C声明的属性的类型，其实际是指向objc_property结构体的指针，其定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</div></pre></td></tr></table></figure>
<h5 id="objc-property-attribute-t"><a href="#objc-property-attribute-t" class="headerlink" title="objc_property_attribute_t"></a>objc_property_attribute_t</h5><p>objc_property_attribute_t定义了属性的特性(attribute)，它是一个结构体，定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 特性名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          <span class="comment">// 特性值</span></div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure>
<h4 id="关联对象-Associated-Object"><a href="#关联对象-Associated-Object" class="headerlink" title="关联对象(Associated Object)"></a>关联对象(Associated Object)</h4><p>关联对象是Runtime中一个非常实用的特性，不过可能很容易被忽视。</p>
<p>关联对象类似于成员变量，不过是在运行时添加的。我们通常会把成员变量(Ivar)放在类声明的头文件中，或者放在类实现的<code>@implementation</code>后面。但这有一个缺点，我们不能再分类中添加成员变量。如果我们尝试在分类中添加新的成员变量，编译器会报错。</p>
<p>我们可能希望通过使用(甚至是滥用)全局变量来解决这个问题。但这些都不是Ivar，因为他们不会连接到一个单独的实例。因此，这种方法很少使用。</p>
<p>Objective-C针对这一问题，提供了一个解决方案：即关联对象(Associated Object)。</p>
<p>我们可以把关联对象想象成一个Objective-C对象(如字典),这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个void指针(const void*)。我们还需要制定一个内存管理策略，以告诉Runtime如何管理这个对象的内存。这个内存管理的策略可以由以下值指定：</p>
<pre><code>OBJC_ASSOCIATION_ASSIGN                //assign
OBJC_ASSOCIATION_RETAIN_NONATOMIC    //retain  nonatomic
OBJC_ASSOCIATION_COPY_NONATOMIC        //copy nonatomic
OBJC_ASSOCIATION_RETAIN                    // retain
OBJC_ASSOCIATION_COPY                    //copy
</code></pre><p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的策略是assign，则宿主释放时，关联对象不会被释放；而如果指定的是retain或者是copy，则宿主释放时，关联对象会被释放。我们甚至可以选择是否是自动retain/copy。当我们需要在多个线程中处理访问对象的多线程代码时，这就非常有用了。</p>
<p>我们将一个对象连接到其它对象所需要做的就是下面两行代码：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> myKey;</div><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);</div></pre></td></tr></table></figure></p>
<p>在这种情况下，self对象将获取一个新的关联的对象anObject，且内存管理策略是自动retain关联对象，当self对象释放时，会自动release关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> anObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;myKey);</div></pre></td></tr></table></figure>
<p>我们可以使用<code>objc_removeAssociatedObjects</code>函数来移除一个关联对象，或者使用<code>objc_setAssociatedObject</code>函数将key指定的关联对象设置为nil。</p>
<p>我们下面来用实例演示一下关联对象的使用方法。</p>
<p>假定我们想要动态地将一个Tap手势操作连接到任何UIView中，并且根据需要指定点击后的实际操作。这时候我们就可以将一个手势对象及操作的block对象关联到我们的UIView对象中。这项任务分两部分。首先，如果需要，我们要创建一个手势识别对象并将它及block做为关联对象。如下代码所示：</p>
<p>首先创建一个UIView的分类<br><em>UIView+GG.h</em><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">GG</span>)</span></div><div class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><em>UIView+GG.m</em><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIView+GG.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *kDTActionHandlerTapGestureKey;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * ;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">GG</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</div><div class="line">    <span class="comment">//获取关联对象（手势）</span></div><div class="line">    <span class="built_in">UITapGestureRecognizer</span> *gesture = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey);</div><div class="line">    <span class="comment">//如果关联对象(手势)为空，创建UIView的关联对象 UITapGestureRecognizer对象</span></div><div class="line">    <span class="keyword">if</span> (!gesture)</div><div class="line">    &#123;</div><div class="line">        gesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(__handleActionForTapGesture:)];</div><div class="line">        [<span class="keyword">self</span> addGestureRecognizer:gesture];</div><div class="line">        <span class="comment">//创建完UITapGestureRecognizer对象，并设置为当前UIView的关联对象。</span></div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置block为UIView的关联对象。</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(<span class="built_in">UITapGestureRecognizer</span> *)gesture</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (gesture.state == <span class="built_in">UIGestureRecognizerStateRecognized</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//获取关联对象(block)</span></div><div class="line">        <span class="keyword">void</span>(^action)(<span class="keyword">void</span>) = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey);</div><div class="line">        <span class="keyword">if</span> (action)</div><div class="line">        &#123;</div><div class="line">            action();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这段代码，我们分别定义了两个key，作为我们关联对象的key。在<code>- (void)setTapActionWithBlock:(void (^)(void))block</code>方法中，我们检测了手势识别的关联对象。如果没有，则创建并建立关联关系。同时，将传入的块对象连接到指定的key上。注意block对象的关联内存管理策略。<br>手势识别对象需要一个<code>target</code>和<code>action</code>，所以接下来我们定义了处理方法：<code>- (void)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture</code>。我们需要检测手势识别对象的状态，因为我们只需要在点击手势识别出来时才执行操作。</p>
<p>从上面的例子我们可以看到，关联对象使用起来并不复杂。它让我们可以动态地增强类现有的功能。我们可以在编码中灵活地运用这一特性。</p>
<h4 id="成员变量、属性的操作方法"><a href="#成员变量、属性的操作方法" class="headerlink" title="成员变量、属性的操作方法"></a>成员变量、属性的操作方法</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>成员变量操作包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取成员变量名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量类型编码</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量的偏移量</span></div><div class="line">ptrdiff_t ivar_getOffset ( Ivar v );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>ivar_getOffset</code>函数，对于类型id或其它对象类型的实例变量，可以调用<code>object_getIvar</code>和<code>object_setIvar</code>来直接访问成员变量，而不适用偏移量。</li>
</ul>
<h5 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h5><p>关联对象操作函数包括以下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 设置关联对象</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</div><div class="line"><span class="comment">// 获取关联对象</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</div><div class="line"><span class="comment">// 移除关联对象</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</div></pre></td></tr></table></figure></p>
<p>关联对象及相关实例已经在前面讨论过了，在此不再重复。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>属性操作相关函数包括以下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取属性名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性特性描述字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性中指定的特性</span></div><div class="line"><span class="keyword">char</span> * property_copyAttributeValue ( objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</div><div class="line"><span class="comment">// 获取属性的特性列表</span></div><div class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>property_copyAttributeValue</code>函数，返回的<code>char*</code>在使用完后需要调用free()释放。</li>
<li><code>property_copyAttributeList</code>函数，返回值在使用完后需要调用free()释放。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>假定这样一个场景，我们从服务端两个不同的接口获取相同的字典数据，但这两个接口是由两个人写的，相同的信息使用了不同的字段表示。我们接收到数据时，可将这些数据保存在相同的对象中。对象类如下定义：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span>: <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>    *   name;                  </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>    *   status;                 </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>接口A、B返回的字典数据如下所示：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">@&#123;<span class="string">@"name1"</span>: <span class="string">"张三"</span>, <span class="string">@"status1"</span>: <span class="string">@"start"</span>&#125;</div><div class="line">@&#123;<span class="string">@"name2"</span>: <span class="string">"张三"</span>, <span class="string">@"status2"</span>: <span class="string">@"end"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>通常的方法是写两个方法分别做转换，不过如果能灵活地运用Runtime的话，可以只实现一个转换，为此，我们需要先定义一个映射字典(全局变量)<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *map = <span class="literal">nil</span>;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span>	</span></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    map = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    map[<span class="string">@"name1"</span>]                = <span class="string">@"name"</span>;</div><div class="line">    map[<span class="string">@"status1"</span>]              = <span class="string">@"status"</span>;</div><div class="line">    map[<span class="string">@"name2"</span>]                = <span class="string">@"name"</span>;</div><div class="line">    map[<span class="string">@"status2"</span>]              = <span class="string">@"status"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>上面的代码将两个字典中不同的字段映射到<code>MyObject</code>中相同的属性上，这样，转换方法可如下处理：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setDataWithDic:(<span class="built_in">NSDictionary</span> *)dic</div><div class="line">&#123;</div><div class="line">    [dic enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">        <span class="built_in">NSString</span> *propertyKey = [<span class="keyword">self</span> propertyForKey:key];</div><div class="line">        <span class="keyword">if</span> (propertyKey)</div><div class="line">        &#123;</div><div class="line">            objc_property_t property = class_getProperty([<span class="keyword">self</span> <span class="keyword">class</span>], [propertyKey UTF8String]);</div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> 针对特殊数据类型做处理</span></div><div class="line">            <span class="built_in">NSString</span> *attributeString = [<span class="built_in">NSString</span> stringWithCString:property_getAttributes(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">            ...</div><div class="line">            [<span class="keyword">self</span> setValue:obj forKey:propertyKey];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，一个属性能否通过上面这种方式来处理的前提是其支持KVC。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章中我们讨论了Runtime中与成员变量和属性相关的内容。成员变量与属性是类的数据基础，合理地使用Runtime中的相关操作能让我们更加灵活地来处理与类数据相关的工作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面一篇文章中，我们介绍了Runtime中与类和对象相关的内容，从这章开始，我们将讨论类实现细节相关的内容，主要包括类中成员变量，属性，方法，协议与分类的实现。&lt;/p&gt;
&lt;p&gt;本章的主要内容将聚集在Runtime对成员变量与属性的处理。在讨论之前，我们先介绍一个重要的概念：类型编码。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 运行时之一：类与对象</title>
    <link href="http://www.guiyongdong.com/2016/11/21/Objective-C-Runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.guiyongdong.com/2016/11/21/Objective-C-Runtime-运行时之一：类与对象/</id>
    <published>2016-11-21T09:22:10.000Z</published>
    <updated>2017-03-09T07:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具有灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样，让它所有的工作可以正常运行。这个运行时系统即<code>Objc Runtime</code>。<code>Objc Runtime</code>其实就是一个<code>Runtime</code>库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<a id="more"></a>
<p><code>Runtime</code>库主要做下面几件事：</p>
<ul>
<li>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被Runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</li>
<li>找出方法的最终执行代码：当程序执行<code>[object doSomething]</code>时，会向消息接收者(object)发送一条信息(doSomething)，Runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。</li>
</ul>
<p>Objective-C Runtime目前有两个版本：<code>Modern Runtime</code>和<code>Legacy Runtime</code>。<code>Modern Runtime</code>覆盖了64位的<code>Mac OS X Apps</code>还有<code>iOS AppS</code>,<code>Legacy Runtime</code>是早期用来给32位<code>Mac OS X Apps</code> 用的，也就是可以不用管就是了。</p>
<p>在这一系列文章中，我们将介绍Runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。CFRuntime的代码是开源的，我们可以在这里<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">https://opensource.apple.com/tarballs/CF/</a>下载整个CoreFoundation的源码来看。 在本文中，我们先来介绍一下类和对象，这是面向对象的基础，我们看看在Runtime中，类是如何体现的。</p>
<h3 id="类与对象基础数据结构"><a href="#类与对象基础数据结构" class="headerlink" title="类与对象基础数据结构"></a>类与对象基础数据结构</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Objective-C类是由Class类型来表示的，它实际上是指向objc_class结构体的指针。它的定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div></pre></td></tr></table></figure></p>
<p>查看<code>objc/runtime.h</code>中<code>objc_class</code>结构体的定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                   	OBJC2_UNAVAILABLE;	<span class="comment">// 父类</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                      	OBJC2_UNAVAILABLE;	<span class="comment">// 类名</span></div><div class="line">    <span class="keyword">long</span> version                          	OBJC2_UNAVAILABLE;	<span class="comment">// 类的版本信息，默认为0</span></div><div class="line">    <span class="keyword">long</span> info                            	OBJC2_UNAVAILABLE;	<span class="comment">// 类信息，供运行期使用的一些位标识</span></div><div class="line">    <span class="keyword">long</span> instance_size                   	OBJC2_UNAVAILABLE;	<span class="comment">// 该类的实例变量大小</span></div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars         	OBJC2_UNAVAILABLE;	<span class="comment">// 该类的成员变量链表</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists 	OBJC2_UNAVAILABLE;	<span class="comment">// 方法定义的链表</span></div><div class="line">    <span class="keyword">struct</span> objc_cache *cache              	OBJC2_UNAVAILABLE;	<span class="comment">// 方法缓存</span></div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols 	OBJC2_UNAVAILABLE;	<span class="comment">// 协议链表</span></div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>
<p>在这个定义中，下面几个字段是我们感兴趣的</p>
<ol>
<li><strong>isa</strong>: 需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类),我们会在后面介绍它。</li>
<li><strong>super_class</strong>：指向该类的父类，如果该类已经是最顶层的跟类(如NSObject或者NSProxy)，则super_class为NULL。</li>
<li><strong>cache</strong>: 用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才到methodLists中查找方法。这样，对于那些经常用到的方法的调用，提高了调用的效率。</li>
<li><strong>version</strong>：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ol>
<p>针对cache,我们用下面例子来说明其执行过程：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [[<span class="built_in">NSArray</span> alloc] init];</div></pre></td></tr></table></figure></p>
<p>其流程是：</p>
<ol>
<li><code>[NSArray alloc]</code>先被执行。因为NSArray没有<code>+alloc</code>方法，于是去父类NSObject去查找。</li>
<li>检测NSObject是否响应<code>+alloc</code>方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把<code>isa</code>指针指向NSArray类。同时，<code>+alloc</code>也被加进cache列表里面。</li>
<li>接着，执行<code>-init</code>方法，如果NSArray响应该方法，则直接将其加入<code>cache</code>；如果不响应，则去父类查找。</li>
<li>在后期的操作中，如果再以<code>[[NSArray alloc] init]</code>这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</li>
</ol>
<h4 id="objc-object与id"><a href="#objc-object与id" class="headerlink" title="objc_object与id"></a>objc_object与id</h4><p><code>objc_object</code>是表示一个类的实例的结构体，它的定义如下(<code>objc/objc.h</code>)：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</div></pre></td></tr></table></figure>
<p>可以看到，这个结构体只是一个指针，即指向其类的isa指针，这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。</p>
<p>另外还有我们常见的id，它是一个objc_object结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void*指针类型的作用。</p>
<h4 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h4><p>上面提到了objc_class结构体中的cache字段，它用于缓存调用过的方法。这个字段是一个指向objc_cache结构体的指针，其定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_cache &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</div><div class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>该结构体的字段描述如下：</p>
<ol>
<li><strong>mask</strong>：一个整数，指定分配的缓存buket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</li>
<li><strong>occupied</strong>：一个整数，指定实际占用的缓存bucket的总数。</li>
<li><strong>buckets</strong>：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能为MULL，表示这个缓存buket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</li>
</ol>
<h4 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h4><p>在上面我们提到，所有的类本身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。如：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> array];</div></pre></td></tr></table></figure></p>
<p>这个例子中，<code>+array</code>消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就有一个问题了，这个isa指针指向哪里呢？为了调用<code>+array</code>方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">meta-<span class="keyword">class</span>是一个类对象的类。</div></pre></td></tr></table></figure></p>
<p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法，而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p>
<p>meta-class之所以重要，是因为它存储着一个类的所有方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>
<p>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。</p>
<p>通过上面的描述，再加上对objc_class结构中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图所示:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/class-diagram.jpg?raw=true" alt="image"><br></div>

<p>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。</p>
<p>讲了这么多，我们还是来写个例子吧：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> TestMetaClass(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"This objcet is %p"</span>, <span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Class is %@, super class is %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], [<span class="keyword">self</span> superclass]);</div><div class="line">    Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Following the isa pointer %d times gives %p"</span>, i, currentClass);</div><div class="line">        currentClass = objc_getClass((__bridge <span class="keyword">void</span> *)currentClass);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's class is %p"</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's meta class is %p"</span>, objc_getClass((__bridge <span class="keyword">void</span> *)[<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">void</span>)ex_registerClassPair &#123;</div><div class="line">    Class newClass = objc_allocateClassPair([<span class="built_in">NSError</span> <span class="keyword">class</span>], <span class="string">"TestClass"</span>, <span class="number">0</span>);</div><div class="line">    class_addMethod(newClass, <span class="keyword">@selector</span>(testMetaClass), (IMP)TestMetaClass, <span class="string">"v@:"</span>);</div><div class="line">    objc_registerClassPair(newClass);</div><div class="line">    <span class="keyword">id</span> instance = [[newClass alloc] initWithDomain:<span class="string">@"some domain"</span> code:<span class="number">0</span> userInfo:<span class="literal">nil</span>];</div><div class="line">    [instance performSelector:<span class="keyword">@selector</span>(testMetaClass)];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这个例子是在运行时创建了一个NSError的子类TestClass，然后为这个子类添加一个方法testMetaClass，这个方法的实现是TestMetaClass函数。</p>
<p>运行后，打印结果是:<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">2014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] NSObject's class is 0xe10000</div><div class="line">2014-10-20 22:57:07.354 mountain[1303:41490] NSObject's meta class is 0x0</div></pre></td></tr></table></figure></p>
<p>我们在for循环中，我们通过objc_getClass来获取对象的isa,并将其打印出来，依此一直回溯到NSObject的meta-class。分析打印结果，可以看到最后指针指向的地址是0x0，即NSObject的meta-class的类地址。</p>
<p>这里需要注意的是：我们在一个类对象调用class方法是无法获取meta-class,它只是返回一个类而已。</p>
<h3 id="类与对象操作函数"><a href="#类与对象操作函数" class="headerlink" title="类与对象操作函数"></a>类与对象操作函数</h3><p>runtime提供了大量的函数来操作类和对象。类的操作方法大部分是以<code>class_</code>为前缀的，而对象的操作方法大部分是以<code>objc_</code>或<code>object_</code>为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>
<h4 id="类相关操作函数"><a href="#类相关操作函数" class="headerlink" title="类相关操作函数"></a>类相关操作函数</h4><p>我们可以回过头去看看<code>objc_class</code>的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些函数。并在最后以实例来演示这些函数的具体方法。</p>
<h5 id="类名-name"><a href="#类名-name" class="headerlink" title="类名(name)"></a>类名(name)</h5><p>类名操作的函数主要有：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取类的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( Class cls );</div></pre></td></tr></table></figure></p>
<ul>
<li>对于<code>class_getName</code>函数，如果传入的cls为Nil，则返回一个nil</li>
</ul>
<h5 id="父类-super-class-和元类-meta-class"><a href="#父类-super-class-和元类-meta-class" class="headerlink" title="父类(super_class)和元类(meta-class)"></a>父类(super_class)和元类(meta-class)</h5><p>父类和元类操作的函数主要有：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取类的父类</span></div><div class="line">Class class_getSuperclass ( Class cls );</div><div class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></div><div class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>class_getSuperclass</code>函数，当cls为nil或者cls为根类时，返回nil。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的。</li>
<li><code>class_isMetaClass</code>函数，如果cls是元类，则返回YES，如果否或者传入的cls为nil，则返回NO。</li>
</ul>
<h5 id="实例变量大小-instance-size"><a href="#实例变量大小-instance-size" class="headerlink" title="实例变量大小(instance_size)"></a>实例变量大小(instance_size)</h5><p>实例变量大小操作的函数有：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取实例大小</span></div><div class="line">size_t class_getInstanceSize ( Class cls );</div></pre></td></tr></table></figure></p>
<h5 id="成员变量-ivars-及属性"><a href="#成员变量-ivars-及属性" class="headerlink" title="成员变量(ivars)及属性"></a>成员变量(ivars)及属性</h5><p>在<code>objc_class</code>中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：<br>1.成员变量操作函数，主要包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></div><div class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取类成员变量的信息</span></div><div class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 添加成员变量</span></div><div class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"><span class="comment">// 获取整个成员变量列表</span></div><div class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>class_getInstanceVariable</code>函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。</li>
<li><code>class_getClassVariable</code>函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</li>
<li>Objective-C不支持往已经存在的类中添加实例变量，因此不管是系统库提供的类，还是我们自己定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以用<code>class_addIvar</code>函数了。不过需要注意的是，这个方法只能在<code>objc_allocateClassPair</code>函数与<code>objc_registerClassPair</code>之间调用。另外，这个类也不能是元类。成员变量的按字节最小对其量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</li>
<li><code>class_copyIvarList</code>函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。</li>
</ul>
<p>2.属性操作函数，主要包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取指定的属性</span></div><div class="line">objc_property_t class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取属性列表</span></div><div class="line">objc_property_t * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 为类添加属性</span></div><div class="line"><span class="built_in">BOOL</span> class_addProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div><div class="line"><span class="comment">// 替换类的属性</span></div><div class="line"><span class="keyword">void</span> class_replaceProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div></pre></td></tr></table></figure></p>
<p>这一种方法也是针对ivars来操作，不过只操作那些属性的值。我们在后面会介绍属性时会再遇到这些函数。</p>
<p>3.在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理strong/weak引用。这几个函数定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> uint8_t * class_getIvarLayout ( Class cls );</div><div class="line"><span class="keyword">void</span> class_setIvarLayout ( Class cls, <span class="keyword">const</span> uint8_t *layout );</div><div class="line"><span class="keyword">const</span> uint8_t * class_getWeakIvarLayout ( Class cls );</div><div class="line"><span class="keyword">void</span> class_setWeakIvarLayout ( Class cls, <span class="keyword">const</span> uint8_t *layout );</div></pre></td></tr></table></figure></p>
<p>但通常情况下，我们不需要主动去调用这些方法，在调用<code>objc_registerClassPair</code>时，会生成合理的布局。在此不详细介绍这些函数。</p>
<h5 id="方法-methodLists"><a href="#方法-methodLists" class="headerlink" title="方法(methodLists)"></a>方法(methodLists)</h5><p>方法操作主要有以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 添加方法</span></div><div class="line"><span class="built_in">BOOL</span> class_addMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"><span class="comment">// 获取实例方法</span></div><div class="line">Method class_getInstanceMethod ( Class cls, SEL name );</div><div class="line"><span class="comment">// 获取类方法</span></div><div class="line">Method class_getClassMethod ( Class cls, SEL name );</div><div class="line"><span class="comment">// 获取所有方法的数组</span></div><div class="line">Method * class_copyMethodList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 替代方法的实现</span></div><div class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"><span class="comment">// 返回方法的具体实现</span></div><div class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</div><div class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</div><div class="line"><span class="comment">// 类实例是否响应指定的selector</span></div><div class="line"><span class="built_in">BOOL</span> class_respondsToSelector ( Class cls, SEL sel );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>class_addMethod</code>的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用<code>method_setImplementation</code>。一个Objective-C方法是一个简单的C函数，它至少包含两个参数self和_cmd。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethodIMP</span><span class="params">(id self, SEL <span class="number">_</span>cmd)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// implementation ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已经存在。另外，参数types是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。</p>
<ul>
<li><code>class_getInstanceMethod</code>、<code>class_getClassMethod</code>函数,与<code>class_copyMethodList</code>不同的是，这两个函数都会去搜索父类的实现。</li>
<li><code>class_copyMethodList</code>函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用<code>class_copyMethodList(object_getClass(cls),&amp;count)</code>(一个类的实例方法定义在元类里面)。该列表不包含父类实现的方法。<code>outCount</code>参数返回方法的个数。在获取到列表后，我们需要使用free()方法来释放它。</li>
<li><code>class_replaceMethod</code>函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于<code>class_addMethod</code>函数一样会添加方法；如果类中已经存在name指定的方法，则类似与<code>method_setImplementation</code>一样替代原方法的实现。</li>
<li><code>class_getMethodImplementation</code>函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比<code>method_getImplementation(class_getInstanceMethod(cls,name))</code>更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应selector，则返回的函数指针将是运行时消息转发机制的一部分。</li>
<li><code>class_respondsToSelector</code>函数，我们通常使用NSObject类的<code>respondsToSelector:</code>或<code>instanceRespondToSelector:</code>方法来达到同样的目的。</li>
</ul>
<h5 id="协议-objc-protocol-list"><a href="#协议-objc-protocol-list" class="headerlink" title="协议(objc_protocol_list)"></a>协议(objc_protocol_list)</h5><p>协议相关的操作包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 添加协议</span></div><div class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</div><div class="line"><span class="comment">// 返回类是否实现指定的协议</span></div><div class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</div><div class="line"><span class="comment">// 返回类实现的协议列表</span></div><div class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>class_conformsToProtocol</code>函数可以使用NSObject类的<code>conformsToProtocol:</code>方法来代替。</li>
<li><code>class_copyProtocolList</code>函数返回的是一个数组，在使用后我们需要使用free()手动释放。</li>
</ul>
<h5 id="版本-version"><a href="#版本-version" class="headerlink" title="版本(version)"></a>版本(version)</h5><p>版本相关的操作包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取版本号</span></div><div class="line"><span class="keyword">int</span> class_getVersion ( Class cls );</div><div class="line"><span class="comment">// 设置版本号</span></div><div class="line"><span class="keyword">void</span> class_setVersion ( Class cls, <span class="keyword">int</span> version );</div></pre></td></tr></table></figure></p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>runtime还提供了两个函数工<code>CoreFoundation</code>和<code>tool-free bridging</code>使用，即：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">Class objc_getFutureClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="keyword">void</span> objc_setFutureClass ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure></p>
<p>通常我们不直接使用这两个函数。</p>
<h5 id="实例-Example"><a href="#实例-Example" class="headerlink" title="实例(Example)"></a>实例(Example)</h5><p>上面列举了大量类操作的函数，下面我们写个实例，来看看这些函数的实例效果：</p>
<p>我们创建一个类MyClass，并且给雷添加一些实例变量和方法。</p>
<p><strong>MyClass.h</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *array;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method1;</div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line">+ (<span class="keyword">void</span>)classMethod1;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><strong>MyClass.m</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</div><div class="line">    <span class="built_in">NSInteger</span> _instance1;</div><div class="line">    <span class="built_in">NSString</span> *_instance2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> integer;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line"></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"调用类方法 classMethod1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用实例方法 method1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"调用实例方法 method2"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"arg1 : %ld, arg2 : %@"</span>,arg1,arg2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在ViewController中的<code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</code>方法中调用例子:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    MyClass *myClass = [[MyClass alloc] init];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">    Class cls = myClass.class;</div><div class="line">    </div><div class="line">    <span class="comment">//类名</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>,class_getName(cls));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//父类</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super class name: %s"</span>,class_getName(class_getSuperclass(cls)));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//是否是元类</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyClass is %@ a meta-class"</span>,class_isMetaClass(cls)?<span class="string">@""</span>:<span class="string">@"not"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//元类</span></div><div class="line">    Class meta_class = objc_getMetaClass(class_getName(cls));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s's meta-class is  %s"</span>,class_getName(cls),class_getName(meta_class));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//变量实例大小</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"instance size: %zu"</span>,class_getInstanceSize(cls));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//成员变量</span></div><div class="line">    Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; outCount; i++) &#123;</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"instance variable's name:%s at index: %d"</span>,ivar_getName(ivar),i);</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">    <span class="comment">//指定名称的成员变量</span></div><div class="line">    Ivar string = class_getInstanceVariable(cls, <span class="string">"_string"</span>);</div><div class="line">    <span class="keyword">if</span> (string != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"instanve variable %s"</span>,ivar_getName(string));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//属性操作</span></div><div class="line">    objc_property_t *properties = class_copyPropertyList(cls, &amp;outCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; outCount; i++) &#123;</div><div class="line">        objc_property_t property = properties[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"property's name : %s"</span>,property_getName(property));</div><div class="line">    &#125;</div><div class="line">    free(properties);</div><div class="line">    <span class="comment">//指定名称的属性</span></div><div class="line">    objc_property_t array = class_getProperty(cls, <span class="string">"_array"</span>);</div><div class="line">    <span class="keyword">if</span> (array != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"property %s"</span>,property_getName(array));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//方法操作 </span></div><div class="line">    Method *methods = class_copyMethodList(cls, &amp;outCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; outCount; i++) &#123;</div><div class="line">        Method method = methods[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"method's signature: %s"</span>,method_getName(method));</div><div class="line">    &#125;</div><div class="line">    free(methods);</div><div class="line">    <span class="comment">//指定方法名实例方法</span></div><div class="line">    Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">    <span class="keyword">if</span> (method1 != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"instance method: %s "</span>,method_getName(method1));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//指定方法名类方法</span></div><div class="line">    Method classMethod = class_getClassMethod(cls, <span class="keyword">@selector</span>(classMethod1));</div><div class="line">    <span class="keyword">if</span> (classMethod != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"class method :%s"</span>,method_getName(classMethod));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断是否实现某方法</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyClass is %@ responsd to selector: method3WithArg1:arg2:"</span>,class_respondsToSelector(cls, <span class="keyword">@selector</span>(method3WithArg1:arg2:))?<span class="string">@""</span>:<span class="string">@"not"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//获取指定方法实现</span></div><div class="line">    IMP imp = class_getMethodImplementation(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">    imp();</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//协议</span></div><div class="line">    Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(cls, &amp;outCount);</div><div class="line">    Protocol *protocol;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; outCount; i++) &#123;</div><div class="line">        protocol = protocols[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"protocol name:%s"</span>,protocol_getName(protocol));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyClass is %@ responsed to protocol %s"</span>,class_conformsToProtocol(cls, protocol)?<span class="string">@""</span>:<span class="string">@"not"</span>,protocol_getName(protocol));</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>控制台输出如下：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] class name: MyClass</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] super class name: NSObject</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] MyClass is not a meta-class</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] MyClass's meta-class is  MyClass</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] instance size: 48</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] instance variable's name:_instance1 at index: 0</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] instance variable's name:_instance2 at index: 1</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] instance variable's name:_array at index: 2</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] instance variable's name:_string at index: 3</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] instance variable's name:_integer at index: 4</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] instanve variable _string</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] property's name : integer</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] property's name : array</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] property's name : string</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] method's signature: method1</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] method's signature: method3WithArg1:arg2:</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] method's signature: method2</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: integer</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: setInteger:</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: setArray:</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: .cxx_destruct</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: string</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: setString:</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: array</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] instance method: method1 </div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] MyClass is  responsd to selector: method3WithArg1:arg2:</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] 调用实例方法 method1</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] protocol name:NSCopying</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] protocol name:NSCoding</div><div class="line">2016-11-23 18:07:47.589 RuntimeDemo[3598:309543] MyClass is  responsed to protocol NSCoding</div></pre></td></tr></table></figure></p>
<h4 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h4><p>runtime的强大之处在于它能在运行时创建类和对象。</p>
<h5 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h5><p>动态创建类涉及到以下几个函数：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 创建一个新类和元类</span></div><div class="line">Class objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes);</div><div class="line"><span class="comment">// 销毁一个类及其相关联的类</span></div><div class="line"><span class="keyword">void</span> objc_disposeClassPair ( Class cls );</div><div class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></div><div class="line"><span class="keyword">void</span> objc_registerClassPair ( Class cls );</div></pre></td></tr></table></figure>
<ul>
<li><code>objc_allocateClassPair</code>函数：如果我们要创建一个根类，则superclass指定为Nil。<code>extraBytes</code>通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。</li>
<li><code>objc_registerClassPair</code>函数：为了创建一个新类，我们需要调用<code>objc_allocateClassPair</code>。然后使用诸如<code>class_addMethod</code>,<code>class_addIvar</code>等函数来为新的类添加方法、实例变量和属性等。完成这些后，我们需要调用<code>objc_registerClassPair</code>函数来注册类，之后这个类就可以在程序中使用了。实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</li>
<li><code>objc_disposeClassPair</code>函数：用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或者其子类的实例时，则不能针对类调用该方法。</li>
</ul>
<p>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">"MySubClass"</span>, <span class="number">0</span>);</div><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_addIvar(cls, <span class="string">"_ivar1"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">"i"</span>);</div><div class="line">objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</div><div class="line">objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</div><div class="line">objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</div><div class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</div><div class="line">class_addProperty(cls, <span class="string">"property2"</span>, attrs, <span class="number">3</span>);</div><div class="line">objc_registerClassPair(cls);</div><div class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</div></pre></td></tr></table></figure></p>
<p>程序的输出如下：</p>
<pre><code>2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
</code></pre><h5 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h5><p>动态创建对象的函数如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 创建类实例</span></div><div class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</div><div class="line"><span class="comment">// 在指定位置创建类实例</span></div><div class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</div><div class="line"><span class="comment">// 销毁类实例</span></div><div class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure>
<ul>
<li><code>class_createInstance</code>函数：创建实例时，会在默认的内存区域为类分配内存。<code>extraBytes</code>参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</li>
</ul>
<p>调用<code>class_createInstance</code>的效果与<code>+alloc</code>方法类似。不过在使用<code>class_createInstance</code>时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line"> </div><div class="line"><span class="keyword">id</span> str1 = [theObject init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 <span class="keyword">class</span>]);</div><div class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 <span class="keyword">class</span>]);</div></pre></td></tr></table></figure></p>
<p>输出的结果是：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] <span class="built_in">NSString</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] __NSCFConstantString</div></pre></td></tr></table></figure></p>
<p>可以看到，使用<code>class_createInstance</code>函数获取的是NSString实例，而不是类簇中的默认站位符类<code>__NSCFConstantString</code>。</p>
<ul>
<li><p><code>objc_constructInstance</code>函数：在指定的位置(bytes)创建类实例。</p>
</li>
<li><p><code>objc_destructInstance</code>函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</p>
</li>
</ul>
<h5 id="实例操作函数"><a href="#实例操作函数" class="headerlink" title="实例操作函数"></a>实例操作函数</h5><p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<p>1.针对整个对象进行操作的函数，这类函数包括<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回指定对象的一份拷贝</span></div><div class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</div><div class="line"><span class="comment">// 释放指定对象占用的内存</span></div><div class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure></p>
<p>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，以为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就可以使用以上几个函数来处理这种情况，如下代码所示：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</div><div class="line">object_setClass(newB, MyClass.class);</div><div class="line">object_dispose(a);</div></pre></td></tr></table></figure></p>
<p>2.针对对象实例变量进行操作的函数，这类函数包含：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 修改类实例的实例变量的值</span></div><div class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</div><div class="line"><span class="comment">// 获取对象实例变量的值</span></div><div class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</div><div class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></div><div class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象中实例变量的值</span></div><div class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</div><div class="line"><span class="comment">// 设置对象中实例变量的值</span></div><div class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</div></pre></td></tr></table></figure></p>
<p>如果实例变量的Ivar已经知道，那么调用<code>object_getIvar</code>会比<code>object_getInstanceVariable</code>函数快，相同情况下，<code>object_setIvar</code>也比<code>object_setInstanceVariable</code>快。</p>
<p>3.针对对象的类进行操作的函数，这类函数包含：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回给定对象的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象的类</span></div><div class="line">Class object_getClass ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 设置对象的类</span></div><div class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</div></pre></td></tr></table></figure></p>
<h5 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h5><p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用<code>objc_addClass</code>函数来注册它们。runtime提供了一系列函数来获取类定义相关的信息，这些函数主要包括：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取已注册的类定义的列表</span></div><div class="line"><span class="keyword">int</span> objc_getClassList ( Class *buffer, <span class="keyword">int</span> bufferCount );</div><div class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></div><div class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 返回指定类的类定义</span></div><div class="line">Class objc_lookUpClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getRequiredClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 返回指定类的元类</span></div><div class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>objc_getClassList</code>函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。</li>
</ul>
<p>下面代码演示了该函数的用法：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> numClasses;</div><div class="line">Class * classes = <span class="literal">NULL</span>;</div><div class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</div><div class="line">    classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</div><div class="line">    numClasses = objc_getClassList(classes, numClasses);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"number of classes: %d"</span>, numClasses);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</div><div class="line">        Class cls = classes[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));</div><div class="line">    &#125;</div><div class="line">    free(classes);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] number of classes: <span class="number">1282</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: DDTokenRegexp</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _NSMostCommonKoreanCharsKeySet</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_xpc_dictionary</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSFileCoordinator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSAssertionHandler</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: PFUbiquityTransactionLogMigrator</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSNotification</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSKeyValueNilSetEnumerator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_tcp_connection_tls_session</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _PFRoutines</div><div class="line">......还有大量输出</div></pre></td></tr></table></figure></p>
<ul>
<li>获取类定义的方法有三个：<code>objc_lookUpClass</code>,<code>objc_getClass</code>和<code>objc_getRequiredClass</code>。如果类在运行时未注册，则<code>objc_lookUpClass</code>会返回nil，而<code>objc_getClass</code>会调用类处理回调，并再次确认该类是否注册，如果确认未注册，则返回nil。而<code>objc_getRequiredClass</code>函数的操作与<code>objc_getClass</code>相同，只不过如果没有找到类，则会杀死进程。</li>
<li><code>objc_getMetaClass</code>函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在这一章中我们介绍了Runtime运行时中与类和对象相关的数据结构，通过这些数据函数，我们可以管窥Objective-C底层面向对象实现的一些信息。另外，通过丰富的操作函数，可以灵活地对这些数据进行操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具有灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。&lt;/p&gt;
&lt;p&gt;这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样，让它所有的工作可以正常运行。这个运行时系统即&lt;code&gt;Objc Runtime&lt;/code&gt;。&lt;code&gt;Objc Runtime&lt;/code&gt;其实就是一个&lt;code&gt;Runtime&lt;/code&gt;库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>NSURLSession与NSURLConnection区别</title>
    <link href="http://www.guiyongdong.com/2016/11/18/NSURLSession%E4%B8%8ENSURLConnection%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.guiyongdong.com/2016/11/18/NSURLSession与NSURLConnection区别/</id>
    <published>2016-11-18T06:09:19.000Z</published>
    <updated>2017-03-09T07:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去面试，被问了一道AFNetworking2.0和3.0有什么区别，当时心想，这谁不知道啊，随口答到：2.0使用的NSURLConnection,3.0使用的是NSURLSession,人家又问NSURLSesstion和NSURLConnection有什么区别，瞬间傻眼了，支支吾吾只是说出了缓存策略的不同。亡羊补牢，为时未晚，这篇博客就讲解一下它们两者到底有什么区别。</p>
<a id="more"></a>
<h4 id="使用现状"><a href="#使用现状" class="headerlink" title="使用现状"></a>使用现状</h4><p>NSURLSession是NSURLConnection的替代者，在2013年苹果全球开发者大会上（WWDC2013）随iOS7一起发布的，是对NSURLConnection进行了重构优化后的新的网络接口。从iOS9开始，NSURLConnection中发送请求的两个方法已经过期（同步请求，异步请求）,初始化网络连接的方法也被设置为过期，系统不再推荐使用，建议使用NSURLSession发送网络请求。NSURLConnection被废弃的主要接口：</p>
<pre><code>- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate startImmediately:(BOOL)startImmediately NS_DEPRECATED(10_5, 10_11, 2_0, 9_0, &quot;Use NSURLSession (see NSURLSession.h)&quot;) __WATCHOS_PROHIBITED;

- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate NS_DEPRECATED(10_3, 10_11, 2_0, 9_0, &quot;Use NSURLSession (see NSURLSession.h)&quot;) __WATCHOS_PROHIBITED;
+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate NS_DEPRECATED(10_3, 10_11, 2_0, 9_0, &quot;Use NSURLSession (see NSURLSession.h)&quot;) __WATCHOS_PROHIBITED;
//异步请求
+ (void)sendAsynchronousRequest:(NSURLRequest*) request
                          queue:(NSOperationQueue*) queue
              completionHandler:(void (^)(NSURLResponse* __nullable response, NSData* __nullable data, NSError* __nullable connectionError)) handler NS_DEPRECATED(10_7, 10_11, 5_0, 9_0, &quot;Use [NSURLSession dataTaskWithRequest:completionHandler:] (see NSURLSession.h&quot;) __WATCHOS_PROHIBITED;
//同步请求             
+ (nullable NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse * __nullable * __nullable)response error:(NSError **)error NS_DEPRECATED(10_3, 10_11, 2_0, 9_0, &quot;Use [NSURLSession dataTaskWithRequest:completionHandler:] (see NSURLSession.h&quot;) __WATCHOS_PROHIBITED;
</code></pre><h4 id="普通任务和上传"><a href="#普通任务和上传" class="headerlink" title="普通任务和上传"></a>普通任务和上传</h4><p>NSURLSession针对下载/上传等复杂的网络操作提供了专门的解决方案，针对普通、上传和下载分别对应三种不同的网络请求任务：NSURLSessionDataTask,NSURLSessionUploadTask和NSURLSessionDownloadTask。创建的task都是挂起状态，需要resume才能启动。</p>
<p>当服务器返回的数据较小时,NSURLSession与NSURLConnection执行普通任务的操作步骤没有区别。<br>执行上传任务时，NSURLSession与NSURLConnection一样需要设置POST请求的请求体进行上传。</p>
<h4 id="下载任务方式"><a href="#下载任务方式" class="headerlink" title="下载任务方式"></a>下载任务方式</h4><p>NSURLConnection下载文件时，先是将整个文件下载到内存，然后再写入到沙盒，如果文件比较大，就会出现内存暴涨的情况。</p>
<p>而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件中，不会出现内存暴涨的情况，但是在下载完成后会把tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。（后面会详细说）</p>
<h4 id="请求方法的控制"><a href="#请求方法的控制" class="headerlink" title="请求方法的控制"></a>请求方法的控制</h4><p>NSURLConnection实例化对象，实例化开始，默认请求就发送(同步发送),不需要调用start方法。而cancel可以停止请求的发送，停止后不能继续访问，需要创建新的请求。</p>
<p>NSURLSession有三个控制方法，取消(cancel)、暂停(suspend)、继续(resume)，暂停以后可以通过继续恢复当前的请求任务。</p>
<h4 id="断点续传的方式"><a href="#断点续传的方式" class="headerlink" title="断点续传的方式"></a>断点续传的方式</h4><p>NSURLConnection进行断点下载，通过设置访问请求的HTTPHeaderField的Range属性，开启运行循环，NSURLConnection的代理方法作为运行循环的事件源，接收到下载数据时代理方法就会持续调用，并使用NSOutputStream管道流进行数据保存。</p>
<p>NSURLSession进行断点下载，当暂停下载任务后，如果downloadTask（下载任务）为非空，调用<code>cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler</code>这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个NSData参数resumeData，如果resumeData非空，我们就保存这个对象到视图控制器的resumeData属性中，在点击再次下载时，通过调用<code>[ [self.session downloadTaskWithResumeData:self.resumeData]resume]</code>方法进行继续下载操作</p>
<p>经过以上比较可以发现，使用NSURLSession进行断点下载更加便捷.</p>
<h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>NSURLSession的构造方法<code>（sessionWithConfiguration:delegate:delegateQueue）</code>中有一个NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比较与NSURLConnection依赖与一个全局的配置对象，缺乏灵活性而言，NSURLSession有很大的改进了。(关于配置信息，后面会讲解到)</p>
<p>通过以上几点，大概知道了NSURLSession和NSURLConnection的区别，想必下载再遇到这样的问题不会支支吾吾了。下面来点NSURLSession的干货。</p>
<hr>
<p><strong><p align="center">干货开始</p></strong></p>
<hr>
<h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h3><p>NSURLSession 为 HTTP 数据传输提供一系列的接口，而使用 NSURLSession 总共只需要三步：</p>
<ol>
<li>创建NSURLSession对象</li>
<li>通过 NSURLSession 的实例创建 Task</li>
<li>执行 Task</li>
</ol>
<h5 id="如何获取Session对象"><a href="#如何获取Session对象" class="headerlink" title="如何获取Session对象"></a>如何获取Session对象</h5><p> 1.获取默认的 Session 对象</p>
<pre><code>/*
 * 用于基本的网络请求，可以几行代码就获取 URL 的内容，使用简单
 * 无法不断的获取服务器返回的数据
 * 无法修改默认的连接行为
 * 身份验证的能力有限
 * 任务在后台时无法上传和下载
 */
+ (NSURLSession *)sharedSession;
</code></pre><p> 2.自定义 Session 对象</p>
<pre><code> // 不用代理
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;
// 用代理
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration
                                  delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate
                             delegateQueue:(nullable NSOperationQueue *)queue;
</code></pre><p>在使用自定义方式创建NSURLSession对像时，都需要传入一个NSURLSessionConfiguration参数，这个参数是对Session的网络请求的基本配置。那这个NSURLSessionConfiguration都有哪些配置呢？接着往下看</p>
<h3 id="NSURLSessionConfiguration"><a href="#NSURLSessionConfiguration" class="headerlink" title="NSURLSessionConfiguration"></a>NSURLSessionConfiguration</h3><p>有三个方法来创建NSURLSessionConfiguration:</p>
<ul>
<li><strong>defaultSessionConfiguration</strong> 使用全局的cache，cookie,使用硬盘来缓存数据。</li>
<li><strong>ephemeralSessionConfiguration</strong> 临时session配置，与默认配置相比，这个配置不会将缓存、cookie等存在本地，只会存在内存里，所以当程序退出时，所有的数据都会消失</li>
<li><strong>backgroundSessionConfiguration</strong> 后台session配置，与默认配置类似，不同的是会在后台开启另一个线程来处理网络数据。</li>
</ul>
<p>一旦创建了NSURLSessionConfiguration就可以给它设置各种属性</p>
<p><strong>看NSURLSessionConfiguration的头文件:</strong></p>
<pre><code>@interface NSURLSessionConfiguration : NSObject &lt;NSCopying&gt;

/* 三种创建方式 */

+ (NSURLSessionConfiguration *)defaultSessionConfiguration;
+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;
+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0);

/* 当使用上述第三种方式创建后台sessionConfiguration时可以读到初始化时传入的唯一标识，其他创建方式都为空 */
@property (nullable, readonly, copy) NSString *identifier;

/* 
缓存策略，默认值是NSURLRequestUseProtocolCachePolicy
 */
@property NSURLRequestCachePolicy requestCachePolicy;

/* 给request指定每次接收数据超时间隔，如果下一次接受新数据用时超过该值，则发送一个请求超时给该request。默认为60s */
@property NSTimeInterval timeoutIntervalForRequest;

/* 给指定resource设定一个超时时间，resource需要在时间到达之前完成。默认是7天。 */
@property NSTimeInterval timeoutIntervalForResource;

/* 指定网络传输类型。精切指出传输类型，可以让系统快速响应，提高传输质量，延长电池寿命等。
typedef NS_ENUM(NSUInteger, NSURLRequestNetworkServiceType)
{
    NSURLNetworkServiceTypeDefault = 0,    // 普通网络传输，默认使用这个
    NSURLNetworkServiceTypeVoIP = 1,    // 网络语音通信传输，只能在VoIP使用
    NSURLNetworkServiceTypeVideo = 2,    // 影像传输
    NSURLNetworkServiceTypeBackground = 3, // 网络后台传输，优先级不高时可使用。对用户不需要的网络操作可使用
    NSURLNetworkServiceTypeVoice = 4       // 语音传输
};
 */
@property NSURLRequestNetworkServiceType networkServiceType;

/* 是否使用蜂窝网络，默认是yes. */
@property BOOL allowsCellularAccess;

/* 是否由系统根据性能自动裁量后台任务。默认值是NO。同sessionSendsLaunchEvent一样，只对后台configuration有效。 */
@property (getter=isDiscretionary) BOOL discretionary NS_AVAILABLE(10_10, 7_0);

/* 
如果要为app的插件提供session，需要给这个值赋值
 */
@property (nullable, copy) NSString *sharedContainerIdentifier NS_AVAILABLE(10_10, 8_0);

/* 
 表示当后台传输结束时，是否启动app.这个属性只对 后台sessionConfiguration 生效，其他configuration类型会自动忽略该值。默认值是YES。
 */
@property BOOL sessionSendsLaunchEvents NS_AVAILABLE(NA, 7_0);

/* 
指定了会话连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性,默认为NULL
*/
@property (nullable, copy) NSDictionary *connectionProxyDictionary;

/* 确定是否支持SSLProtocol版本的会话
 */
@property SSLProtocol TLSMinimumSupportedProtocol;

/* 
确定是否支持SSLProtocol版本的会话
*/
@property SSLProtocol TLSMaximumSupportedProtocol;

/* 
它可以被用于开启HTTP管道，这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的
 */
@property BOOL HTTPShouldUsePipelining;

/* 
默认为yes,是否提供来自shareCookieStorge的cookie，如果想要自己提供cookie，可以使用HTTPAdditionalHeaders来提供。
 */
@property BOOL HTTPShouldSetCookies;

/* Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage. */
@property NSHTTPCookieAcceptPolicy HTTPCookieAcceptPolicy;

/* 
指定了一组默认的可以设置出站请求的数据头。这对于跨会话共享信息，如内容类型，语言，用户代理，身份认证，是很有用的。
例如：
    @{@&quot;Accept&quot;: @&quot;application/json&quot;,
     @&quot;Accept-Language&quot;: @&quot;en&quot;,
     @&quot;Authorization&quot;: authString,
     @&quot;User-Agent&quot;: userAgentString
   }
 */
@property (nullable, copy) NSDictionary *HTTPAdditionalHeaders;

/* 
同时连接一个host的最大数。iOS默认是4.APP是作为一个整体来看的
 */
@property NSInteger HTTPMaximumConnectionsPerHost;

/* 
存储cookie，清除存储，直接set为nil即可。
对于默认和后台的session，使用sharedHTTPCookieStorage。
对于短暂的session，cookie仅仅储存到内存，session失效时会自动清除。
 */
@property (nullable, retain) NSHTTPCookieStorage *HTTPCookieStorage;

/* 
证书存储，如果不使用，可set为nil.
默认和后台session，默认使用的sharedCredentialStorage.
短暂的session使用一个私有存储在内存中。session失效会自动清除。
 */
@property (nullable, retain) NSURLCredentialStorage *URLCredentialStorage;

/* 
缓存NSURLRequest的response。
默认的configuration，默认值的是sharedURLCache。
后台的configuration，默认值是nil
短暂的configuration，默认一个私有的cache于内存，session失效，cache自动清除。
*/
@property (nullable, retain) NSURLCache *URLCache;

/* Enable extended background idle mode for any tcp sockets created.    Enabling this mode asks the system to keep the socket open
 *  and delay reclaiming it when the process moves to the background (see https://developer.apple.com/library/ios/technotes/tn2277/_index.html) 
 */
@property BOOL shouldUseExtendedBackgroundIdleMode NS_AVAILABLE(10_11, 9_0);

/* 
处理NSURLRequest的NSURLProtocol的子类。
重要:对后台Session失效。
 */
@property (nullable, copy) NSArray&lt;Class&gt; *protocolClasses;

@end
</code></pre><p>现在，我们知道如何来创建一个Session对象了，创建完Session对象，根据一个Request对象我们就可以发送网络请求了。下面看一下NSURLSession的头文件中的这些方法，如图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/NSURLSession1.png?raw=true"><br></div>

<p>从这些方法中得知，分别返回了<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>，<code>NSURLSessionStreamTask</code> 这四个类的对象，那么这四个类是干什么呢？我们接着往下看。</p>
<h3 id="URLSessionTask"><a href="#URLSessionTask" class="headerlink" title="URLSessionTask"></a>URLSessionTask</h3><p>NSURLSessionTask是一个抽象类，其下有4个实体子类可以直接使用：<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>、<code>NSURLSessionStreamTask</code>。这四个子类封装了现代程序四个最基本的网络任务：获取数据，比如JSON或者XML，上传文件和下载文件还有数据流的获取。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/NSURLSessionTask.png?raw=true"><br></div>

<p>NSURLSession比NSURLConnection最方便的地方就是任务可以暂停，继续。在网络请求中，真正去执行下载或者上传任务的就是URLSessionTask，我们来看一下它常用的方法：</p>
<p><code>- (void)resume;</code> 当使用NSURLSession创建一个NSURLSessionTask任务时，要手动调用此方法，任务才会开启，而NSURLConnection默认开启。</p>
<p><code>- (void)suspend;</code> 暂停任务方法，手动调用会暂停当前任务，再次开启此任务时，会从紧接上次任务开始，会面会说到如何暂停任务再开启任务。</p>
<p><code>- (void)cancel;</code> 取消任务。</p>
<p>NSURLSessionTask还有个属性，<code>@property (readonly) NSURLSessionTaskState state;</code> 此属性标识当前任务的状态，枚举类型</p>
<pre><code>typedef NS_ENUM(NSInteger, NSURLSessionTaskState) {
    NSURLSessionTaskStateRunning = 0,                     /* 正在执行 */
    NSURLSessionTaskStateSuspended = 1,                   /* 暂停状态 */
    NSURLSessionTaskStateCanceling = 2,                   /* 取消状态*/
    NSURLSessionTaskStateCompleted = 3,                   /* 任务完成状态 */
}
</code></pre><p>上面说到的四个类，都直接或间接继承NSURLSessionTask，所有NSURLSessionTask的方法或者属性这四个类都有，那么，简单说一下这四个类都是干什么的。</p>
<h4 id="NSURLSessionDataTask"><a href="#NSURLSessionDataTask" class="headerlink" title="NSURLSessionDataTask"></a>NSURLSessionDataTask</h4><p>NSURLSessionDataTask是开发中使用频率最高的，我们平常使用的GET和POST请求都是通过它来实现的，如果请求的数据简单并且不需要对获取的数据进行复杂操作，我们使用 Block 解析返回的数据即可。具体代码如下：</p>
<h5 id="简单-Get-请求"><a href="#简单-Get-请求" class="headerlink" title="简单 Get 请求"></a>简单 Get 请求</h5><pre><code>/**
 *  简单 GET 请求
  */
- (void)getWithsharedSession
{
  // 获取默认 Session
  NSURLSession *session = [NSURLSession sharedSession];
  // 创建 URL
  NSURL *url = [NSURL URLWithString:@&quot;https://www.baidu.com/s?wd=test&quot;];
  // 创建任务 task
  NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
    // 获取数据后解析并输出
     NSString *dataStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    NSLog(@&quot;%@&quot;,dataStr);
  }];
  // 启动任务
  [task resume];
}
</code></pre><h5 id="简单-POST-请求"><a href="#简单-POST-请求" class="headerlink" title="简单 POST 请求"></a>简单 POST 请求</h5><pre><code>/**
 *  简单 Post 请求，POST 和 GET 请求在于对 request 的处理不同，其余和 GET 相同
 */
- (void)postWithSharedSession
{
  // 获取默认 Session
  NSURLSession *session = [NSURLSession sharedSession];
  // 创建 URL
  NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login&quot;];
  // 创建 request
  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
  // 请求方法
  request.HTTPMethod = @&quot;POST&quot;;
  // 请求体
  request.HTTPBody = [@&quot;username=1234&amp;pwd=4321&quot; dataUsingEncoding:NSUTF8StringEncoding];
  // 创建任务 task
  NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
          // 获取数据后解析并输出
          NSLog(@&quot;%@&quot;,[NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);
  }];
  // 启动任务
  [task resume];
}
</code></pre><p>另外我们也可以设置session的代理来实时的监听数据，我们可以使用NSURLSession的<code>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;</code>和<code>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue;</code>这两个方法来设置代理，具体的协议为<code>NSURLSessionDelegate</code>，它有四个直接或间接子协议<code>NSURLSessionTaskDelegate</code>，<code>NSURLSessionDownloadDelegate</code>和 <code>NSURLSessionStreamDelegate</code>、<code>NSURLSessionDataDelegate</code>。具体代理方法如下：</p>
<pre><code>//创建有代理的session
- (void)sessionDataDelegate
{
    // 创建带有代理方法的自定义 session
    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];

    // 创建任务
    NSURLSessionDataTask *task = [session dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=1234&amp;pwd=4321&quot;]]];

    // 启动任务
    [task resume];
}

#pragma mark -
#pragma mark - NSURLSessionDelegate

// 1. 接收到服务器的响应
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler
{
    NSLog(@&quot;接收到服务器的响应&quot;);
    // 必须设置对响应进行允许处理才会执行后面两个操作。
    completionHandler(NSURLSessionResponseAllow);
}

// 2. 接收到服务器的数据（可能调用多次）
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {
    // 处理每次接收的数据
    NSLog(@&quot;接受到服务器的数据%s&quot;,__func__);
}

// 3. 请求成功或者失败（如果失败，error有值）
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {
    // 请求完成,成功或者失败的处理
    NSLog(@&quot;SessionTask %s&quot;,__func__);
}
</code></pre><h4 id="NSURLSessionDownloadTask"><a href="#NSURLSessionDownloadTask" class="headerlink" title="NSURLSessionDownloadTask"></a>NSURLSessionDownloadTask</h4><p>NSURLSessionDownloadTask在下载文件的时候，是将数据一点点地写入本地的临时文件。所以在 completionHandler 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：</p>
<pre><code>/**
 *  NSURLSessionDownloadTask 下载任务
 */
- (void)downLoad
{
    NSURLSession *session = [NSURLSession sharedSession];
    NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/images/minion_01.png&quot;] ;
    NSURLSessionDownloadTask *task = [session downloadTaskWithURL:url completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) {
        // location 是沙盒中 tmp 文件夹下的一个临时 url，文件下载后会存到这个位置，由于 tmp 中的文件随时可能被删除，所以我们需要自己需要把下载的文件挪到 Caches 文件夹中
        NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename];
        // 剪切文件
        [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:path] error:nil];
        NSLog(@&quot;%@&quot;,[NSThread currentThread]);
        //切记当前为子线程，
        dispatch_async(dispatch_get_main_queue(), ^{
            self.imageView.image = [UIImage imageNamed:path];
        });

    }];
    // 启动任务
    [task resume];
}
</code></pre><p>代理方法下载</p>
<pre><code>/**
 *  NSURLSessionDownloadTask 代理
 */
- (void)sessionDownloadTaskDelegate
{
  // 创建带有代理方法的自定义 session
  NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];

  // 创建任务
  NSURLSessionDownloadTask *task = [session downloadTaskWithURL:[NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/images/minion_02.png&quot;]];

  // 启动任务
  [task resume];
}
#pragma mark -
#pragma mark -NSURLSessionDownloadDelegate
/**
 *  写入临时文件时调用
 *  @param bytesWritten              本次写入大小
 *  @param totalBytesWritten         已写入文件大小
 *  @param totalBytesExpectedToWrite 请求的总文件的大小
 */
- (void)URLSession:(NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
{
    //可以监听下载的进度
  CGFloat progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
  NSLog(@&quot;downloadTask %f&quot;,progress);
}

// 2. 下载完成调用
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location
{
  // location 还是一个临时路径,需要自己挪到需要的路径（caches 文件夹）
  NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];
  [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:filePath] error:nil];
  NSLog(@&quot;downloadTask 移动文件路径&quot;);
}
</code></pre><h5 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h5><p>说一下开发中经常用到的断点续传。在开发中，我们经常由于某种原因，在下载或上传的时候往往不能一次性下载或上传完，有可能下载或上传了一半就终止了，这时候当条件满足继续下载或上传时，我们不希望从头开始，这时候就可以使用断点续传。它的大概思路是：</p>
<ul>
<li>某种限制，续传暂停</li>
<li>将暂停后数据（当前数据）保存起来–_resumeData = resumeData;</li>
<li>条件允许续传时，使用resumeData创建新的NSURLSessionTask</li>
</ul>
<p>代码：</p>
<pre><code>- (IBAction)startDowning:(id)sender {


    if (_resumeData) {
        _downloadTask = [_session downloadTaskWithResumeData:_resumeData];
    }else {
        _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil];
        _request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:@&quot;http://image.baidu.com/search/down?tn=download&amp;ipn=dwnl&amp;word=download&amp;ie=utf8&amp;fr=result&amp;url=http%3A%2F%2Fb.zol-img.com.cn%2Fdesk%2Fbizhi%2Fimage%2F6%2F960x600%2F1427787678554.jpg&amp;thumburl=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D1996019669%2C1779575266%26fm%3D21%26gp%3D0.jpg&quot;]];
        _downloadTask = [_session downloadTaskWithRequest:_request];
    }
    [_downloadTask resume];
}

- (IBAction)stopDowning:(id)sender {
    if (_downloadTask) {
        __weak typeof (self)weakSelf = self;
        [_downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) {
            NSLog(@&quot;%@&quot;,resumeData);
            weakSelf.resumeData = resumeData;
            weakSelf.downloadTask = nil;
        }];
    }
}

#pragma mark -
#pragma mark - NSURLSessionDownloadDelegate

- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location {
    NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];
    // 剪切文件
    [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:path] error:nil];

    dispatch_async(dispatch_get_main_queue(), ^{
        self.imageView.image = [UIImage imageNamed:path];
    });
}
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
    CGFloat progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
    NSLog(@&quot;downloadTask %f&quot;,progress);
    dispatch_async(dispatch_get_main_queue(), ^{
        self.progressView.progress = progress;
    });

}
</code></pre><p><strong>注意：</strong>上面的代码是不会断点续传的，原因是这个图片的url不支持断点续传，在断点续传时，要和服务器配合好。</p>
<h4 id="NSURLSessionUploadTask"><a href="#NSURLSessionUploadTask" class="headerlink" title="NSURLSessionUploadTask"></a>NSURLSessionUploadTask</h4><p>在 NSURLSession 中，文件上传主要使用两种方式：</p>
<pre><code>- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;
</code></pre><p>我们这里使用第二个方法，表单的形式上传数据</p>
<pre><code>- (void)upload {
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://api.weibo.com/2/statuses/public_timeline.json&quot;]];
    //设置HTTP请求方式  GET / POST
    [request setHTTPMethod:@&quot;POST&quot;];
    //设置请求头
    NSString *boundary = @&quot;hwg&quot;;
    [request setValue:[NSString stringWithFormat: @&quot;multipart/form-data;%@&quot;, boundary]forHTTPHeaderField:@&quot;Content-type&quot;];
    //设置请求体
    //获取上传的图片的data
    NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;xiaoxin&quot; ofType:@&quot;jpeg&quot;]];
    //此处添加需要看清楚内容
    NSData *body =  [self httpFormDataBodyWithBoundary:boundary params:@{@&quot;access_token&quot;:@&quot;2.00cYYKWF6EKpiB3883361b1dJiZ4eD&quot;,@&quot;status&quot;:@&quot;哈哈，这是我测试NSURLSession上传文件的微博&quot;} fieldName:@&quot;pic&quot; fileName:@&quot;pic.png&quot; fileContentType:@&quot;image/png&quot; data:data];
    NSURLSession *session = [NSURLSession sharedSession];
    NSURLSessionUploadTask *upload_task = [session uploadTaskWithRequest:request fromData:body completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        NSLog(@&quot;upload  success&quot;);
    }];
    //必须要 resume
    [upload_task resume];
}

#pragma mark-拼接请求体
- (NSData *)httpFormDataBodyWithBoundary:(NSString *)boundary
                                 params:(NSDictionary *)params
                              fieldName:(NSString *)fieldName
                               fileName:(NSString *)fileName
                        fileContentType:(NSString *)fileContentType
                                   data:(NSData *)fileData {

    NSString *preBoundary = [NSString stringWithFormat:@&quot;--%@&quot;,boundary];
    NSString *endBoundary = [NSString stringWithFormat:@&quot;--%@--&quot;,boundary];
    NSMutableString *body = [[NSMutableString alloc] init];
    //遍历
    for (NSString *key in params) {
        //得到当前的key
        //如果key不是当前的pic，说明value是字符类型，比如name：Boris
        //添加分界线，换行，必须使用\r\n
        [body appendFormat:@&quot;%@\r\n&quot;,preBoundary];
        //添加字段名称换2行
        [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;\r\n\r\n&quot;,key];
        //添加字段值
        [body appendFormat:@&quot;%@\r\n&quot;,[params objectForKey:key]];

    }
    //添加分界线，换行
    [body appendFormat:@&quot;%@\r\n&quot;,preBoundary];
    //声明pic字段，文件名为boris.png
    [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;; filename=\&quot;%@\&quot;\r\n&quot;,fieldName,fileName];
    //声明上传文件的格式
    [body appendFormat:@&quot;Content-Type: %@\r\n\r\n&quot;,fileContentType];
    //声明结束符
    NSString *endStr = [NSString stringWithFormat:@&quot;\r\n%@&quot;,endBoundary];
    //声明myRequestData，用来放入http  body
    NSMutableData *myRequestData = [NSMutableData data];
    //将body字符串转化为UTF8格式的二进制
    [myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];
    //将image的data加入
    [myRequestData appendData:fileData];
    //加入结束符--hwg--
    [myRequestData appendData:[endStr dataUsingEncoding:NSUTF8StringEncoding]];
    return myRequestData;
}
</code></pre><p>这里我们需要拼接一个表单数据，才能够上传数据。 当然，我们也可以用代理方法来监听上传的进度</p>
<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task
   didSendBodyData:(int64_t)bytesSent
    totalBytesSent:(int64_t)totalBytesSent
totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
    CGFloat progress = 1.0 * totalBytesSent / bytesSent;
    NSLog(@&quot;downloadTask %f&quot;,progress);
}
</code></pre><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>以上就是我今天总结的，哪里有问题还希望大家提出意见。其实在开发中，我们很少使用到这些，因为总是有一些牛人为我们封装了各种功能的强大库，比如网络类，最常用的就是AFNetworking。人家的库为什么好用，说白了就是各种情况都考虑到了。所有我们要学的还是人家的编程思想。接下来，我会做一个专题，研究一下各大平常使用到的库，它们到底牛在哪里，敬请阅读！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天去面试，被问了一道AFNetworking2.0和3.0有什么区别，当时心想，这谁不知道啊，随口答到：2.0使用的NSURLConnection,3.0使用的是NSURLSession,人家又问NSURLSesstion和NSURLConnection有什么区别，瞬间傻眼了，支支吾吾只是说出了缓存策略的不同。亡羊补牢，为时未晚，这篇博客就讲解一下它们两者到底有什么区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="NSURLSession" scheme="http://www.guiyongdong.com/tags/NSURLSession/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://www.guiyongdong.com/2016/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.guiyongdong.com/2016/11/15/排序算法总结/</id>
    <published>2016-11-15T03:40:05.000Z</published>
    <updated>2016-11-16T08:26:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十大排序算法比较图"><a href="#十大排序算法比较图" class="headerlink" title="十大排序算法比较图"></a>十大排序算法比较图</h3><hr>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/15.png?raw=true"><br></div>



<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<p><strong>算法描述</strong><br><strong>冒冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</strong></p>
<p><strong>算法实现</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortBubble:(NSMutableArray *)targetArray {
    BOOL flag = true;  //flag 用来做标记
    NSInteger num = 0; //标记总比较次数
    for (NSInteger i = 0; i &lt; targetArray.count&amp;&amp;flag; i++) { //若flag为true  则退出循环
        flag = false;   //初始是false
        for (NSInteger j = 0; j &lt; targetArray.count - i-1; j++) {
            num++;
            NSLog(@&quot;---%ld&quot;,num);
            if ([targetArray[j] integerValue] &gt; [targetArray[j+1] integerValue]) {
                id temp = targetArray[j];
                targetArray[j] = targetArray[j+1];
                targetArray[j+1] = temp;
                flag = true;
            }
        }
    }
    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><a id="more"></a>
<p><strong>时间复杂度:</strong><br>分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据上面的代码可以推断就是n-1次的比较。没有数据交换，时间复杂度是O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较:1+2+3+…+(n-1)=n(n-1)/2次，因此总的时间复杂度是O(n<sup>2</sup>)。</p>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/16.gif?raw=true"><br></div>



<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><hr>
<p><strong>算法描述</strong><br><strong>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</strong></p>
<p><strong>算法实现</strong></p>
<ol>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortSimple:(NSMutableArray *)targetArray {
    NSInteger min;
    for (NSInteger i = 0; i &lt; targetArray.count - 1; i++) {
        min = i; //将当前下标定义为最小值下标
        for (NSInteger j = i + 1; j &lt; targetArray.count; j++) {
            if (targetArray[min] &gt; targetArray[j]) { //如果有小于当前最小值得关键字
                min = j; //将此关键字的下标赋值给min
            }
        }
        if (i != min) {  //如果min和i不相等  说明找到最小值，交换
            id temp = targetArray[i];
            targetArray[i] = targetArray[min];
            targetArray[min] = temp;
        }
    }
    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><p><strong>时间复杂度：</strong><br>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较n-1+n-2+…+1=n(n-1)/2次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就是初始降序时2，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n<sup>2</sup>)。</p>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/17.gif?raw=true"><br></div>


<p>应该说，尽管与冒泡排序的时间复杂度同为O(n<sup>2</sup>)，但简单选择排序的性能上还是要略优于冒泡排序。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><hr>
<p><strong>算法描述</strong></p>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p><strong>算法实现</strong></p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortInsertion:(NSMutableArray *)targetArray {
    for (NSInteger i = 1; i &lt; targetArray.count; i++) {
        id key = targetArray[i];
        NSInteger j = i - 1;
        while (j &gt;= 0 &amp;&amp; targetArray[j] &gt; key) {
            targetArray[j+1] = targetArray[j];
            j--;
        }
        targetArray[j+1]=key;
    }
    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/18.gif?raw=true"><br></div>


<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr>
<p><strong>算法描述</strong><br>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p>
<p><strong>算法实现</strong><br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortShell:(NSMutableArray *)targetArray {
    NSInteger increment = targetArray.count;
    NSInteger i,j;
    do {
        increment = increment/3+1;//增量序列
        for (i=increment; i&lt;targetArray.count; i++) {
            if ([targetArray[i] integerValue] &lt; [targetArray[i-increment] integerValue]) {
                id temp = targetArray[i];
                for (j=i-increment; j&gt;=0&amp;&amp;[targetArray[j] integerValue] &gt; [temp integerValue]; j-=increment) {
                    targetArray[j+increment] = targetArray[j];
                }
                targetArray[j+increment] = temp;
            }
        }

    } while (increment &gt; 1);

    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/19.jpg?raw=true"><br></div>


<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<p><strong>算法描述</strong><br>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>算法实现</strong></p>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortHeap:(NSMutableArray *)targetArray {
    NSInteger heapSize = targetArray.count;
    id temp;
    //建堆
    for (NSInteger i = heapSize/2-1; i&gt;=0; i--) {
        [self heapify:targetArray index:i lenght:heapSize];
    }
    //堆排序
    for (NSInteger j = heapSize-1; j &gt;= 1; j--) {
        temp = targetArray[0];
        targetArray[0] = targetArray[j];
        targetArray[j] = temp;
        [self heapify:targetArray index:0 lenght:--heapSize];
    }
    NSLog(@&quot;%@&quot;,targetArray);
}

- (void)heapify:(NSMutableArray *)targetArray index:(NSInteger)x lenght:(NSInteger)len {
    NSInteger l=2*x+1,r=2*x+2,largest=x;
    id temp;
    if (l &lt; len &amp;&amp; [targetArray[l] integerValue] &gt; [targetArray[largest] integerValue]) {
        largest = l;
    }
    if (r &lt; len &amp;&amp; [targetArray[r] integerValue] &gt; [targetArray[largest] integerValue]) {
        largest = r;
    }
    if (largest != x) {
        temp = targetArray[x];
        targetArray[x] = targetArray[largest];
        targetArray[largest] = temp;
        [self heapify:targetArray index:largest lenght:len];
    }
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/20.gif?raw=true"><br></div>


<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<p><strong>算法描述</strong><br>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p><strong>算法实现</strong></p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>- (NSMutableArray *)sortMerge:(NSMutableArray *)targetArray {
    NSInteger len = targetArray.count;
    NSInteger middle = len/2;
    if (len &lt; 2) {
        return targetArray;
    }
    NSMutableArray *leftArray = [NSMutableArray arrayWithArray:[targetArray subarrayWithRange:NSMakeRange(0, middle)]];
    NSMutableArray *rightArray = [NSMutableArray arrayWithArray:[targetArray subarrayWithRange:NSMakeRange(middle, len-middle)]];
    NSMutableArray *array = [self merge:[self sortMerge:leftArray] right:[self sortMerge:rightArray]];
    NSLog(@&quot;%@&quot;,array);
    return array;

}

- (NSMutableArray *)merge:(NSMutableArray *)leftArray right:(NSMutableArray *)rightArray {
    NSMutableArray *resultArray = [NSMutableArray array];
    while (leftArray.count &amp;&amp; rightArray.count) {
        if ([leftArray[0] integerValue] &lt;= [rightArray[0] integerValue]) {
            [resultArray addObject:leftArray[0]];
            [leftArray removeObjectAtIndex:0];
        }else {
            [resultArray addObject:rightArray[0]];
            [rightArray removeObjectAtIndex:0];
        }
    }
    while (leftArray.count) {
        [resultArray addObject:leftArray[0]];
        [leftArray removeObjectAtIndex:0];
    }
    while (rightArray.count) {
        [resultArray addObject:rightArray[0]];
        [rightArray removeObjectAtIndex:0];
    }

    return resultArray;
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/21.gif?raw=true"><br></div>


<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr>
<p><strong>算法描述</strong><br>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><strong>算法实现</strong><br>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortQuick:(NSMutableArray *)targetArray {
    [self quick:targetArray left:0 right:targetArray.count-1];
    NSLog(@&quot;%@&quot;,targetArray);
}

- (void)quick:(NSMutableArray *)targetArray left:(NSInteger)left right:(NSInteger)right {
    NSInteger pivot;
    if (left &lt; right) {
        pivot = [self partition:targetArray left:left right:right];
        [self quick:targetArray left:left right:pivot-1];
        [self quick:targetArray left:pivot+1 right:right];
    }
}

- (NSInteger)partition:(NSMutableArray *)targetArray left:(NSInteger)left right:(NSInteger)right {
    id pivotKey = targetArray[left];
    id temp;
    while (left &lt; right) {
        while (left &lt; right &amp;&amp; [targetArray[right] integerValue] &gt; [pivotKey integerValue]) {
            right--;
        }
        temp = targetArray[left];
        targetArray[left] = targetArray[right];
        targetArray[right] = temp;
        while (left &lt; right &amp;&amp; [targetArray[left] integerValue] &lt;= [pivotKey integerValue]) {
            left++;
        }
        temp = targetArray[left];
        targetArray[left] = targetArray[right];
        targetArray[right] = temp;
    }

    return left;
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/22.gif?raw=true"><br></div>














]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;十大排序算法比较图&quot;&gt;&lt;a href=&quot;#十大排序算法比较图&quot; class=&quot;headerlink&quot; title=&quot;十大排序算法比较图&quot;&gt;&lt;/a&gt;十大排序算法比较图&lt;/h3&gt;&lt;hr&gt;
&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/15.png?raw=true&quot; /&gt;&lt;br&gt;&lt;/div&gt;



&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;算法描述&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;冒冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法实现&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换它们两个；&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个；&lt;/li&gt;
&lt;li&gt;重复步骤1~3，直到排序完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)sortBubble:(NSMutableArray *)targetArray {
    BOOL flag = true;  //flag 用来做标记
    NSInteger num = 0; //标记总比较次数
    for (NSInteger i = 0; i &amp;lt; targetArray.count&amp;amp;&amp;amp;flag; i++) { //若flag为true  则退出循环
        flag = false;   //初始是false
        for (NSInteger j = 0; j &amp;lt; targetArray.count - i-1; j++) {
            num++;
            NSLog(@&amp;quot;---%ld&amp;quot;,num);
            if ([targetArray[j] integerValue] &amp;gt; [targetArray[j+1] integerValue]) {
                id temp = targetArray[j];
                targetArray[j] = targetArray[j+1];
                targetArray[j+1] = temp;
                flag = true;
            }
        }
    }
    NSLog(@&amp;quot;%@&amp;quot;,targetArray);
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://www.guiyongdong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>查找算法之线性索引查找法</title>
    <link href="http://www.guiyongdong.com/2016/11/14/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>http://www.guiyongdong.com/2016/11/14/查找算法之线性索引查找法/</id>
    <published>2016-11-14T07:28:07.000Z</published>
    <updated>2016-11-15T03:42:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构，<strong>索引就是把一个关键字与它对应的记录相关联的过程，</strong>一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</p>
<p>索引按照结构可以分为线性索引、树形索引和多级索引。这里只介绍线性索引技术。<strong>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。</strong>这里介绍三种线性索引：<strong>稠密索引、分块索引、倒排索引。</strong></p>
<a id="more"></a>
<h3 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h3><hr>
<p><strong>稠密索引是指在线性索引中，将数据集中的每一个记录对应一个索引项。</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/11.png?raw=true"><br></div>

<p><strong>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列</strong></p>
<p>索引项也有序也就意味着，我们要查找关键字时，可以用到折半，插值，斐波那契等有序查找算法，大大提高了效率。比如上图，我要查找关键字是18的记录，如果直接从右侧的数据表中查找，那只能顺序查找，需要查找6次才可以查到结果。而如果是从左侧的索引表中查找，只需两侧折半查找就可以得到18对应的指针，最终查找到结果。</p>
<p>这显然是稠密索引优点，到时如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说 ，可能就需要反复去访问磁盘，查找性能反而大大下降了。</p>
<h3 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h3><hr>
<p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立索引项，从而减少索引项的个数。</p>
<p><strong>分块有序，是把数据集的记录分成了若干块，并且这些快需要满足两个条件：</strong></p>
<ul>
<li><strong>块内无序，</strong>即每一块内的记录不要求有序，当然，如果块内记录有序更理想，不过块内有序需要大量时间和空间的代价，通常要求快内无序。</li>
<li><strong>块间有序,</strong>例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。</li>
</ul>
<p><strong>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引</strong></p>
<p>如图所示，定义的分块索引的索引项结构分三个数据项：</p>
<ul>
<li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块的最大关键字要大;</li>
<li>存储了块中的记录个数，以便于循环时使用;</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li>
</ul>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/12.png?raw=true"><br></div>

<p>在分块索引表中查找，就是分两步进行：</p>
<ol>
<li>在分块索引表中查找关键字所在的块。由于分块索引表是快间有序的，因此很容易利用折半，插值等算法得到结果。</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找。</li>
</ol>
<p>分块索引的时间复杂度：<br>设n个记录的数据集被平分成m块，每块中有t条记录，显然n=m×t,或者说m=n/t。再假设L<sub>b</sub>为查找索引表的平均查找长度，因最好与最差的等概率原则，所以L<sub>b</sub>的平均长度为(m+1)/2。L<sub>w</sub>为块中查找记录的平均查找长度，同理可知它的平均查找长度为(t+1)/2。这样分块索引查找的平均查找长度为:</p>
<div align="center"><br>ASL<sub>w</sub>=L<sub>b</sub>+L<sub>w</sub>=(m+1)/2+(t+1)/2=(1/2)*((n/t)+t)+1<br></div>

<p>注意上面这个式子的推导是为了让整个分块索引查找长度依赖n和t两个变量。从这里我们得到，平均长度不仅仅取决于数据集的总记录数n，还和每一个块的记录数t有关，最佳的情况就是分的块数m和块中的记录数t相同，此时意味着n=m×t=t<sup>2</sup>,即ASL<sub>w</sub>=(1/2)*((n/t)+t)+1=&radic;n+1</p>
<p>可见，分块索引的效率比之顺序查找的O(n)是高了不少。不过显然它与折半查找的O(logn)相比还是有不小的差距，因此在确定所在块的过程中，由于块间有序，所以可以应用折半，插值等手段来提高效率。</p>
<p>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据表查找等技术的应用中。</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><hr>
<p>在我们使用百度或者谷歌搜索的时候，当我们输入某个信息，搜索引擎都会在短时间内给我们一些结果，如图，它是用到什么算法技术实现的高效查找呢？</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/13.png?raw=true"><br></div>

<p>这里简单介绍，也算是最基础的搜索技术——倒排索引。<br>当然，搜索引擎所使用到的算法绝对比这复杂的多。<br>例如我们看如下两句话：</p>
<ol>
<li>Books and friends should be few but good</li>
<li>A good book is a good friend</li>
</ol>
<p>如图所示，我们将单词做了排序，也就是表格显示了每个不同的单词分别出现在哪篇文章中。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/14.png?raw=true"><br></div>

<p>有了这张表，我们在查每个单词时都能很快的查找到这个单词在哪篇文章。<br>在这里这张单词表就是索引表，索引项的通用结构是：</p>
<ul>
<li>次关键码，例如上表中的“英文单词”</li>
<li>记录号表，例如上表中的“文章编号”</li>
</ul>
<p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构，&lt;strong&gt;索引就是把一个关键字与它对应的记录相关联的过程，&lt;/strong&gt;一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。&lt;/p&gt;
&lt;p&gt;索引按照结构可以分为线性索引、树形索引和多级索引。这里只介绍线性索引技术。&lt;strong&gt;所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。&lt;/strong&gt;这里介绍三种线性索引：&lt;strong&gt;稠密索引、分块索引、倒排索引。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="http://www.guiyongdong.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找算法之有序表查找</title>
    <link href="http://www.guiyongdong.com/2016/11/10/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE/"/>
    <id>http://www.guiyongdong.com/2016/11/10/查找算法之有序表查找/</id>
    <published>2016-11-10T08:46:24.000Z</published>
    <updated>2016-11-15T03:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="折半查找法"><a href="#折半查找法" class="headerlink" title="折半查找法"></a>折半查找法</h3><p><strong>折半查找(Binary Search)技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序(通常从小到大)，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找，不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</strong></p>
<a id="more"></a>
<p>假设现在有这样一个有序数组{0,1,16,24,35,47,59,62,73,88,99}，对它进行查找是否存在62这个数，我们来看折半查找的算法是如何工作的。</p>
<pre><code>/* 折半查找 **/
- (NSInteger)binary_search:(NSArray *)targetArray key:(NSInteger)key {
    NSInteger low,high,mid;
    low = 0;  /*定义最低下标为记录首位*/
    high = targetArray.count-1;  /*记录最高下标为记录末位*/
    while (low &lt;= high) {
        mid = (low + high)/2;   /*折半*/
        if (key &lt; [targetArray[mid] integerValue]) { /*若查找值比中值小*/
            high = mid-1;  /*最高下标调整到中位下标小一位*/
        }else if (key &gt; [targetArray[mid] integerValue]) {  /*若查找值比中值大*/
            low = mid+1;  /*最低下标调整到中位下标大一位*/
        }else {
            return mid;   /*若相等则说明mid即为查找到的位置*/
        }
    }
    return -1;
}
</code></pre><p>具体执行步骤为：</p>
<p>1.程序开始运行，参数targetArray={0,1,16,24,35,47,59,62,73,88,99}, key=62,初始化时，此时low=1,high=10,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/1.png?raw=true"><br></div>

<p>2.开始循环，进行查找。<br>3.开始折半，mid计算得5，由于[targetArray[5] integerValue]=47&lt;key,所以执行了low = mid+1，low=6,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/2.png?raw=true"><br></div>

<p>4.再次循环， mid=(6+10)/2=8,此时[targetArray[8] integerValue]=73&gt;key,所以执行high = mid-1，high=7,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/3.png?raw=true"><br></div>

<p>5.再次循环，mid=(6+7)/2=6,此时[targetArray[6] integerValue]=59&lt;key,所以执行了low = mid+1，low=7,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/4.png?raw=true"><br></div>

<p>6.再次循环，mid=(7+7)/2=7, 此时[targetArray[7] integerValue]=62=key,查找成功，返回7.</p>
<p>该算法还是比较容易理解的，同时它的效率也是非常的高，但到底有多高，我们来计算此算法的时间复杂度。</p>
<p>首先， 将这个数组的查找过程绘制成一棵二叉树，如图所示，从图中可以理解，如果查找的关键字不是中间记录47的话，折半查找等于是把静态有序查找表分成了两棵子树，即查找结果只需要找其中的一半数据即可，等于工作量减少了一半，然后继续折半查找，效率当然是非常高了。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/5.png?raw=true"><br></div>

<p>由<strong>“具有n个结点的完全二叉树的深度为「log2n」+1”</strong> 可以看出，查找关键字的最坏为「log2n」+1  最好情况为1 所以折半算法的时间复杂度为0(logn),它显然好于顺序查找的O(n)时间复杂度了。</p>
<p>不过由于折半查找的前提条件是需要有序顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了，但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>如果对折半查找的第8句代码进行改造，得到如下公式mid=(low+high)/2=low+(high-low)/2;<br>也就是mid等于最低下标low加上最高下标high与low的差的一半，再进一步的改进得到如下方案：mid=low+(high-low)*(key-targetArray[low])/(targetArray[high]-targetArray[low]);<br>这就是插值查找的算法。</p>
<p><strong>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字做比较后的查找方法，其核心就在于插值的计算公式：<br>（key-targetArray[low]）/(targetArray[high]-targetArray[low])。</strong> 应该说从时间复杂度来看，它也是O(logn),但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多，反之，数组中如果分布类似{0,1,2,2000,200,…..,999998,999999}这种极端不均匀的数据，用插值查找未必是最合适的选择。</p>
<h3 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h3><p><strong>斐波那契查找(Fibonacci Search)，它是利用了黄金分割原理来实现的。斐波那契数列：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/6.png?raw=true"><br></div>

<p>上代码：</p>
<pre><code>/* 斐波那契查找 */
1  - (NSInteger)fibonacci_Search:(NSMutableArray *)targetArray key:(NSInteger)key {
2     NSArray *F = @[@0,@1,@1,@2,@3,@5,@8,@13,@21,@34];  /*斐波那契数列*/
3     NSInteger low,high,mid,i,k,n;
4     low = 0;  /*定义最低下标为记录首位*/
5     high = targetArray.count-1;  /*定义最高下标为记录末位*/
6     k = 0;
7     n = targetArray.count-1;
8     while (n &gt; [F[k] integerValue] - 1) {
9         k++;
10    }
11    for (i = n; i&lt;[F[k] integerValue]-1; i++) {  /*将不满的数值补齐*/
12        targetArray[i]=targetArray[n];
13    }

14    while (low &lt;= high) {
15        mid = low + [F[k-1] integerValue] - 1;  /*计算当前分割的下标*/
16        if (key &lt; [targetArray[mid] integerValue]) {  /*若查找记录小于当前分割记录*/
17            high = mid - 1;   /*最高下标调整到分割下标mid-1处*/
18            k = k - 1;  /*斐波那契数列下标减一位*/
19        }else if (key &gt; [targetArray[mid] integerValue]) {  /*若查找记录大于当前分割记录*/
20            low = mid + 1;   /*最低下标调整到分割下标mid+1处*/
21            k = k - 2;   /*斐波那契数列下标减两位*/
22        }else {
23            if (mid &lt;= n) {
24                return mid;  /*若相等则说明mid即为查找到的位置*/
25            }else {
26                return n;   /*若mid&gt;n说明是补全数值，返回n*/
27            }
28        }
29    }
30    return -1;
31  }
</code></pre><p>1.程序开始运行，参数targetArray={0,1,16,24,35,47,59,62,73,88,99},要查找的关键字key=59。注意此时我们已经有了事先计算好的全局变量数值F的具体数据，它的斐波那契数列，F={0,1,1,2,3,5,8,13,21,…..}。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/7.png?raw=true"><br></div>

<p>2.第6~10行是计算当前的n处于斐波那契数列的位置，现在n=10，F[6]&lt;n&lt;F[7],所以计算得出k=7。</p>
<p>3.第11~13行，由于k=7,计算时是以F[7]=13<br>为基础，而a中最大的仅是a[10],后面的a[11],a[12]均为赋值，这不能构成有序数列，因此将它们都赋值为最大的数值值，所以此时a[11]=a[12]=a[10]=99。</p>
<p>4.第14~29行查找正式开始。</p>
<p>5.第15行，mid=0+F[7-1]-1=7,也就是说，我们第一个要对比的数值是从下标为7开始的。</p>
<p>6.由于此时key=59 而targetArray[7]=62,因此执行第17~18行，得到high=6,k=6,</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/8.png?raw=true"><br></div>

<p>7.再次循环，mid=0+F[6-1]-1=4。此时targetArray[4]=35&lt;key,因此执行20~21行，得到low=4+1=5,k=6-2=4,注意此时k下调2个单位。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/9.png?raw=true"><br></div>

<p>8.再次循环，mid=5+F[4-1]-1=6。此时targetArray[6]=59=key,因此执行第24行，返回mid=6。程序结束运行。</p>
<p>斐波那契查找算法的核心在于：</p>
<ol>
<li>当key=targetArray[mid]时，查找就成功；</li>
<li>当key=targetArray[mid]时,新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个；</li>
<li>当key&gt;targetArray[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个。</li>
</ol>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/10.png?raw=true"><br></div>

<p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些，所以尽管斐波那契查找的时间复杂度也为O(logn)，但就平均性能来说，斐波那契查找要优于折半查找。可惜如果最坏情况，比如这里key=1,那么始终都处于左侧长半区在查找，则查找效率要低折半查找。</p>
<p>还有比较关键的一点，折半查找是进行加法与除法运算(mid=(low+high)/2)，插值查找进行复杂的四则运算(mid=low+(high-low)*(key-targetArray[high]-targetArray[low])),而斐波那契查找只是最简单加减法运算(mid=low+F[k-1]-1),在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。</p>
<p>以上三种有序表的查找本质上是分割点的选择不同，各有各的优劣，实际开发中，可以根据数据的特点综合考虑再做出选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;折半查找法&quot;&gt;&lt;a href=&quot;#折半查找法&quot; class=&quot;headerlink&quot; title=&quot;折半查找法&quot;&gt;&lt;/a&gt;折半查找法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;折半查找(Binary Search)技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序(通常从小到大)，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找，不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="http://www.guiyongdong.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找算法之顺序表查找</title>
    <link href="http://www.guiyongdong.com/2016/11/10/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>http://www.guiyongdong.com/2016/11/10/查找算法之顺序表查找法/</id>
    <published>2016-11-10T07:45:23.000Z</published>
    <updated>2016-11-15T03:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h3><p><strong>顺序查找法（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或者最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，查找成功，找到查找的记录；如果知道最后一个（或第一个）记录，其关键字和给定值比较都不相等时，则表中没有所查的记录，查找不成功。</strong></p>
<p>顺序查找的算法实现如下：</p>
<pre><code>- (NSInteger)sequential_search:(NSArray *)targetArray key:(id)key {
    NSInteger n = targetArray.count;
    for (int i = 0; i &lt; n; i++) {
        if (targetArray[i] == key) {
            return i;
        }
    }
    return -1;
}
</code></pre><p>这段代码非常简单，就是在数组targetArray中查看有没有关键字（key），当你需要查找复杂表结构的记录时，只需要把数组targetArray和关键字key定义成你需要的表结构和数据类型即可。</p>
<p>对于这种顺序查找算法来说，查找成功最好的情况就是在第一个位置就找到了，算法的时间复杂度为O(1)，最坏的情况是在最后一个位置才找到，需要比较n次，时间复杂度为O(n)，由于关键字在任何一位置的概率相同，所以平均查找次数为(n+1)/2，所以最终时间复杂度还是O(n)。</p>
<p>很显然，顺序查找技术是由很大缺点的，n很大时，查找效率极为地下，不过优点也是有的，这个算法非常简单，对静态查找表的记录没有任何的要求，在一些小型数据的查找时，是可以使用的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;顺序查找法&quot;&gt;&lt;a href=&quot;#顺序查找法&quot; class=&quot;headerlink&quot; title=&quot;顺序查找法&quot;&gt;&lt;/a&gt;顺序查找法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;顺序查找法（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="http://www.guiyongdong.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>iOS触摸事件处理详解</title>
    <link href="http://www.guiyongdong.com/2016/11/09/iOS%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.guiyongdong.com/2016/11/09/iOS触摸事件处理详解/</id>
    <published>2016-11-09T06:39:39.000Z</published>
    <updated>2017-03-09T07:02:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你设计一个app的时候，可能会有这样的场景，你想动态的去响应一个事件。例如，在屏幕上的一个触摸事件可能在不同的对象中都发生，并且你不得不决定由哪一个对象来响应这个事件并且尝试去理解怎么样的一个对象接收了到这个事件。</p>
<p>当一个常见的用户事件发生的时候，UIKit会创建一个事件对象Event Object,该对象包含了事件处理所必须得一些信息。然后它会将事件对象置于激活的app事件队列。例如触摸事件，该触摸时事件对象是一系列触摸信息包装集。例如手势事件，该事件是一个动态的变量它取决于你使用了什么框架以及你感兴趣的手势事件类型。</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>iOS 事件分为三大类</p>
<ul>
<li>触摸事件</li>
<li>加速器事件</li>
<li>远程控制事件</li>
</ul>
<p>这篇博客主要讲解触摸事件<br>触摸事件是我们平时遇到最多的事件，例如单击、长按、滑动等等。当用户点击按钮，到按钮处理回调。整个过程是如何发生，需要什么样的原则，这些都是问题。为了使系统能更加鲜明符合用户的操作逻辑，iOS系统将事件相应过程拆分成两部分：</p>
<ol>
<li>寻找响应链；</li>
<li>事件响应，先将事件通过某种规则来分发，找到处理事件的控件，其次是将事件传递分发，响应。</li>
</ol>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><p><strong>UIEvent</strong><br>iOS将触摸事件定义为第一个手指开始触摸屏幕到最后一个手指离开屏幕定义为一个触摸事件。用类UIEvent表示。</p>
<p><strong>UITouch</strong><br>一个手指第一次点击屏，会形成一个UITouch对象，直到离开销毁。表示触碰。UITouch对象能表明了当前手指触碰的屏幕位置，状态。状态分为开始触碰、移动、离开。</p>
<p>根据定义，UIEvent实际包括了多个UITouch对象。有几个手指触碰，就会有几个UITouch对象。<br>定义代码如下:</p>
<pre><code>@interface UIEvent : NSObject
@property(nonatomic,readonly) UIEventType     type NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly) UIEventSubtype  subtype NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly) NSTimeInterval  timestamp;
#if UIKIT_DEFINE_AS_PROPERTIES
//UITouch SET
@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;
//省略部分代码
@end
</code></pre><p>UIEventType表明了事件类型，UIEvent表示了三大事件。allTouches是该事件的所有UITouch对象的集合。</p>
<pre><code>//UITouch
@interface UITouch : NSObject
@property(nonatomic,readonly) NSTimeInterval      timestamp;
@property(nonatomic,readonly) UITouchPhase        phase;
@property(nonatomic,readonly) NSUInteger          tapCount;   // touch down within a certain point within a certain amount of time
@property(nonatomic,readonly) UITouchType         type NS_AVAILABLE_IOS(9_0);

@property(ullable,nonatomic,readonly,strong) UIWindow                        *window;
@property(nullable,nonatomic,readonly,strong) UIView                          *view;
@property(nullable,nonatomic,readonly,copy)   NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers 
NS_AVAILABLE_IOS(3_2);
//省略部分代码
@end
//Touch 状态枚举
typedef NS_ENUM(NSInteger, UITouchPhase) {
    UITouchPhaseBegan,             // whenever a finger touches the surface.
    UITouchPhaseMoved,             // whenever a finger moves on the surface.
    UITouchPhaseStationary,        // whenever a finger is touching the surface but hasn&apos;t moved since the previous event.
    UITouchPhaseEnded,             // whenever a finger leaves the surface.
    UITouchPhaseCancelled,         // whenever a touch doesn&apos;t end but we need to stop tracking (e.g. putting device to face)
};
</code></pre><p>UITouch中phase表明了手指移动的状态，包括1.开始点击；2.移动；3.保持; 4.离开；5.被取消（手指没有离开屏幕，但是系统不再跟踪它了）</p>
<p>综上，UIEvent就是一组UITouch。每当该组中任何一个UITouch对象的phase发生变化，系统都会产生一条TouchMessage。也就是说每次用户手指的移动和变化，UITouch都会形成状态改变，系统变回会形成Touch message进行传递和派发。那么 一次触摸事件是由一组UITouch对象状态变化引起的一组Touch message的转发和派送。那么事件派发的原则是什么？</p>
<h3 id="响应者"><a href="#响应者" class="headerlink" title="响应者"></a>响应者</h3><p>我们先来了解一下什么是响应者。<br>只要继承了UIResponder的对象就可以作为事件的响应者，下面看一下 UIResponder及其子类的继承关系：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Responder/Responder1.png?raw=true"><br></div>

<p>平常开发中所使用到的控件例如：UIButton,UiView,UIViController,APPDelegate，UIApplication等都能响应事件。与用户交互的控件就是第一响应者，它将作为响应者链的开始，事件首先发送给第一响应者，然后再依次传递下去，直到该事件被某个响应者处理。</p>
<h3 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h3><p>响应链是“事件派发”的原则和规定，那么响应链是什么？顾名思义事件链是一个链条，详细的定义如下:</p>
<ul>
<li>每条链是一个 链表状结构，整个是一棵树</li>
<li>链表的每一个node是一个 UIResponser对象</li>
</ul>
<p>UIResponser,响应链中的响应者，用来接收和处理事件的类，先抛开iOS中的具体传递细节，系统发送UIEvent的Touch message给UIResponser类。UIResponser提供了一下几个函数来做事件处理</p>
<pre><code>//触摸事件
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);

//物理按钮，遥控器上面的按钮在按压状态等状态下的回调
- (void)pressesBegan:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesChanged:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesEnded:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesCancelled:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);

//设备的陀螺仪和加速传感器使用
- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
</code></pre><p>UIResponser包括了各种Touch message 的处理，比如开始，移动，停止等等。</p>
<p>回到响应链，响应链是由UIResponser组成的，那么是按照哪种规则形成的。</p>
<ol>
<li>程序启动<ul>
<li>UIApplication会生成一个单例，并会关联一个APPDelegate。APPDelegate作为整个响应链的根建立起来，而UIApplication会将自己与这个单例链接，即UIApplication的nextResponser(下一个事件处理者)为APPDelegate。</li>
</ul>
</li>
<li>创建UIWindow<ul>
<li>程序启动后，任何的UIWindow被创建时，UIWindow内部都会把nextResponser设置为UIApplication单例。</li>
<li>UIWindow初始化rootViewController, rootViewController的nextResponser会设置为UIWindow</li>
</ul>
</li>
<li>UIViewController初始化<ul>
<li>loadView, VC的view的nextResponser会被设置为VC。</li>
</ul>
</li>
<li>addSubView<ul>
<li>addSubView操作过程中，如果子subView不是VC的View,那么subView的nextResponser会被设置为superView。如果是VC的View,那就是 subView -&gt; subView.VC -&gt;superView</li>
<li>如果在中途，subView.VC被释放，就会变成subView.nextResponser = superView</li>
</ul>
</li>
</ol>
<p>最终形成类似这样一张图</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Responder/Responser2.png?raw=true"><br></div>

<p>其中应该是由箭头的，箭头的方向是朝上，也就是subView指向superView.</p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>有了响应网为基础，事件的传递就比较简单，只需要选择其中一条响应链，但是选择那一条响应链来传递呢？为了弄清真个过程，我们先来查看一下从触摸硬件事件转化为UIEvent消息。</p>
<ol>
<li>首先用户触摸屏幕，系统的硬件进程会获取到这个点击事件，将事件简单处理封装后存到系统中，由于硬件检测进程和当前运行的APP是两个进程，所以进程两者之间传递事件用的是端口通信。硬件检测进程会将事件放入到APP检测的那个端口。</li>
<li>其次，APP启动主线程RunLoop会注册一个端口事件，来检测触摸事件的发生。当时事件到达，系统会唤起当前APP主线程的Runloop。唤起原因就是端口触摸事件，主线程会分析这个事件。</li>
<li>最后，系统判断该次触摸是否导致了一个新的事件, 也就是说是否是第一个手指开始触碰，如果是，系统会先从响应网中 寻找响应链。如果不是，说明该事件是当前正在进行中的事件产生的一个Touch message， 也就是说已经有保存好的响应链。</li>
</ol>
<p>如果是新事件，系统会寻找响应链，为了符合用户的操作习惯，系统会根据用户的点击位置，在当前的整个APP的显示层级中寻找。过程如下：</p>
<ol>
<li>将所有的显示在屏幕上的 “合格的”UIWindow对象 按照层级结构从上到下排列成一个数组。</li>
<li>从第一个UIWindow对象开始，先判断UIWindow是否合格，其次判断 点击位置在不在这个Window内，如果不在 ，返回nil, 就换下一个UIWindow;如果在的话，并且UIWindow没有subView就返回自己，整个过程结束。如果UIWindow有subViews,就从后往前遍历整个subViews,做和UIWindow类似的事情，直到找到一个View。如果没有找到到就不做传递。</li>
<li><strong>合格的UIWindow，UIView。意思是控件被允许接受事件。符合三个条件：1.不能被隐藏；2.alpha值大于0.01(不是backgroundColor为clearColor)；3.isUserInteractionEnabled为YES，打开状态。一般UILabel,UIImageView纯显示的控件默认是关闭状态，也就是不处理事件。</strong></li>
</ol>
<p>显示控件有了两个方法来做上面这件事，就是常说的hitTest</p>
<pre><code> // 先判断点是否在View内部，然后遍历subViews
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  
//判断点是否在这个View内部
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   // default returns YES if point is in bounds
</code></pre><p>整个过程的系统实现大致如下</p>
<pre><code>- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event {
  //判断是否合格
    if (!self.hidden &amp;&amp; self.alpha &gt; 0.01 &amp;&amp; self.isUserInteractionEnabled) {
        //判断点击位置是否在自己区域内部
        if ([self pointInside: point withEvent:event]) {
            UIView *attachedView;
            for (int i = self.subviews.count - 1; i &gt;= 0; i--) {
                UIView *view  = self.subviews[i];
                //对子view进行hitTest
                attachedView =  [view hitTest:point withEvent:event];
                if (attachedView)
                    break;
            }
            if (attachedView)  {
                return attachedView;
            } else {
                return self;
            }
        }
    }
    return nil;
}
</code></pre><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>以上可知默认情况下，用户点击哪个View,系统就会在寻找过程中返回哪个view，但是我们可以重载上面两个方法做如下事情：</p>
<ul>
<li>将控件外部点规整到控件内部。 例如控件较小，点击位置在控件边缘外部，可以重载- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 将外部的点也判断为内部点，这样hitTest就会遍历自己。</li>
<li>重载HitTest更改默认行为。 有时候点击subView的某些特殊位置需要superView处理，我们可以在superView的hitTest，返回superView。这样superView变成首部响应者</li>
</ul>
<blockquote>
<p>hitTest的逻辑代码中会把隐藏，透明（alpha&lt;0.01,不是backgroundColor为clearColor），不交互的view滤过，但不代表hitTest不会被调用，我们可以重载hitTest去让 已经隐藏、透明、不交互的view响应事件。不过最正规的方法是打开控件交互属性。</p>
</blockquote>
<p>以上过程返回的View被称作hitTestView，顺着hitTestView的nextResponser,可以形成一个链，即响应链。 最后指向appDelegate. 并且返回hitTestView之后，系统会持有hitTestView。事件不结束，这个hitTestView不会发生变化，即使用户点击之后将手指移动到其他控件上面，该点击都会绑定开始的hitTestView。当所有手指离开屏幕，事件结束。再次点击，事件重新开始。以上过程再来一次。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>形成响应链之后，UIWindow会把事件目标锁定为hitTestView(响应链头的控件)，当手指状态发生变化， 会不停的发送UITouch Message 给这个hitTestView。 下面这几个方法会被调用。<br>然后控件的以下方法会陆续被调用</p>
<pre><code>//点击刚开始，回调这个方法
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
//点击之后移动，回调这个方法
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
//手指移开，点击结束
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
//点击过程中，事件被手势识别，会回调这个方法，关于手势后面会讲解
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);
</code></pre><h4 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h4><p>由于系统只会把事件发送给 hitTestView，如果你想让hitTestView之后的其他响应者处理该Touch Mesage ，需要自己实现以上几个方法做派发，例如</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event
{
    //do someThiing
  [self.nextResponser touchesBegan: touches withEvent:event];
}
</code></pre><p>事件转发可以做很多事情。大家可以尽可能的想象</p>
<h3 id="手势处理"><a href="#手势处理" class="headerlink" title="手势处理"></a>手势处理</h3><p>以上看来所有的事情都很平稳，无非就是寻找响应链，传递事件等等。但是接下来大家可能需要蒙圈。先来道题目</p>
<ul>
<li>AView 有子view BView，AView上面有一个<strong>单击手势</strong>，这个时候点击BView。默认情况下，Bview的四个Touch方法中，那些方法会被调用？</li>
</ul>
<p>可能很多人会说没有任何影响，基本都会调用，答案是整个过程会调用这两个方法。</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
</code></pre><p>touchEnd不会被调用。<br>为什么？因为有手势的存在，我们先看一下手势。</p>
<h4 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h4><p>手势是苹果为处理常用的用户交互所推出了一个优先级更高的处理技术。为了让用户完成对多种控件的基本操作，苹果实现了以下几个手势</p>
<blockquote>
<p><strong>UITapGestureRecognizer</strong><br><strong>UIPinchGestureRecognizer</strong><br><strong>UIRotationGestureRecognizer</strong><br><strong>UISwipeGestureRecognizer</strong><br><strong>UIPanGestureRecognizer</strong><br><strong>UIScreenEdgePanGestureRecognizer</strong><br><strong>UILongPressGestureRecognizer</strong></p>
</blockquote>
<p>上面包括点击，长按，旋转，滑动等等手势。这样开发者就可以随便将其关联到某个控件上完成交互。<br>先抛开刚才的问题，先看单纯的手势如何识别用户操作。</p>
<p>系统会将用户触摸屏幕的点事件 发送给手势，手势会根据具体的点击位置和序列，判断是否是某种特定行为。具体的判断方法如下</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
</code></pre><p>和UIResponser一样，手势也有这几个方法，点击的每个阶段手势都会响应不同的方法，手势会在以上四个方法中去对手势的State做更改，手势的State表明当前手势是识别还是失败等等。比如单击手势会在touchesBegan 时记录点击位置，然后在touchesEnded判断点击次数、时间、是否移动过，最后得出是否识别该手势。这几个方法一般在自定义手势里面使用。</p>
<h4 id="手势状态"><a href="#手势状态" class="headerlink" title="手势状态"></a>手势状态</h4><pre><code>typedef NS_ENUM(NSInteger, UIGestureRecognizerState) {
    //未知状态
    UIGestureRecognizerStatePossible,   // the recognizer has not yet recognized its gesture, but may be evaluating touch events. this is the default state
    //首次识别状态，对于连续手势，例如长按，有这种状态
    UIGestureRecognizerStateBegan,      // the recognizer has received touches recognized as the gesture. the action method will be called at the next turn of the run loop
    //再次识别，当手连续手势识别之后，再次受到touch事件
    UIGestureRecognizerStateChanged,    // the recognizer has received touches recognized as a change to the gesture. the action method will be called at the next turn of the run loop
    //识别完成，受到touchend 消息之后
    UIGestureRecognizerStateEnded,      // the recognizer has received touches recognized as the end of the gesture. the action method will be called at the next turn of the run loop and the recognizer will be reset to UIGestureRecognizerStatePossible
    //取消识别
    UIGestureRecognizerStateCancelled,  // the recognizer has received touches resulting in the cancellation of the gesture. the action method will be called at the next turn of the run loop. the recognizer will be reset to UIGestureRecognizerStatePossible
    //识别失败
    UIGestureRecognizerStateFailed,     // the recognizer has received a touch sequence that can not be recognized as the gesture. the action method will not be called and the recognizer will be reset to UIGestureRecognizerStatePossible
    // Discrete Gestures – gesture recognizers that recognize a discrete event but do not report changes (for example, a tap) do not transition through the Began and Changed states and can not fail or be cancelled
    //识别状态，与识别结束一个意思
    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded // the recognizer has received touches recognized as the gesture. the action method will be called at the next turn of the run loop and the recognizer will be reset to UIGestureRecognizerStatePossible
};
</code></pre><p>手势的状态有以上几种,我们来看手势的整个迁移过程，先明确几个信息</p>
<ol>
<li>手势的状态迁移只有在它们收到Touch message的时候，才能做状态变化处理代码。</li>
<li>手势分为连续状态手势和不连续状态手势。连续手势有长按，慢滑等。不连续手势有单击，双击等等。</li>
<li>当用户没有点击屏幕，所有手势都处于Possiable状态。</li>
</ol>
<p>当用户点击屏幕，手势会收到Touch Began Message， 手势的touchBegan方法会被调用。手势开始记录点击位置和时间。仍处于Possiable状态。如果用户按住不放，间隔超过一定时间，单击手势会变化为失败状态，并在下个一runloop变为possiable。如果时间大于长按手势设定时间，长按手势就会变化为Began状态，当用户移动手指，长按手势的touch move方法被调用，长按手势将自己状态设置为Change，并且也会回调处理方法。最后手指离开，系统调用长按手势touchEnd方法，手势状态回归为Recognized状态。</p>
<h4 id="手势混合处理"><a href="#手势混合处理" class="headerlink" title="手势混合处理"></a>手势混合处理</h4><p>如果一个View上既有单击，又有双击，用户点击该view两次， 默认情况下，单击被处理，双击不管用。因为默认情况下，一旦事件被某个手势处理，第二个手势会识别失败 幸运的是苹果提供了方法让我们修改这种默认行为，具体的方法如下</p>
<pre><code>@protocol UIGestureRecognizerDelegate &lt;NSObject&gt;
@optional
// called when a gesture recognizer attempts to transition out of UIGestureRecognizerStatePossible. returning NO causes it to transition to UIGestureRecognizerStateFailed
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;

// called when the recognition of one of gestureRecognizer or otherGestureRecognizer would be blocked by the other
// return YES to allow both to recognize simultaneously. the default implementation returns NO (by default no two gestures can be recognized simultaneously)
//
// note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture&apos;s delegate may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;

// called once per attempt to recognize, so failure requirements can be determined lazily and may be set up between recognizers across view hierarchies
// return YES to set up a dynamic failure requirement between gestureRecognizer and otherGestureRecognizer
//
// note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture&apos;s counterpart delegate or subclass methods may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);

// called before touchesBegan:withEvent: is called on the gesture recognizer for a new touch. return NO to prevent the gesture recognizer from seeing this touch
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;

// called before pressesBegan:withEvent: is called on the gesture recognizer for a new press. return NO to prevent the gesture recognizer from seeing this press
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceivePress:(UIPress *)press;

@end
</code></pre><p>上面是手势的代理方法，你可以实现手势的这几个代理方法，更改默认行为。</p>
<ul>
<li>(BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;<br>手势已经应分析出该事件可以响应，再对自己的状态进行更改之前，会询问代理的这个方法是否允许更改。默认为YES，如果你实现并设置为NO,那么手势会变为失败状态，这个可以用在手势只识别View的某几个区域的相应。</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer;<br>当两个手势都对该事件进行识别，但只有一个能响应，另外一个会失败。比如一个View上绑定两个单击事件。为了让两个手势都响应，我们可以实现此方法，让两个手势都响应。</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer NS_AVAILABLE_IOS(7_0);</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer NS_AVAILABLE_IOS(7_0);<br>这两个方法是iOS 7引入的，目的是让两个手势之间增加依赖，比如单击和双击，如果需要单击在双击失败的情况下识别，那么可以实现这两个方法。</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldReceiveTouch:(UITouch )touch;</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldReceivePress:(UIPress )press;<br>这两个方法是判断手势在新的Touch和Press Began阶段是否关注该UITouch和UIPress对象，默认为YES，如果设置为NO,手势不会关注该Touch的任何状态变化。</li>
</ul>
<h4 id="手势与事件响应"><a href="#手势与事件响应" class="headerlink" title="手势与事件响应"></a>手势与事件响应</h4><p>回到我们上面问过的问题，BView只有touchBegan， touchesCancelle 的原因是什么？答案在于整个触摸事件全过程</p>
<ol>
<li>系统会通过hitTest的方法寻找响应链，完成之后会形成下图模型。</li>
</ol>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Responder/Responser3.png?raw=true"><br></div>

<blockquote>
<p>图中最右边是响应链，中间是关联在相应链在视图上的手势</p>
</blockquote>
<ol>
<li>有了模型之后就会发生图上的三个步骤</li>
</ol>
<p>第一步：系统会将所有的 Touch message 优先发送给 关联在响应链上的全部手势。手势根据Touch序列消息和手势基本规则更改自己的状态（有的可能失败，有的可能识别等等）。如果没有一个手势对Touch message 进行拦截（拦截:系统不会将Touch message 发送给响应链顶部响应者)，系统会进入第二步</p>
<p>第二步：系统将Touch message 发送给响应链 顶部的 视图控件，顶部视图控件这个时候就会调用Touch相关的四个方法中的某一个。之后进入自定义Touch message转发</p>
<p>第三步：自定义Touch message转发可以继承UIResponser的四个Touch函数做转发。</p>
<p>解释一下第一步中说的拦截，手势会表明是否拦截该Touch Message,主要由下面三个属性控制。</p>
<p>再回到那道题目，如果我们想hitTestView的toucheEnd函数依然能得到调用，怎么办？其实UIGestureRecognizer有三个属性</p>
<pre><code>@property(nonatomic) BOOL cancelsTouchesInView;       // default is YES. causes touchesCancelled:withEvent: or pressesCancelled:withEvent: to be sent to the view for all touches or presses recognized as part of this gesture immediately before the action method is called.
@property(nonatomic) BOOL delaysTouchesBegan;         // default is NO.  causes all touch or press events to be delivered to the target view only after this gesture has failed recognition. set to YES to prevent views from processing any touches or presses that may be recognized as part of this gesture
@property(nonatomic) BOOL delaysTouchesEnded;         // default is YES. causes touchesEnded or pressesEnded events to be delivered to the target view only after this gesture has failed recognition. this ensures that a touch or press that is part of the gesture can be cancelled if the gesture is recognized
</code></pre><ul>
<li>cancelsTouchesInView<br>  默认为YES,表明当手势识别了该事件，系统会将Touch cancel消息发送给hitTestView ，并调用hitTestView的TouchCancel。设置为NO，不会再收到TouchCancel</li>
<li>delaysTouchesBegan<br>  默认为NO, 表明无论什么情况下，不会拦截Touch began消息。如果设置为YES，只要有一个手势不识别失败，都不会发送Touch began到响应链的第一响应者。</li>
<li>delaysTouchesEnded<br>  默认为NO, 和delaysTouchesBegan类似，不过它是用来控制TouchEnd message的拦截</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>iOS整个事件处理的过程就是这样，系统为完成整个交互做了很多东西，核心点如下：</p>
<ul>
<li>事件分发过程分为：1.寻找响应链；2.事件消息分发</li>
<li>响应网是事件响应的基础，响应链是事件响应的具体路径。</li>
<li>事件消息分发优先发送给手势集合，手势内部会做冲突处理，过滤消息。不被过滤的消息会传递给响应链对象。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你设计一个app的时候，可能会有这样的场景，你想动态的去响应一个事件。例如，在屏幕上的一个触摸事件可能在不同的对象中都发生，并且你不得不决定由哪一个对象来响应这个事件并且尝试去理解怎么样的一个对象接收了到这个事件。&lt;/p&gt;
&lt;p&gt;当一个常见的用户事件发生的时候，UIKit会创建一个事件对象Event Object,该对象包含了事件处理所必须得一些信息。然后它会将事件对象置于激活的app事件队列。例如触摸事件，该触摸时事件对象是一系列触摸信息包装集。例如手势事件，该事件是一个动态的变量它取决于你使用了什么框架以及你感兴趣的手势事件类型。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="响应者链" scheme="http://www.guiyongdong.com/tags/%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/"/>
    
  </entry>
  
</feed>
