<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>贵大头的博客</title>
  <subtitle>贵大头的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.guiyongdong.com/"/>
  <updated>2017-03-18T07:37:00.000Z</updated>
  <id>http://www.guiyongdong.com/</id>
  
  <author>
    <name>贵永冬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一天一Android之Activity</title>
    <link href="http://www.guiyongdong.com/2017/03/17/%E4%B8%80%E5%A4%A9%E4%B8%80Android%E4%B9%8BActivity/"/>
    <id>http://www.guiyongdong.com/2017/03/17/一天一Android之Activity/</id>
    <published>2017-03-17T09:30:01.000Z</published>
    <updated>2017-03-18T07:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来说一说Android四大组件之一的<code>Activity</code>，类似于iOS的<code>UIViewController</code>。当我们新建一个Android项目时，Android Studio默认会为我们创建一个主活动:<code>MainActivity</code>和一个默认的主布局:<code>activity_main.xml</code>。一个活动想要显示在屏幕上，就必须在<code>AndroidManifest.xml</code>中注册。但是这些工作都有IDE帮我们自动完成了。我们来看<code>AndroidManifest.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">          <span class="attr">package</span>=<span class="string">"com.guiyongdong.activitydemo"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">application</span></span></div><div class="line">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></div><div class="line">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></div><div class="line">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></div><div class="line">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</div><div class="line">        </div><div class="line">        <span class="comment">&lt;!--MainActivity--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Activity声明"><a href="#Activity声明" class="headerlink" title="Activity声明"></a>Activity声明</h3><p>我们首先声明了程序的包名<code>package=&quot;com.guiyongdong.listviewdemo&quot;</code>。</p>
<h5 id="lt-application-gt"><a href="#lt-application-gt" class="headerlink" title="&lt;application&gt;"></a><code>&lt;application&gt;</code></h5><p>接下来我们又声明了<code>&lt;application&gt;</code>标签，这个标签标示当前程序的配置，例如我们配置了icon（程序的图标）、label（程序的名称）等。</p>
<h5 id="lt-activity-gt"><a href="#lt-activity-gt" class="headerlink" title="&lt;activity&gt;"></a><code>&lt;activity&gt;</code></h5><p>然后我们又在<code>&lt;application&gt;</code>标签内添加了一个<code>&lt;activity&gt;</code>标签，这个标签就是声明一个活动（Avtivity）。记住，所有的活动都必须声明在<code>&lt;application&gt;</code>标签内。<code>name</code>属性表示声明的是哪个Activity，因为我们之前已经声明过了当前的包名， 所有以后声明的Activity只要在这个包中，我们只需要声明<code>.MainActivity</code>就可以了。其实它的全称还是<code>com.guiyongdong.listviewdemo. MainActivity</code>。 我们又看到在<code>&lt;activity&gt;</code>标签内，我们有声明了一个标签<code>&lt;intent-filter&gt;</code>，来看看它们是什么。</p>
<h5 id="lt-intent-filter-gt"><a href="#lt-intent-filter-gt" class="headerlink" title="&lt;intent-filter&gt;"></a><code>&lt;intent-filter&gt;</code></h5><p><code>&lt;intent-filter&gt;</code>这个标签表示intent过滤器，至于intent是什么，我们待会再说。先来看看它声明了什么类型的过滤器。<br>在<code>&lt;intent-filter&gt;</code>标签内，我们可以声明三种标签，分别是:<code>&lt;action&gt;</code>、<code>&lt;category&gt;</code>和<code>&lt;data&gt;</code>，这三个标签都是可以作为活动的过滤器。这里我们声明了一个<code>&lt;action&gt;</code>：<code>android.intent.action.MAIN</code>和一个<code>&lt;category&gt;</code>：<code>android.intent.category.LAUNCHER</code>，这两个值都是Android SDK提供给我们的，它表示当前活动为主活动，另一个表示当前活动为启动活动，注意着两种类型的过滤器必须放在一起，不让运行不起来~。当然，我们也可以自定义其他过滤器的值，这个在我们说到隐式Intent时会自定义。</p>
<h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent一般可被用于启动活动，启动服务以及发送广播等场景，当前我们主要讲解Activity,所以我们主要看Intent在活动中的应用。</p>
<p>Intent大致可以分为两种：<strong>显式Intent</strong>和<strong>隐式Intent</strong>。</p>
<p>上面我们说到了，如果一个Activity想要作为程序启动时的主Activity，必须声明声明<code>&lt;intent-filter&gt;</code>标签，而且必须在此标签下声明两个值为固定值的<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>。一般情况下我们的程序不可能只有一个活动，如果我们想要再开启一个活动时，该怎么办呢？</p>
<h5 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h5><p>开启另一个Activity的最简单的方式就是使用显式Intent，我本人没有开发过Android，也不知道这种方式在项目中的使用率，但我感觉它的使用率应该不低，因为它太简单了。</p>
<p>例如我又新建了一个Avtivity(SecondActivity)，系统默认为我们在<code>AndroidManifest.xml</code>中注册，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">          <span class="attr">package</span>=<span class="string">"com.guiyongdong.activitydemo"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">application</span></span></div><div class="line">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></div><div class="line">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></div><div class="line">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></div><div class="line">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></div><div class="line">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</div><div class="line">        </div><div class="line">        <span class="comment">&lt;!--MainActivity--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line">        </div><div class="line">        <span class="comment">&lt;!--SecondActivity--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当然，这时候我可以在<code>SecondActivity</code>的标签下声明任何的filter标签，不过现在我不需要声明，因为我现在使用的是显式Intent。我们在<code>MainActivity</code>的布局文件中添加一个按钮，并且添加按钮的点击事件，事件是去打开<code>SecondActivity</code>活动，至于如何布局，以后再说。 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        Button button = (Button) findViewById(R.id.button);</div><div class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            		<span class="comment">//显式启动SecondActivity</span></div><div class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class);</div><div class="line">                startActivity(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于为何这么写，刚开始我也不明白，好在我有一点java基础，这里奉劝想学习Android的同学，必须打好java基础。</p>
<p>大家可以看到，我在Intent的构造函数中传了两个值，一个是<code>MainActivity.this</code>，一个是<code>SecondActivity.class</code>，它的构造函数为:<code>Intent(Context context, Class&lt;?&gt; cls)</code>，第一个参数是表示启动活动的上下文，第二个参数Class表示指定想要启动的目标活动，通过这个构造函数，我们就能构建出Intent的<code>意图</code>（就是我要去干什么）。然后我们调用<code>startActivity</code>方法，把这个明显的意图传递过去就行了。</p>
<h5 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h5><p>相比于显式Intent，隐式Intent则含蓄很多了，它并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的<code>action</code>和<code>category</code>等信息，让系统去分析这个Intent，并找出合适的活动去启动。</p>
<p>什么叫合适的活动？我们来想一个问题，系统为什么会启动<code>MainActivity</code>作为程序的主界面，是因为我们声明了如下代码:<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在<code>&lt;action&gt;</code>标签中我们指明了当前活动可以响应<code>android.intent.action.MAIN</code>这个action,而<code>&lt;category&gt;</code>标签则包含了一些附加信息，指明当前活动可以响应<code>android.intent.category.LAUNCHER</code>这个category，只有这两个配置同时匹配，这个活动才是合适的活动。</p>
<p>例如我们为<code>SecondActivity</code>添加如下filter：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.guiyongdong.activitydemo.second"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后我修改MainActivity中按钮的点击方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">    		<span class="comment">//隐式启动Intent</span></div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.guiyongdong.activitydemo.second"</span>);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们看到，我直接将action的字符串传了过去，表明想要启动能响应<code>com.guiyongdong.activitydemo.second</code>这个action的活动，我们之前说过，只有action和category同时匹配才能响应，但是这里我们并没有指定category，那是因为<code>android.intent.category.DEFAULT</code>是一种默认的category，在我们调用<code>startActivity</code>方法的时候，会自动的添加这个默认的category到Intent中。</p>
<p>当然，现在我们也可以添加任意自定义的category：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.guiyongdong.activitydemo.second"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.guiyongdong.category.my_second"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在MainActivity中添加如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.guiyongdong.activitydemo.second"</span>);</div><div class="line">        intent.addCategory(<span class="string">"com.guiyongdong.category.my_second"</span>);</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们依然能够启动<code>SecondActivity</code>。</p>
<p>当然，我们前面也说到了<code>&lt;data&gt;</code>这个标签，它用于更精确地指定当前活动能响应什么类型的数据，<code>&lt;data&gt;</code>标签中主要可以匹配一下内容：</p>
<ul>
<li>android:scheme 用于指定数据协议部分，如http</li>
<li>android:host 用于指定数据的主机名部分，如www.baidu.com</li>
<li>android:port 用于指定数据的端口部分</li>
<li>android:path 用于指定主机名和端口之后的部分</li>
<li>android:mimeType 用于指定可以处理的数据类型</li>
</ul>
<p>至于详细的该怎么用，大家可以去试试。这里列一下打电话的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CALL);</div><div class="line">        intent.setData(Uri.parse(<span class="string">"tel:10086"</span>));</div><div class="line">        startActivity(intent);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然，前提是我们在<code>AndroidManifest.xml</code>添加打电话的权限<br><code>&lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt;</code></p>
<h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><p>当我们启动一个新的Activity的时候，它覆盖在了原来的Activity上，我们想一想，Android是通过上面来管理这些Activity的呢？</p>
<p>这里要说明一种数据结构：栈，栈是一种先进后出的数据结构。我们发现，当我们点击返回键时，最先消失的活动是我们最新添加显示的活动。</p>
<p>Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称为返回栈(Back Stack)。</p>
<h5 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h5><ul>
<li><p>运行状态<br>  当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动。</p>
</li>
<li><p>暂停状态<br>  当一个活动不再处于栈顶位置，但仍是可见的，这时活动就进入了暂停状态，因为有时候开启一个新的活动，这个活动并不是占满整个屏幕的。处于暂停状态的活动仍然是完全活着的，系统也不愿意去回收这种活动，只有在内存极低的情况下，系统才会去考虑回收这种活动。</p>
</li>
<li><p>停止状态<br>  当一个活动不再处于栈顶位置，并且完全不可见时，活动就进入了暂停状态，系统仍然会为此活动保存相应的状态和成员变量，但是，这并不是完全可靠，当内存不足，处于停止状态的活动有可能被系统回收。</p>
</li>
<li><p>销毁状态<br>  当一个活动从返回栈中移除后就成了销毁状态。系统最倾向于回收处于这种状态的活动。</p>
</li>
</ul>
<h5 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h5><p>Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。</p>
<ul>
<li><p>onCreate()<br>  这个方法我们已经见过很多次了，每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。我们应该在这个方法中完成活动的初始化操作，比如加载布局，绑定事件等。</p>
</li>
<li><p>onStart()<br>  这个方法在活动由不可见变为可见的时候调用。</p>
</li>
<li><p>onResume()<br>  这个方法在活动准备好喝用户交互的时候调用。此时活动一定位于返回栈的栈顶，并且处于运行状态。</p>
</li>
<li><p>onPause()<br>  这个方法在系统准备去启动或者恢复另外一个活动的时候调用。通常会在这个方法中奖一些消耗CPU的资源释放掉，但是这个方法的执行速度一定要快，不然会影响到新的活动的使用。</p>
</li>
<li><p>onStop()<br>  这个方法在活动完全不可见的时候调用。它和onPause()方法的区别主要在于，如果启动的新活动是一个对话框式的活动，那么OnPause()方法会得到执行，而onStop()方法并不会执行。</p>
</li>
<li><p>onDestory()<br>  这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</p>
</li>
<li><p>onRestart()<br>  这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</p>
</li>
</ul>
<p>看完以上的7个方法（发现这些方法和iOS好相似啊），可以将活动分为3种生存期。</p>
<ul>
<li><p>完整生存期。活动在onCreate()方法和onDestroy()方法之间所经历的，就是完整生存期。一般情况下，都是在onCreate()中完成各种初始化，在onDestroy()中完成释放内存的操作。</p>
</li>
<li><p>可见生存期。活动在onStart()方法和onStop()方法之间所经历的，就是可见生存期。我们可以通过这两个方法，合理的管理那些对用户可见的资源。</p>
</li>
<li><p>前台生存期。活动在onResume()方法和onPause()方法之间所经历的就是前台生存期。</p>
</li>
</ul>
<p>如图，完整的描述了Activity的整个生命周期：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android5.jpg?raw=true"><br></div>

<h3 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h3><p>活动的启动模式一共有4种，分别是standard、singleTop、singleTask和singleInstance。可以在<code>AndroidManifest.xml</code>通过给<code>&lt;activity&gt;</code>标签指定<code>android:launchMode</code>属性来选择启动模式。</p>
<h5 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h5><p>standard是活动的默认启动模式，每当启动一个新的活动，它都会在返回栈中如栈，每次启动都会创建该活动的一个新的实例。</p>
<h5 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h5><p>加入我们在<code>SecondActivity</code>活动中再启动一个<code>SecondActivity</code>，这时候系统是不会再去创建一个新的<code>SecondActivity</code>活动的。singleTop模式下，当启动活动时如果发现返回栈的栈顶已经是该类型的活动，则认为可以直接使用它，不会再去创建新的活动实例。</p>
<h5 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h5><p>使用singleTask可以很好的解决重复创建栈顶活动的问题，每次启动该活动时系统首先会在返回栈中检查是否有存在该活动的实例，如果发现已经存在则直接使用该实例，并把这个活动之上的所有活动统统出栈，如果没有发现，就会创建一个新的活动实例。</p>
<h5 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h5><p>singleInstance不同于上面的三种模式，它表示活动会启用一个新的返回栈来管理这个活动，因为程序中可以存在多个返回栈。一般情况下，我们希望几个程序共享某个活动时会使用到此模式。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于Activity的知识还有很多，只有在开发中才能遇到各种问题，继续吧，骚年~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来说一说Android四大组件之一的&lt;code&gt;Activity&lt;/code&gt;，类似于iOS的&lt;code&gt;UIViewController&lt;/code&gt;。当我们新建一个Android项目时，Android Studio默认会为我们创建一个主活动:&lt;code&gt;MainActivity&lt;/code&gt;和一个默认的主布局:&lt;code&gt;activity_main.xml&lt;/code&gt;。一个活动想要显示在屏幕上，就必须在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;中注册。但是这些工作都有IDE帮我们自动完成了。我们来看&lt;code&gt;AndroidManifest.xml&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;manifest&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns:android&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;          &lt;span class=&quot;attr&quot;&gt;package&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;com.guiyongdong.activitydemo&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:allowBackup&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:icon&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@mipmap/ic_launcher&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:label&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@string/app_name&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:roundIcon&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@mipmap/ic_launcher_round&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:supportsRtl&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;android:theme&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;@style/AppTheme&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--MainActivity--&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;activity&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;.MainActivity&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;android.intent.action.MAIN&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;android.intent.category.LAUNCHER&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;intent-filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;activity&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;application&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;manifest&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.guiyongdong.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.guiyongdong.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>一天一Android之Android系统初窥</title>
    <link href="http://www.guiyongdong.com/2017/03/15/%E4%B8%80%E5%A4%A9%E4%B8%80Android%E4%B9%8BAndroid%E7%B3%BB%E7%BB%9F%E5%88%9D%E7%AA%A5/"/>
    <id>http://www.guiyongdong.com/2017/03/15/一天一Android之Android系统初窥/</id>
    <published>2017-03-15T09:08:17.000Z</published>
    <updated>2017-03-17T09:35:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于前段时间使用ReactNative开发过一个项目，在开发的过程中，会使用到大量的非ReactNative提供的组件和功能。这时候就必须写原生桥接，iOS还好说，毕竟是靠这个吃饭的，可是android就捉襟见肘了。为了向大前端的目标更进一步，我计划开始学习android，为期6个月，我的目标是6个月内起码自己公司的android项目可以上手，当然，如果想成为真正的android开发者，光靠这6个月是不行。还需要大量的实际项目才能锻炼。</p>
<p>值得庆幸的是我在大学主攻的就是java(哈哈，现在也基本上忘的差不多了)。为了打好基础，我买了两本书，一本是《java编程思想》，一本是京东上销量很好的《第二行代码Android》，希望这两本书能够帮到我。另外我也会专门开一个专栏，讲解我学习java的过程。可能在接下来的博客中，我总结的都是基础知识，大神莫嘲笑。</p>
<a id="more"></a>
<h3 id="Android系统架构"><a href="#Android系统架构" class="headerlink" title="Android系统架构"></a>Android系统架构</h3><p>Android大概可以分为四层架构：Linux内核层、系统运行库层、应用框架层和应用层。</p>
<p><strong>Linux内核层</strong></p>
<p>Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、Wi-Fi驱动、电源管理等。</p>
<p><strong>系统运行时库层</strong></p>
<p>这一层通过一些C/C++库来为Android系统提供了主要的特性支持。如SQLite库提供了数据库的支持，OpenGL|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。</p>
<p>同样在这一层还要Android运行时库，主要提供了一些核心库，能是开发者可以使用java来编写Android应用。另外，Android运行时库还包含了Dalvik虚拟机（5.0系统之后改为ART运行环境），它能让每一个Android应用都能运行在独立的进程中，并且拥有一个自己的Dalvik虚拟机实例。</p>
<p><strong>应用框架层</strong></p>
<p>这一层主要提供了构建应用程序时可能用到的各种API，Android自带的一些核心应用就是使用这些API完成的，我们也是通过这些API来完成我们的应用。</p>
<p><strong>应用层</strong></p>
<p>普通用户主要就是和这一层打交道，我们自己开发的应用都是属于这一层的，当然，系统自带的应用也是这一层的。</p>
<p>系统架构图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android1.jpg?raw=true"><br></div>


<h3 id="Android版本"><a href="#Android版本" class="headerlink" title="Android版本"></a>Android版本</h3><p>可能现在应用最低的适配都是从4.0版本开始，目前最高版本是7.1.1，而且谷歌对Android版本的命名都是以甜点命名的。什么牛轧糖、棒棒糖。</p>
<h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p>在我没接触Android之前，我的同学都是使用MyEclipse开发的，至于是如何开发的，我不知道，因为当我开始学Android的时候，已经普及了另一个开发工具：<strong>Android Studio</strong>。当然，只有IDE是不行的，还得有<strong>JDK</strong>、<strong>Android SDK</strong>。</p>
<p>如果使用Android Studio，你也可以使用studio自带的工具进行下载各个版本的SDK。如图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android2.png?raw=true"><br></div>

<p>当然，SDK的目录你可以随便选。</p>
<h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><p>至于该如何创建项目，我就不说了。创建完项目以后切换到Project模式下，就是项目的真实目录了。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android3.png?raw=true"><br></div>

<p>下面来看看这些目录或者文件都是干什么的：</p>
<p><strong>.gradle和.idea</strong> </p>
<p>这两个目录下放置的都是Android Studio自动生成的一些文件，我们无须关心，也不要去编辑。</p>
<p><strong>app</strong></p>
<p>这个目录才是我们以后经常使用和编辑的，一会再说它。</p>
<p><strong>build</strong></p>
<p>这个目录也不需要关心，它主要包含了一些在编译时自动生成的文件。</p>
<p><strong>gradle</strong></p>
<p>这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认没有启动gradle wrapper的方式，如果需要打开，可以点击 File-&gt;Other Settings-&gt;Build,Execution,Deployment-&gt;Build Tools-&gt;Gradle 进行配置。</p>
<p><strong>.gitignore</strong></p>
<p>设置git忽略哪些文件</p>
<p><strong>build.gradle</strong></p>
<p>这个文件时全局的gradle构建脚本，通常这个文件中的内容是不需要修改的，我只知道gradle是构建工具，至于gradle更多的信息，我还得再研究一下。</p>
<p><strong>gradle.properties</strong></p>
<p>这个文件时全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。</p>
<p><strong>gradlew和gradlew.bat</strong></p>
<p>这两个文件时用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用，gradlew.bat是在Windows系统中使用的。</p>
<p><strong>ListViewDemo.iml</strong></p>
<p>这个文件的名字和我们的项目名字是一样的，不固定。一般不用动。</p>
<p><strong>local.properties</strong></p>
<p>这个文件用于指定Android SDK路径，一般我们不动，除非你的SDK本地路径改变了。</p>
<p><strong>settings.gradle</strong></p>
<p>这个文件用于指定项目中所引入的模块，因为当前项目就一个模块：app，在以后可能我们还会引入其他模块，一般IDE帮我们自动导入。</p>
<h4 id="app"><a href="#app" class="headerlink" title="app"></a>app</h4><p>看了整个工程的目录，感觉有用的不是很多，好多都是和gradle或者配置有关。其实，真正需要我们关心的只有app这个目录。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/android/android4.png?raw=true"><br></div>

<p><strong>build</strong></p>
<p>这个目录和外层的build目录类似，主要也是包含了一些在编译时生成的文件，不过它里面的内容更复杂，也不需要管。</p>
<p><strong>libs</strong></p>
<p>如果项目中使用到了第三方的jar包，就需要把这些jar包都放在libs录下，放在这个目录下的jar包都会被自动添加到构建路径中去。</p>
<p><strong>androidTest</strong></p>
<p>这个一看就是用来编写测试用例的，一些小公司可能也不写测试代码的。</p>
<p><strong>java</strong></p>
<p>毫无疑问，java目录是放置我们所有java代码的地方，以后所有的代码都在里面。</p>
<p><strong>res</strong></p>
<p>这个目录下的内容比较多，简单所，就是放各种资源的，图片，布局，字符串等资源。图片放到drawable文件下，布局放置layout下，字符串放在values下。</p>
<p><strong>AndroidMainfest.xml</strong></p>
<p>这个文件很重要，是整个Android的配置文件，包括程序中使用到的所有四大组件都需要在这个文件注册，另外还有权限声明等。</p>
<p><strong>test</strong></p>
<p>它是用来编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。</p>
<p><strong>.gitignore</strong></p>
<p>忽略文件</p>
<p><strong>app.iml</strong></p>
<p>不需要关心</p>
<p><strong>build.gradle</strong></p>
<p>这个文件也很重要，是app模块的gradle构建脚本，里面会有好多的配置，以后研究到了再说。</p>
<p><strong>proguard-rules.pro</strong></p>
<p>代码混淆规则，主要混淆代码，放在人家破解你的项目。</p>
<p>好了， android项目的大概工程目录就是这样，其实我们会发现，重要的没几个，而且重要的好多都和gradle有关，看来真得好好研究下gradle是什么了。</p>
<h3 id="build-gradle文件"><a href="#build-gradle文件" class="headerlink" title="build.gradle文件"></a>build.gradle文件</h3><p>在整个项目中，一共有连个build.gradle文件。我们先来看看最外层的build.gradle文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.3.0'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些代码都是自动生成的，我们发现在两个闭包中都声明了<code>jcenter()</code>，它是一个代码托管仓库，很多android开源项目都会托管到jcenter上。只要声明它，就可以引用jcenter上的托管的项目。</p>
<p>在<code>dependencies</code>闭包中，还声明了<code>classpath</code>，这个主要是声明gradle插件的，因为gradle不仅仅为android工作，还为java等项目工作，所有我们要声明使用哪个包中的gradle工具。例如我们声明了<code>com.android.tools.build:gradle:2.3.0</code>，2.3.0是此插件的版本号。</p>
<p>再来看看app下的<code>build.gradle</code>文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">apply plugin: <span class="string">'com.android.application'</span></div><div class="line"></div><div class="line">android &#123;</div><div class="line">    compileSdkVersion <span class="number">25</span></div><div class="line">    buildToolsVersion <span class="string">"25.0.1"</span></div><div class="line">    defaultConfig &#123;</div><div class="line">        applicationId <span class="string">"com.guiyongdong.listviewdemo"</span></div><div class="line">        minSdkVersion <span class="number">15</span></div><div class="line">        targetSdkVersion <span class="number">25</span></div><div class="line">        versionCode <span class="number">1</span></div><div class="line">        versionName <span class="string">"1.0"</span></div><div class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></div><div class="line">    &#125;</div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            <span class="function">minifyEnabled <span class="keyword">false</span></span></div><div class="line">            proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></div><div class="line">    <span class="title">androidTestCompile</span><span class="params">(<span class="string">'com.android.support.test.espresso:espresso-core:2.2.2'</span>, &#123;</span></div><div class="line">        exclude group: <span class="string">'com.android.support'</span>, <span class="keyword">module</span>: <span class="string">'support-annotations'</span></div><div class="line">    &#125;)</div><div class="line">    compile 'com.android.support:appcompat-v7:25.0.1'</div><div class="line">    compile 'com.android.support.constraint:constraint-layout:1.0.0-beta4'</div><div class="line">    compile 'com.android.support:recyclerview-v7:25.0.1'</div><div class="line">    testCompile 'junit:junit:4.12'</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咋一看，这个文件好复杂啊，别急，我们一行一行的看。</p>
<p><code>com.android.application</code> 表示这是一个应用程序模块，<code>com.android.library</code> 表示这是一个库模块，他俩最大的区别就是，一个可以直接运行，一个只能作为代码库依附于别的应用程序模块来运行。</p>
<p>接下来是一个大的android闭包，我们看看它都代表什么。</p>
<p><code>compileSdkVersion</code>: 用于指定项目的编译版本，我们这里指定25，表示使用Android 7.1.1来编译，如果你不知道具体使用哪个版本来编译，你可以直接看此文章的第一张图，或者你也可以在Android Studio-&gt;Preferences 直接搜索Android SDK 来查看版本情况。</p>
<p><code>buildToolsVersion</code>: 用来指定项目构建工具的版本，如果有新版本时，Android Studio会进行提升。</p>
<p><code>applicationId</code>: 当前项目的包名</p>
<p><code>minSdkVersion</code>: 最低支持的Android系统版本</p>
<p><code>targetSdkVersion</code>: 这个表示你在该目标版本上已经做过充分的测试，系统将会为你的应用程序启用一些最新的功能和特性，比如你设置成23或者更高，系统会为你的应用程序启用运行时权限，如果你设置成22，那么Android 6.0的功能你就用不了。</p>
<p><code>versionCode</code>: 当前版本号</p>
<p><code>versionName</code>: 当前项目的版本名 </p>
<p><code>testInstrumentationRunner</code>: 测试的一些东西</p>
<p>我们再来看看<code>buildTypes</code>闭包，buildTypes闭包用于指定生成安装文件的相关配置，通常他包含两个子包：<code>release</code>和<code>debug</code>。一个表示生成环境，一个表示测试环境，debug默认可以不写。我们看看<code>release</code>包下的具体内容</p>
<p><code>minifyEnabled</code>: 用于指定是否对代码进行混淆<br><code>proguardFiles</code>: 混淆时使用的文件</p>
<p>我们再来看看<code>dependencies</code>包，它表示当前项目所有的依赖关系，通常Android Studio项目一共有3种依赖方式：<strong>本地依赖</strong>、<strong>库依赖</strong>、<strong>远程依赖</strong>。本地依赖就是jar包依赖，库依赖是在项目中添加模块，远程依赖是对jcenter库上开源项目的依赖。</p>
<p><code>compile fileTree</code>: 它就是一个本地依赖声明，表示将libs目录下的所有的.jar后缀的文件都添加到构建路径中去。</p>
<p><code>compile</code>: 这个则是远程依赖，</p>
<p>还有一种库依赖，写法为<code>compile project(&#39;:helper&#39;)</code>，它表示添加一个名叫helper库的依赖，当然，前提是这个库已经添加到你的项目中。</p>
<p>关于build.gradle的配置还有很多，我想在以后项目复杂了，会遇到的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于前段时间使用ReactNative开发过一个项目，在开发的过程中，会使用到大量的非ReactNative提供的组件和功能。这时候就必须写原生桥接，iOS还好说，毕竟是靠这个吃饭的，可是android就捉襟见肘了。为了向大前端的目标更进一步，我计划开始学习android，为期6个月，我的目标是6个月内起码自己公司的android项目可以上手，当然，如果想成为真正的android开发者，光靠这6个月是不行。还需要大量的实际项目才能锻炼。&lt;/p&gt;
&lt;p&gt;值得庆幸的是我在大学主攻的就是java(哈哈，现在也基本上忘的差不多了)。为了打好基础，我买了两本书，一本是《java编程思想》，一本是京东上销量很好的《第二行代码Android》，希望这两本书能够帮到我。另外我也会专门开一个专栏，讲解我学习java的过程。可能在接下来的博客中，我总结的都是基础知识，大神莫嘲笑。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.guiyongdong.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.guiyongdong.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>转场动画详解</title>
    <link href="http://www.guiyongdong.com/2017/03/06/%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.guiyongdong.com/2017/03/06/转场动画详解/</id>
    <published>2017-03-06T02:02:31.000Z</published>
    <updated>2017-03-09T07:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中，页面之间的跳转无外乎由<code>UINavigationController</code>管理的<code>push</code>或者<code>pop</code>操作、以及由<code>UIViewController</code>管理的<code>present</code>和<code>dismiss</code>操作，无论何种操作，iOS原生系统都为我们提供了页面之间的基础跳转动画。但是往往在开发中，由于各种功能需求，iOS原生系统提供的跳转动画并不能满足我们的需求，好在iOS早就给我们提供了一套自定义转场动画的解决方案，这篇文章就来详细了解一下转场动画。在了解这篇文章之前，先看看iOS提供的整个转场框架</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/transition.png?raw=true"><br></div>

<a id="more"></a>
<h2 id="present-dismiss"><a href="#present-dismiss" class="headerlink" title="present/dismiss"></a>present/dismiss</h2><p>首先，我们先来了解一下<code>模态跳转</code>。开发中，假如在A界面需要模态跳转到B界面，通常会这么写：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    PresentBViewController *bVC = [[PresentBViewController alloc] init];</div><div class="line">    [<span class="keyword">self</span> presentViewController:bVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>模态消失当前界面则是这么写：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a>UIViewControllerTransitioningDelegate</h4><p>使用模态跳转时，系统已经为我们写好的跳转的动画，而要想自定义模态跳转动画，则需要一个实现<code>UIViewControllerTransitioningDelegate</code>协议、并实现协议部分方法的对象。在<code>UIViewController.h</code>头文件中，我们可以发现如下定义：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIViewControllerTransitioningDelegate</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewController</span>(<span class="title">UIViewControllerTransitioning</span>)</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerTransitioningDelegate</span>&gt; transitioningDelegate <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">7</span>_0);</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>如此，我们则需要定义一个对象，并实现<code>UIViewControllerTransitioningDelegate</code>协议方法，赋值给将要模态跳转的控制器(<code>PresentBViewController</code>)，如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PresentAViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) PresentManager *presentManager;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PresentAViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    PresentBViewController *bVC = [[PresentBViewController alloc] init];</div><div class="line">    <span class="keyword">self</span>.presentManager = [[PresentManager alloc] init];</div><div class="line">    bVC.transitioningDelegate = <span class="keyword">self</span>.presentManager;</div><div class="line">    [<span class="keyword">self</span> presentViewController:bVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>我们先来看看<code>UIViewControllerTransitioningDelegate</code>有哪些协议方法:<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//当使用模态弹出时 会调用此方法 返回一个实现 UIViewControllerAnimatedTransitioning 协议的对象 </span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                                            presentingController:(<span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                                sourceController:(<span class="built_in">UIViewController</span> *)source;</div><div class="line"><span class="comment">//当使用模态消失时 会调用此方法 返回一个实现 UIViewControllerAnimatedTransitioning 协议的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed;</div><div class="line"><span class="comment">// 当使用模态弹出时 会调用此方法 返回一个实现 UIViewControllerInteractiveTransitioning协议的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForPresentation:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</div><div class="line"><span class="comment">// 当使用模态消失时 会调用此方法 返回一个实现 UIViewControllerInteractiveTransitioning协议的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIPresentationController</span> *)presentationControllerForPresentedViewController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                               presentingViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                   sourceViewController:(<span class="built_in">UIViewController</span> *)source;</div></pre></td></tr></table></figure></p>
<p>先来看这两个代理方法：<code>animationControllerForPresentedController:presentingController:sourceController:(UIViewController *)source</code>和<code>animationControllerForDismissedController:(UIViewController *)dismissed</code>他们都返回了一个实现<code>UIViewControllerAnimatedTransitioning</code>协议的对象。<code>UIViewControllerAnimatedTransitioning</code>协议的方法就是我们实现动画的地方。关于此协议我们等会再说。</p>
<p>再来看如下两个方法:<br><code>interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator</code>和<code>interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator</code>，他们都返回了一个实现<code>UIViewControllerInteractiveTransitioning</code>协议的对象，而此协议主要用于交互式转场动画。关于此协议我们等会再说。</p>
<h2 id="push-pop"><a href="#push-pop" class="headerlink" title="push/pop"></a>push/pop</h2><p>在使用<code>UINavigationController</code>进行页面之间的导航管理时，系统也是默认为我们实现了<code>push</code>和<code>pop</code>动画的，而如果想自定义<code>push/pop</code>动画，则需要一个实现<code>UINavigationControllerDelegate</code>协议的对象。如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PushAViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) PushManager *pushManager;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PushAViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    PushBViewController *bVC = [[PushBViewController alloc] init];</div><div class="line">    <span class="keyword">self</span>.pushManager = [[PushManager alloc] init];</div><div class="line">    bVC.navigationController.delegate = <span class="keyword">self</span>.pushManager;</div><div class="line">    [<span class="keyword">self</span>.navigationController pushViewController:bVC animated:<span class="literal">YES</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h4 id="UINavigationControllerDelegate"><a href="#UINavigationControllerDelegate" class="headerlink" title="UINavigationControllerDelegate"></a>UINavigationControllerDelegate</h4><p>我们再来看看<code>UINavigationControllerDelegate</code>协议的相关方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//返回真正执行交互式动画的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController</div><div class="line">                                   interactionControllerForAnimationController:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;) animationController;</div><div class="line"></div><div class="line"><span class="comment">//返回由谁去执行动画的对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController</div><div class="line">                                            animationControllerForOperation:(<span class="built_in">UINavigationControllerOperation</span>)operation</div><div class="line">                                                         fromViewController:(<span class="built_in">UIViewController</span> *)fromVC</div><div class="line">                                                           toViewController:(<span class="built_in">UIViewController</span> *)toVC;</div></pre></td></tr></table></figure></p>
<p>我们会发现 此两种方法分别返回了实现了<code>UIViewControllerInteractiveTransitioning</code>协议的对象和实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象。我们不难发现，无论是<code>push/pop</code>还是<code>present/dismiss</code>真正的执行动画都是一个实现了<code>UIViewControllerAnimatedTransitioning</code>协议的对象，而真正执行交互式动画的都是一个实现了<code>UIViewControllerInteractiveTransitioning</code>协议的对象。既然如此，那我们就来研究一下<code>UIViewControllerAnimatedTransitioning</code>和<code>UIViewControllerInteractiveTransitioning</code>协议</p>
<h2 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a>UIViewControllerAnimatedTransitioning</h2><p>先来看此协议的方法:<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//动画执行的时间</span></div><div class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext;</div><div class="line"><span class="comment">//执行动画</span></div><div class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext;</div></pre></td></tr></table></figure></p>
<p>此协议的两个方法必须实现。<code>transitionDuration:</code>方法返回动画执行的时间。通常情况下，系统执行<code>present/dismiss</code>和<code>push/pop</code>动画的时间为0.5秒左右。<code>animateTransition</code>方法就是真正执行动画的地方。这个方法系统会给我们传过来一个实现了<code>UIViewControllerContextTransitioning</code>协议的对象（转场上下文），在执行动画之前，我们先来了解一下<code>UIViewControllerContextTransitioning</code>协议。</p>
<p>先来看<code>UIViewControllerContextTransitioning</code>协议的定义<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//上下文的view 对做动画的view需要添加到此上下文的view中</span></div><div class="line">- (<span class="built_in">UIView</span> *)containerView;</div><div class="line"><span class="comment">//是否动画正在进行</span></div><div class="line">- (<span class="built_in">BOOL</span>)isAnimated;</div><div class="line"><span class="comment">//是否是交互式动画</span></div><div class="line">- (<span class="built_in">BOOL</span>)isInteractive; </div><div class="line"><span class="comment">//是否取消</span></div><div class="line">- (<span class="built_in">BOOL</span>)transitionWasCancelled;</div><div class="line"><span class="comment">//获取当前模态跳转的方式</span></div><div class="line">- (<span class="built_in">UIModalPresentationStyle</span>)presentationStyle;</div><div class="line"><span class="comment">//根据系数来更新交互式动画 0~1</span></div><div class="line">- (<span class="keyword">void</span>)updateInteractiveTransition:(<span class="built_in">CGFloat</span>)percentComplete;</div><div class="line"><span class="comment">//完成交互式动画</span></div><div class="line">- (<span class="keyword">void</span>)finishInteractiveTransition;</div><div class="line"><span class="comment">//取消交互式动画</span></div><div class="line">- (<span class="keyword">void</span>)cancelInteractiveTransition;</div><div class="line"><span class="comment">//iOS10新加入的方法 暂停交互式动画</span></div><div class="line">- (<span class="keyword">void</span>)pauseInteractiveTransition <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">10</span>_0);</div><div class="line"><span class="comment">//当动画结束时 要调用此方法告诉上下文</span></div><div class="line">- (<span class="keyword">void</span>)completeTransition:(<span class="built_in">BOOL</span>)didComplete;</div><div class="line"><span class="comment">//获取当前上下文的控制器，使用UITransitionContextFromViewControllerKey获取fromVC 使用UITransitionContextToViewControllerKey获取toVC</span></div><div class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UIViewController</span> *)viewControllerForKey:(<span class="built_in">UITransitionContextViewControllerKey</span>)key;</div><div class="line"><span class="comment">//iOS8之后的方法 返回此上下文控制器的view ，通常情况下，尽可能不直接使用controller的view属性，因为有时候我们直接使用controller的view并不是我们真正要做动画的view。我们应该直接使用UITransitionContextFromViewKey来获取fromView，使用UITransitionContextToViewKey来获取toView。</span></div><div class="line">- (<span class="keyword">nullable</span> __kindof <span class="built_in">UIView</span> *)viewForKey:(<span class="built_in">UITransitionContextViewKey</span>)key <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="comment">//目标view的transform</span></div><div class="line">- (<span class="built_in">CGAffineTransform</span>)targetTransform <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</div><div class="line"><span class="comment">//返回初始位置的frame 即fromView的frame</span></div><div class="line">- (<span class="built_in">CGRect</span>)initialFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</div><div class="line"><span class="comment">//返回动画结束位置的frame 即toView得frame</span></div><div class="line">- (<span class="built_in">CGRect</span>)finalFrameForViewController:(<span class="built_in">UIViewController</span> *)vc;</div></pre></td></tr></table></figure></p>
<p>了解完<code>UIViewControllerContextTransitioning</code>协议后，我们就可以实现自定义转场动画了。</p>
<p>第一节中，我们定义了类<code>PresentManager</code>并实现了<code>UIViewControllerAnimatedTransitioning</code>和<code>UIViewControllerTransitioningDelegate</code>,我们先来看<code>UIViewControllerTransitioningDelegate</code>协议的具体实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                                            presentingController:(<span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                                sourceController:(<span class="built_in">UIViewController</span> *)source &#123;</div><div class="line">    <span class="comment">//标记此动画为Present 并使用自身为动画的最终执行者</span></div><div class="line">    <span class="keyword">self</span>.transitionStyle = TransitionStylePresent;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed &#123;</div><div class="line">    <span class="comment">//标记此动画为Dismiss 并使用自身为动画的最终执行者</span></div><div class="line">    <span class="keyword">self</span>.transitionStyle = TransitionStyleDismiss;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看看<code>UIViewControllerAnimatedTransitioning</code>协议的具体实现：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</div><div class="line">	<span class="comment">//返回动画的执行时间</span></div><div class="line">    <span class="keyword">return</span> <span class="number">1.0</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</div><div class="line">    <span class="comment">//1. 首先获取上下文的view</span></div><div class="line">    <span class="built_in">UIView</span>  *containerView = [transitionContext containerView];</div><div class="line">    <span class="keyword">if</span> (!containerView) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.transitionStyle == TransitionStylePresent) &#123;</div><div class="line">        <span class="comment">//present 动画</span></div><div class="line">        </div><div class="line">        <span class="comment">//2. 获取 fromViewController 和 toViewController</span></div><div class="line">        <span class="built_in">UIViewController</span> *fromViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</div><div class="line">        <span class="built_in">UIViewController</span> *toViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//3. 获取fromView和toView</span></div><div class="line">        <span class="built_in">UIView</span> *fromView, *toView;</div><div class="line">        <span class="keyword">if</span> ([transitionContext respondsToSelector:<span class="keyword">@selector</span>(viewForKey:)]) &#123;</div><div class="line">            fromView = [transitionContext viewForKey:<span class="built_in">UITransitionContextFromViewKey</span>];</div><div class="line">            toView = [transitionContext viewForKey:<span class="built_in">UITransitionContextToViewKey</span>];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            fromView = fromViewController.view;</div><div class="line">            toView = toViewController.view;</div><div class="line">        &#125;</div><div class="line">        fromView.frame = [transitionContext initialFrameForViewController:fromViewController];</div><div class="line">        toView.frame = [transitionContext finalFrameForViewController:toViewController];</div><div class="line">        </div><div class="line">        <span class="comment">//4. 设置toView动画初始frame 这里 模仿一下从屏幕左边模态跳转</span></div><div class="line">        toView.frame = <span class="built_in">CGRectMake</span>(-toView.frame.size.width, toView.frame.origin.y, toView.frame.size.width, toView.frame.size.height);</div><div class="line">        </div><div class="line">        <span class="comment">//5. 添加到上下文的view上</span></div><div class="line">        [containerView addSubview:fromView];</div><div class="line">        [containerView addSubview:toView];</div><div class="line">        </div><div class="line">        <span class="comment">//6. 执行动画</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] animations:^&#123;</div><div class="line">            toView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, toView.frame.origin.y, toView.frame.size.width, toView.frame.size.height);</div><div class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            <span class="comment">//7. 一定要告诉上下文 动画执行结束</span></div><div class="line">            [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</div><div class="line">        &#125;];</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// pop动画</span></div><div class="line">        <span class="comment">//2. 获取 fromViewController 和 toViewController</span></div><div class="line">        <span class="built_in">UIViewController</span> *fromViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</div><div class="line">        <span class="built_in">UIViewController</span> *toViewController = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//3. 获取fromView和toView</span></div><div class="line">        <span class="built_in">UIView</span> *fromView, *toView;</div><div class="line">        <span class="keyword">if</span> ([transitionContext respondsToSelector:<span class="keyword">@selector</span>(viewForKey:)]) &#123;</div><div class="line">            fromView = [transitionContext viewForKey:<span class="built_in">UITransitionContextFromViewKey</span>];</div><div class="line">            toView = [transitionContext viewForKey:<span class="built_in">UITransitionContextToViewKey</span>];</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            fromView = fromViewController.view;</div><div class="line">            toView = toViewController.view;</div><div class="line">        &#125;</div><div class="line">        fromView.frame = [transitionContext initialFrameForViewController:fromViewController];</div><div class="line">        toView.frame = [transitionContext finalFrameForViewController:toViewController];</div><div class="line">        </div><div class="line">        <span class="comment">//4. 添加到上下文的view上</span></div><div class="line">        [containerView addSubview:toView];</div><div class="line">        [containerView addSubview:fromView];</div><div class="line">        </div><div class="line">        <span class="comment">//5. 执行动画</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] animations:^&#123;</div><div class="line">            fromView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, -fromView.frame.size.height, fromView.frame.size.width, fromView.frame.size.height);</div><div class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            <span class="comment">//7. 一定要告诉上下文 动画执行结束</span></div><div class="line">            [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我这里只是做一个简单的动画，至于该如何做更复杂的动画，那就开动大家的大脑吧。</p>
<p>同样的，自定义<code>push/pop</code>动画也是如此，这里不再详解。</p>
<h2 id="交互式动画"><a href="#交互式动画" class="headerlink" title="交互式动画"></a>交互式动画</h2><p>在前面，我们一直提到一个协议<code>UIViewControllerInteractiveTransitioning</code>，实现此协议，我们就能使用交互式转场动画。iOS7为我们提供了已经实现好此协议的类<code>UIPercentDrivenInteractiveTransition</code>，我们只需继承此类，便可实现交互式动画。为了方便，下面的例子依旧在<code>present/dismiss</code>转场基础上讲解，我们让<code>PresentManager</code>继承<code>UIPercentDrivenInteractiveTransition</code>，并且在<code>PresentBViewController</code>上添加<code>pan</code>手势，具体代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//这里为了方便  当A控制器present B控制器的时候 直接在B控制器上添加pan手势，并且强引用B控制器。</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                                            presentingController:(<span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                                sourceController:(<span class="built_in">UIViewController</span> *)source &#123;</div><div class="line">    <span class="comment">//标记此动画为Present 并使用自身为动画的最终执行者</span></div><div class="line">    <span class="keyword">self</span>.transitionStyle = TransitionStylePresent;</div><div class="line">    <span class="comment">//添加手势</span></div><div class="line">    [<span class="keyword">self</span> addGesture:presented];</div><div class="line">    <span class="keyword">self</span>.presentingVC = presented;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在代理方法中返回`PresentManager`自己作为交互式代理</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForDismissal:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.interacting) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//添加手势</span></div><div class="line">- (<span class="keyword">void</span>)addGesture:(<span class="built_in">UIViewController</span> *)viewController &#123;</div><div class="line">    <span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(panGesture:)];</div><div class="line">    [viewController.view addGestureRecognizer:pan];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//监听手势变化</span></div><div class="line">- (<span class="keyword">void</span>)panGesture:(<span class="built_in">UIPanGestureRecognizer</span> *)gesture &#123;</div><div class="line">    <span class="built_in">CGPoint</span> translation = [gesture translationInView:gesture.view];</div><div class="line">    <span class="keyword">switch</span> (gesture.state) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateBegan</span>:</div><div class="line">        		<span class="comment">//标记当前模态消失为手势调用</span></div><div class="line">            <span class="keyword">self</span>.interacting = <span class="literal">YES</span>;</div><div class="line">            [<span class="keyword">self</span>.presentingVC dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateChanged</span>: &#123;</div><div class="line">        		<span class="comment">//根据手势的滑动距离 更新状态</span></div><div class="line">            <span class="built_in">CGFloat</span> fraction = translation.x / gesture.view.frame.size.width;</div><div class="line">            [<span class="keyword">self</span> updateInteractiveTransition:fraction];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateEnded</span>:</div><div class="line">        <span class="keyword">case</span> <span class="built_in">UIGestureRecognizerStateCancelled</span>: &#123;</div><div class="line">        		<span class="comment">//如果划过50% dismiss掉 否则恢复</span></div><div class="line">            <span class="keyword">self</span>.interacting = <span class="literal">NO</span>;</div><div class="line">            <span class="built_in">CGFloat</span> fraction = translation.x / gesture.view.frame.size.width;</div><div class="line">            <span class="keyword">if</span> (fraction&lt;<span class="number">0.5</span> || gesture.state == <span class="built_in">UIGestureRecognizerStateCancelled</span>) &#123;</div><div class="line">                [<span class="keyword">self</span> cancelInteractiveTransition];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                [<span class="keyword">self</span> finishInteractiveTransition];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样的，<code>push/pop</code>亦是如此。</p>
<h2 id="UIPresentationController"><a href="#UIPresentationController" class="headerlink" title="UIPresentationController"></a>UIPresentationController</h2><p>在第一节，我们说到<code>UIViewControllerTransitioningDelegate</code>协议的时候，还有个方法没有说，它是iOS8以后才有的，此方法为：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIPresentationController</span> *)presentationControllerForPresentedViewController:(<span class="built_in">UIViewController</span> *)presented</div><div class="line">                                                               presentingViewController:(<span class="keyword">nullable</span> <span class="built_in">UIViewController</span> *)presenting</div><div class="line">                                                                   sourceViewController:(<span class="built_in">UIViewController</span> *)source</div></pre></td></tr></table></figure></p>
<p>此方法返回一个<code>UIPresentationController</code>对象，这个对象是做什么的呢？</p>
<p><code>UIViewController</code>有一个属性<code>modalPresentationStyle</code>，我们来看看它有哪些值：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIModalPresentationStyle</span>) &#123;</div><div class="line">        <span class="built_in">UIModalPresentationFullScreen</span> = <span class="number">0</span>,</div><div class="line">        <span class="built_in">UIModalPresentationPageSheet</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">3</span>_2) __TVOS_PROHIBITED,</div><div class="line">        <span class="built_in">UIModalPresentationFormSheet</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">3</span>_2) __TVOS_PROHIBITED,</div><div class="line">        <span class="built_in">UIModalPresentationCurrentContext</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">3</span>_2),</div><div class="line">        <span class="built_in">UIModalPresentationCustom</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0),</div><div class="line">        <span class="built_in">UIModalPresentationOverFullScreen</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">        <span class="built_in">UIModalPresentationOverCurrentContext</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0),</div><div class="line">        <span class="built_in">UIModalPresentationPopover</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">8</span>_0) __TVOS_PROHIBITED,</div><div class="line">        <span class="built_in">UIModalPresentationNone</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0) = <span class="number">-1</span>,         </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>平常开发中，我们使用最多的就是<code>UIModalPresentationCustom</code>，如果我们不使用<code>UIModalPresentationCustom</code>，默认的系统会在我们调用“上下文”的<code>completeTransition</code>方法后会把fromVC移除掉。</p>
<p>如果我们想在<code>present/pop</code>执行动画的生命周期过程中，任意的在上下文中插入视图或者更改最终视图的大小等，使用<code>UIPresentationController</code>便可实现。我们来看<code>UIPresentationController</code>类的定义：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//上下文的view</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *containerView;</div><div class="line"></div><div class="line"><span class="comment">//即将布局</span></div><div class="line">- (<span class="keyword">void</span>)containerViewWillLayoutSubviews;</div><div class="line"><span class="comment">//正在布局</span></div><div class="line">- (<span class="keyword">void</span>)containerViewDidLayoutSubviews;</div><div class="line"></div><div class="line"><span class="comment">//返回模态跳转后的view（B控制器View）的最终frame  通常情况下要重写此方法</span></div><div class="line">- (<span class="built_in">CGRect</span>)frameOfPresentedViewInContainerView;</div><div class="line"></div><div class="line"><span class="comment">//周期方法</span></div><div class="line">- (<span class="keyword">void</span>)presentationTransitionWillBegin;</div><div class="line">- (<span class="keyword">void</span>)presentationTransitionDidEnd:(<span class="built_in">BOOL</span>)completed;</div><div class="line">- (<span class="keyword">void</span>)dismissalTransitionWillBegin;</div><div class="line">- (<span class="keyword">void</span>)dismissalTransitionDidEnd:(<span class="built_in">BOOL</span>)completed;</div></pre></td></tr></table></figure></p>
<p>如此，我们便可在视图周期方法中任意的添加和删除视图，以满足我们的需求。也可以在布局过程中，改变弹出视图的frame。切记，视图的添加和删除都是在上下文的view中进行的。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>了解完整个转场动画的框架，我们合理的使用框架中的协议和类，便能尽可能的满足我们的开发需求。至于该如何实现，大家可以动脑了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发中，页面之间的跳转无外乎由&lt;code&gt;UINavigationController&lt;/code&gt;管理的&lt;code&gt;push&lt;/code&gt;或者&lt;code&gt;pop&lt;/code&gt;操作、以及由&lt;code&gt;UIViewController&lt;/code&gt;管理的&lt;code&gt;present&lt;/code&gt;和&lt;code&gt;dismiss&lt;/code&gt;操作，无论何种操作，iOS原生系统都为我们提供了页面之间的基础跳转动画。但是往往在开发中，由于各种功能需求，iOS原生系统提供的跳转动画并不能满足我们的需求，好在iOS早就给我们提供了一套自定义转场动画的解决方案，这篇文章就来详细了解一下转场动画。在了解这篇文章之前，先看看iOS提供的整个转场框架&lt;/p&gt;
&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/guiyongdong/Resource/blob/master/hexoImage/transition.png?raw=true&quot;/&gt;&lt;br&gt;&lt;/div&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="动画" scheme="http://www.guiyongdong.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking源码解析</title>
    <link href="http://www.guiyongdong.com/2017/02/15/AFNetworking%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.guiyongdong.com/2017/02/15/AFNetworking源码解析/</id>
    <published>2017-02-15T06:15:04.000Z</published>
    <updated>2017-03-01T02:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络是APP开发中非常重要的一部分，除非这个APP是本地自玩，否则就离不开网络。在iOS开发中，我们一般都会去使用别人造好的轮子，其中最有名也最常用的非<code>AFNetworking</code>莫属。这篇文章就深入探讨一下<code>AFNetworking</code>是如何工作的。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>我们先来看看<code>AFNetworking</code>整个架构体系：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/af2.png?raw=true"><br></div>

<p>首先，我们有两个问题需要了解：</p>
<ul>
<li>如何使用NSURLSession发出HTTP请求</li>
<li>如何使用AFNetworking发出HTTP请求</li>
</ul>
<a id="more"></a>
<h4 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h4><hr>
<p><code>NSURLSession</code>以及与它相关的类为我们提供了下载内容的API，这个API提供了一系列的代理方法来支持身份认证，并且支持后台下载。</p>
<p>使用<code>NSURLSession</code>来运行HTTP请求并且获得数据总共有五个步骤：</p>
<ol>
<li>实例化一个<code>NSURLRequest/NSMutableURLRequest</code>,设置URL</li>
<li>通过<code>- shareSession</code>方法获取<code>NSURLSession</code></li>
<li>在session上调用<code>- dataTaskWithRequest:completionHandler:</code>方法返回一个<code>NSURLSessionDataTask</code></li>
<li>调用dataTask的<code>- resume</code>,开始执行任务</li>
<li>在completionHandler中将数据编码，返回字符串</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:[[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"https://github.com"</span>]];</div><div class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request</div><div class="line">                                       completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">                                           <span class="built_in">NSString</span> *dataStr = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">                                           <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, dataStr);</div><div class="line">                                       &#125;];</div><div class="line">[task resume];</div></pre></td></tr></table></figure>
<p>这一段代码可以说是使用<code>NSURLSession</code>发送请求最简单的一段代码了，当你运行这段代码会在控制台看到github首页的html</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang="en" class=""&gt;</div><div class="line">  &lt;head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# object: http://ogp.me/ns/object# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#"&gt;</div><div class="line">    &lt;meta charset='utf-8'&gt;</div><div class="line">        ...</div><div class="line">    &lt;/head&gt;</div><div class="line">    ...</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>想对<code>NSURLSession</code>有更深的了解，<a href="http://www.guiyongdong.com/2016/11/18/NSURLSession%E4%B8%8ENSURLConnection%E5%8C%BA%E5%88%AB/">请点这里</a></p>
<h4 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h4><hr>
<p>AFNetworking的使用也比较简单的，使用它来发送HTTP请求有两个步骤</p>
<ol>
<li>以服务器的主机地址或者域名生成一个<code>AFHTTPSessionManager</code>的实例</li>
<li>调用<code>- GET:parameters:progress:success:failure:</code>方法</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] initWithBaseURL:[[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"hostname"</span>]];</div><div class="line">[manager GET:<span class="string">@"relative_url"</span> parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span></div><div class="line">    success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span> ,responseObject);</div><div class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error);</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：在iOS9中，苹果默认全局HTTPS，如果你要发送不安全的HTTP请求，需要在info.plist中加入如下键值对才能发出不安全的HTTP请求<br><span></span><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/af3.jpeg?raw=true"><br>还有一件事情是要注意的是，AFNetworking默认接收json格式的响应（因为这是在iOS平台上的框架，一般不需要text/html）,如果想要返回html,需要设置<code>acceptableContentTypes</code>。</p>
</blockquote>
<h4 id="AFNetworking的调用栈"><a href="#AFNetworking的调用栈" class="headerlink" title="AFNetworking的调用栈"></a>AFNetworking的调用栈</h4><hr>
<p>刚才我们写了一个简单的网络请求，接下来，我们来看看<code>AFHTTPSessionManager</code>的初始化方法<code>- initWithBaseURL:</code>的调用栈：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- [AFHTTPSessionManager initWithBaseURL:]</div><div class="line">    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]</div><div class="line">        - [AFURLSessionManager initWithSessionConfiguration:]</div><div class="line">            - [<span class="built_in">NSURLSession</span> sessionWithConfiguration:delegate:delegateQueue:]</div><div class="line">            - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></div><div class="line">            - [AFSecurityPolicy defaultPolicy] <span class="comment">// 负责身份认证</span></div><div class="line">            - [AFNetworkReachabilityManager sharedManager] <span class="comment">// 查看网络连接情况</span></div><div class="line">        - [AFHTTPRequestSerializer serializer] <span class="comment">// 负责序列化请求</span></div><div class="line">        - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></div></pre></td></tr></table></figure>
<p>从这个初始化方法的调用栈，我们可以非常清晰地了解这个架构的结构：</p>
<ul>
<li>其中<code>AFURLSessionManager</code>是<code>AFHTTPSessionManager</code>的父类</li>
<li><code>AFURLSessionManager</code>负责生成<code>NSURLSession</code>的实例，管理<code>AFSecurityPolicy</code>和<code>AFNetworkReachabilityManager</code>,来保证请求的安全和查看网络连接情况，它有一个<code>AFJSONResponseSerializer</code>的实例来序列化HTTP响应</li>
<li><code>AFHTTPSessionManager</code>有着自己的<code>AFHTTPRequestSerialier</code>和<code>AFJSONResponseSerializer</code>来管理请求和响应的序列化，同时依赖父类提供的接口保证安全、监控网络状态，实现发出HTTP请求这一核心功能</li>
</ul>
<p>初始化方法很好地揭示了AFNetworking整个框架的架构，接下来我们要通过分析另一个方法<code>- GET:parameters:process:success:failure:</code>的调用栈，看一下HTTP请求是如何发出的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- [AFHTTPSessionManager GET:parameters:process:success:failure:]</div><div class="line">    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] <span class="comment">// 返回 NSURLSessionDataTask #1</span></div><div class="line">        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] <span class="comment">// 返回 NSMutableURLRequest</span></div><div class="line">        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] <span class="comment">// 返回 NSURLSessionDataTask #2</span></div><div class="line">            - [<span class="built_in">NSURLSession</span> dataTaskWithRequest:] <span class="comment">// 返回 NSURLSessionDataTask #3</span></div><div class="line">            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</div><div class="line">                - [AFURLSessionManagerTaskDelegate init]</div><div class="line">                - [AFURLSessionManager setDelegate:forTask:]</div><div class="line">    - [<span class="built_in">NSURLSessionDataTask</span> resume]</div></pre></td></tr></table></figure>
<p>在这里 <code>#1</code> <code>#2</code> <code>#3</code>处返回的是同一个dataTask，我们可以看到，在<code>#3</code>出调用的方法<code>- [NSURLSession dataTaskWithRequest:]</code>和只使用<code>NSURLSession</code>发出HTTP请求时调用的方法<code>- [NSURLSession dataTaskWithRequest:completionHandler:]</code>差不多。在这个地方返回dataTask之后，我们再调用<code>- resume</code>方法执行请求，并在某些事件执行时通知代理<code>AFURLSessionManagerTaskDelegate</code></p>
<h3 id="AFNetworking的核心AFURLSessionManager"><a href="#AFNetworking的核心AFURLSessionManager" class="headerlink" title="AFNetworking的核心AFURLSessionManager"></a>AFNetworking的核心AFURLSessionManager</h3><hr>
<p><code>AFURLSessionManager</code>绝对可以称得上是AFNetworking的核心</p>
<ul>
<li>负责创建和管理NSURLSession</li>
<li>管理NSURLSessionTask</li>
<li>实现NSURLSessionDelegate等协议中的代理方法</li>
<li>使用_AFURLSessionTaskSwizzling调剂方法</li>
<li>引入AFSecurityPolicy保证请求的安全</li>
<li>引入AFNetworkingReachabilityManager监控网络状态</li>
</ul>
<p>这一节将会着重介绍上面七个功能中的前五个，分析它是如何包装<code>NSURLSession</code>以及众多代理方法的。</p>
<h4 id="创建和管理NSURLSession"><a href="#创建和管理NSURLSession" class="headerlink" title="创建和管理NSURLSession"></a>创建和管理NSURLSession</h4><hr>
<p>使用<code>AFURLSessionManager</code>时，第一件要做的事情一定是初始化：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!configuration) &#123;</div><div class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.sessionConfiguration = configuration;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</div><div class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line"></div><div class="line"><span class="meta">#if !TARGET_OS_WATCH</span></div><div class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</div><div class="line">    <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</div><div class="line">    <span class="comment">//为已有的task设置代理</span></div><div class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</div><div class="line">            [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</div><div class="line">            [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</div><div class="line">            [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在初始化方法中，需要完成初始化一些自己持有的特例：</p>
<ol>
<li>初始化 <strong>会话配置</strong> (NSURLSessionConfiguration)，默认为<code>defaultSessionConfiguration</code></li>
<li>初始化 <strong>会话</strong> (session)，并设置会话的代理以及代理列队</li>
<li>初始化管理 <strong>响应序列化</strong> (AFJSONResponseSerializer)，<strong>安全认证</strong> (AFSecurityPolicy) 以及 <strong>监控网络状态</strong> (AFNetworkReachabilityManager) 的实例</li>
<li>初始化保存data task的字典(mutableTaskDelegatesKeysByTaskIdentifier)</li>
</ol>
<h4 id="管理NSURLSessionTask"><a href="#管理NSURLSessionTask" class="headerlink" title="管理NSURLSessionTask"></a>管理NSURLSessionTask</h4><hr>
<p>接下来，在获得了<code>AFURLSessionManager</code>的实例之后，我们可以通过以下方法创建<code>NSURLSessionDataTask</code>的实例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                                         fromFile:(<span class="built_in">NSURL</span> *)fileURL</div><div class="line">                                         progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</div><div class="line">                                completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span>  * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                                             progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</div><div class="line">                                          destination:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</div><div class="line">                                    completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>这里省略了一些返回NSURLSessionTask的方法，因为这些接口的形式都是差不多的。</p>
<p>我们将以 <code>[AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code>方法的实现为例，分析它是如何实例化并返回一个<code>NSURLSessionTask</code>的实例的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>- [NSURLSession dataTaskWithRequest:]</code>方法传入<code>NSURLRequest</code></li>
<li>调用<code>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</code>方法返回一个<code>AFURLSessionManagerTaskDelegate</code>对象</li>
<li>将<code>completionHandler</code> <code>uploadProgressBlock</code>和<code>downloadProgressBlock</code>传入该对象并在相应事件发生时进行回调</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = <span class="keyword">self</span>;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</div><div class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中同时调用了另一个方法<code>- [AFURLSessionManager setDelegate:forTask:]</code>来设置代理：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSParameterAssert</span>(task);</div><div class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</div><div class="line"></div><div class="line">    [<span class="keyword">self</span>.lock lock];</div><div class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</div><div class="line">    [<span class="keyword">self</span>.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如上面所提到的，<code>AFURLSessionManager</code>就是通过字典<code>mutableTaskDelegatesKeyedByTaskIdentifier</code>来存储并管理每一个<code>NSURLSessionTask</code>，它以<code>taskIdentifier</code>为键存储task。</p>
<p>该方法使用<code>NSLock</code>来保证不同线程使用<code>mutableTaskDelegatesKeyedByTaskIdentifier</code>时，不会出现线程竞争的问题。</p>
<p>同时调用<code>-setupProgressForTask</code>，我们会在下面具体介绍这个方法。</p>
<h4 id="实现NSURLSessionDelegate等协议中的代理方法"><a href="#实现NSURLSessionDelegate等协议中的代理方法" class="headerlink" title="实现NSURLSessionDelegate等协议中的代理方法"></a>实现NSURLSessionDelegate等协议中的代理方法</h4><hr>
<p>在<code>AFURLSessionManager</code>的头文件中可以看到，它遵循了多个协议，其中包括：</p>
<ul>
<li>NSURLSessionDelegate</li>
<li>NSURLSessionTaskDelegate</li>
<li>NSURLSessionDataDelegate</li>
<li>NSURLSessionDownloadDelegate</li>
</ul>
<p>它的初始化方法<code>- [AFURLSessionManager initWithSessionConfiguration:]</code>将<code>NSURLSession</code>的代理指向self，然后实现这些方法，提供更简洁的block的接口：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block;</div><div class="line">- (<span class="keyword">void</span>)setSessionDidReceiveAuthenticationChallengeBlock:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionAuthChallengeDisposition</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSURLAuthenticationChallenge</span> *challenge, <span class="built_in">NSURLCredential</span> * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>它为所有的代理协议都提供了对应的block接口，方法实现的思路都是相似的，我们以<code>- [AFNRLSessionManager setSessionDidBecomeInvalidBlock:]</code>为例。</p>
<p>首先调用setter方法，将block存入<code>sessionDidBecomeInvalid</code>属性中：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block &#123;</div><div class="line">    <span class="keyword">self</span>.sessionDidBecomeInvalid = block;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当代理方法调用时，如果存在对应的block，会执行对应的block:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error  </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</div><div class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他相似的接口实现也都差不多，这里直接跳过了。</p>
<h4 id="使用AFURLSessionManagerTaskDelegate管理进度"><a href="#使用AFURLSessionManagerTaskDelegate管理进度" class="headerlink" title="使用AFURLSessionManagerTaskDelegate管理进度"></a>使用AFURLSessionManagerTaskDelegate管理进度</h4><hr>
<p>在上面我们提到过<code>AFURLSessionManagerTaskDelegate</code>类，它主要为task提供进度管理功能，并在task结束时回调，也就是调用在<code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code>等方法中传入的<code>completionHandler</code>。</p>
<p>我们首先分析一下<code>AFURLSessionManagerTaskDelegate</code>是如何对进度进行跟踪的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setupProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</div><div class="line"></div><div class="line">    <span class="meta">#1：设置在上传进度或者下载进度状态改变时的回调</span></div><div class="line"></div><div class="line">    <span class="meta">#2：KVO</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的实现有两个部分，一部分是对代理持有的两个属性<code>uploadProgress</code>和<code>downloadProgress</code>设置回调</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">__<span class="keyword">weak</span> __typeof__(task) weakTask = task;</div><div class="line"></div><div class="line"><span class="keyword">self</span>.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;  </div><div class="line">[<span class="keyword">self</span>.uploadProgress setCancellable:<span class="literal">YES</span>];</div><div class="line">[<span class="keyword">self</span>.uploadProgress setCancellationHandler:^&#123;</div><div class="line">   __typeof__(weakTask) strongTask = weakTask;</div><div class="line">   [strongTask cancel];</div><div class="line">&#125;];</div><div class="line">[<span class="keyword">self</span>.uploadProgress setPausable:<span class="literal">YES</span>];</div><div class="line">[<span class="keyword">self</span>.uploadProgress setPausingHandler:^&#123;</div><div class="line">   __typeof__(weakTask) strongTask = weakTask;</div><div class="line">   [strongTask suspend];</div><div class="line">&#125;];</div><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.uploadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;  </div><div class="line">   [<span class="keyword">self</span>.uploadProgress setResumingHandler:^&#123;</div><div class="line">       __typeof__(weakTask) strongTask = weakTask;</div><div class="line">       [strongTask resume];</div><div class="line">   &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里只有对<code>uploadProgress</code>设置回调的代码，设置<code>downloadProgress</code>与这里完全相同</p>
<blockquote>
<p>主要目的是在对应<code>NSProgress</code>的状态改变时，调用<code>resume</code> <code>suspend</code>等方法改变task的状态。</p>
</blockquote>
<p>第二部分是对task和<code>NSProgress</code>属性进行键值观测：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[task addObserver:<span class="keyword">self</span></div><div class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))</div><div class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">         context:<span class="literal">NULL</span>];</div><div class="line">[task addObserver:<span class="keyword">self</span></div><div class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))</div><div class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">         context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">[task addObserver:<span class="keyword">self</span></div><div class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))</div><div class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">         context:<span class="literal">NULL</span>];</div><div class="line">[task addObserver:<span class="keyword">self</span></div><div class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))</div><div class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">         context:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">[<span class="keyword">self</span>.downloadProgress addObserver:<span class="keyword">self</span></div><div class="line">                       forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</div><div class="line">                          options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                          context:<span class="literal">NULL</span>];</div><div class="line">[<span class="keyword">self</span>.uploadProgress addObserver:<span class="keyword">self</span></div><div class="line">                     forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</div><div class="line">                        options:<span class="built_in">NSKeyValueObservingOptionNew</span></div><div class="line">                        context:<span class="literal">NULL</span>];</div></pre></td></tr></table></figure>
<p>在<code>observeValueForKeypath:ofObject:change:context:</code>方法中改变进度，并调用block</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</div><div class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSURLSessionTask</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))]) &#123;</div><div class="line">            <span class="keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="string">@"new"</span>] longLongValue];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;</div><div class="line">            <span class="keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="string">@"new"</span>] longLongValue];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))]) &#123;</div><div class="line">            <span class="keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="string">@"new"</span>] longLongValue];</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;</div><div class="line">            <span class="keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="string">@"new"</span>] longLongValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对象的某些属性改变时更新<code>NSProgress</code>对象或使用block传递<code>NSProgress</code>对象<br><code>self.uploadProgressBlock(object)</code>。</p>
<h4 id="代理方法-URLSession-task-didCompleteWithError"><a href="#代理方法-URLSession-task-didCompleteWithError" class="headerlink" title="代理方法 URLSession:task:didCompleteWithError:"></a>代理方法 URLSession:task:didCompleteWithError:</h4><hr>
<p>在每一个<code>NSURLSessionTask</code>结束时，都会在代理方法<code>URLSession:task:didCompleteWithError:</code>中：</p>
<ol>
<li>调用传入的<code>completionHander</code>block</li>
<li>发出<code>AFNetworkingTaskDidCompleteNotification</code>通知</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</div><div class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</div><div class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error  </div><div class="line">&#123;</div><div class="line">    <span class="meta">#1：获取数据, 存储 `responseSerializer` 和 `downloadFileURL`</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="meta">#2：在存在错误时调用 `completionHandler`</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="meta">#3：调用 `completionHandler`</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是整个代理方法的骨架，先看一下最简单的第一部分代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">__block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];  </div><div class="line">userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line"><span class="comment">//Performance Improvement from #2672</span></div><div class="line"><span class="built_in">NSData</span> *data = <span class="literal">nil</span>;  </div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;  </div><div class="line">   data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</div><div class="line">   <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></div><div class="line">   <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;  </div><div class="line">   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</div><div class="line">   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码从<code>mutableData</code>中取出数据，设置了<code>userInfo</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;  </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">        <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果当前manager持有<code>completionGroup</code>或者<code>completionQueue</code>就是用它们。否则会创建一个<code>dispatch_group_t</code>并在主线程中调用<code>completionHandler</code>并发送通知（在主线程中）。</p>
<p>如果在执行当前task时没有遇到错误，那么先对数据进行序列化，然后同样调用block并发送通知。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;  </div><div class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</div><div class="line">    responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</div><div class="line">        responseObject = <span class="keyword">self</span>.downloadFileURL;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (responseObject) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</div><div class="line">            <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="代理方法URLSession-dataTask-didReceiveData-和URLSession-downloadTask-didFinishDownloadingToURL-这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为mutableData追加数据和处理下载的文件："><a href="#代理方法URLSession-dataTask-didReceiveData-和URLSession-downloadTask-didFinishDownloadingToURL-这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为mutableData追加数据和处理下载的文件：" class="headerlink" title="代理方法URLSession:dataTask:didReceiveData:和URLSession:downloadTask:didFinishDownloadingToURL: 这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为mutableData追加数据和处理下载的文件："></a>代理方法URLSession:dataTask:didReceiveData:和URLSession:downloadTask:didFinishDownloadingToURL: 这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为mutableData追加数据和处理下载的文件：</h4><hr>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</div><div class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location  </div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.downloadFileURL = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        <span class="keyword">self</span>.downloadFileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</div><div class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span>.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (fileManagerError) &#123;</div><div class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用-AFURLSessionTaskSwizzling-调剂方法"><a href="#使用-AFURLSessionTaskSwizzling-调剂方法" class="headerlink" title="使用 _AFURLSessionTaskSwizzling 调剂方法"></a>使用 _AFURLSessionTaskSwizzling 调剂方法</h4><hr>
<p><code>_AFURLSessionTaskSwizzling</code>的唯一功能就是修改<code>NSURLSessionTask</code>的<code>resume</code>和<code>suspend</code>方法，使用下面的方法替换原有的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)af_resume &#123;</div><div class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</div><div class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</div><div class="line">    [<span class="keyword">self</span> af_resume];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)af_suspend &#123;</div><div class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</div><div class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</div><div class="line">    [<span class="keyword">self</span> af_suspend];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做的目的是为了在方法<code>resume</code>或者<code>suspend</code>被调用时发送通知。</p>
<p>具体方法调剂的过程是在<code>+load</code>方法中进行的</p>
<p><code>load</code>方法只会在整个文件被引入时调用一次</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"NSURLSessionTask"</span>)) &#123;</div><div class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</div><div class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</div><div class="line"><span class="meta">#pragma GCC diagnostic push</span></div><div class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wnonnull"</span></span></div><div class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</div><div class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</div><div class="line">            Class superClass = [currentClass superclass];</div><div class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</div><div class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</div><div class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</div><div class="line">                originalAFResumeIMP != classResumeIMP) &#123;</div><div class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</div><div class="line">            &#125;</div><div class="line">            currentClass = [currentClass superclass];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [localDataTask cancel];</div><div class="line">        [session finishTasksAndInvalidate];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>首先用<code>NSClassFromString(@&quot;NSURLSessionTask&quot;)</code>判断当前部署的iOS版本是否含有类<code>NSURLSessionTask</code></li>
<li>因为iOS7和iOS8上对于<code>NSURLSesionTask</code>的实现不同，所以会通过<code>- [NSURLSession dataTaskWithURL:]</code>方法返回一个<code>NSURLSessionTask</code>实例</li>
<li>取得当前类<code>_AFURLSessionTaskSwizzling</code>中的实现<code>af_resume</code></li>
<li>判断当前类<code>currentClass</code>有<code>resume</code>方法</li>
<li>使用<code>swizzleResumeAndSuspendMethodForClass:</code>调剂该类的<code>resume</code>和<code>suspend</code>方法</li>
<li>currentClass = [currentClass superclass]</li>
</ol>
<h4 id="引入AFSecurityPolicy保证请求的安全"><a href="#引入AFSecurityPolicy保证请求的安全" class="headerlink" title="引入AFSecurityPolicy保证请求的安全"></a>引入AFSecurityPolicy保证请求的安全</h4><hr>
<p><code>AFSecurityPolicy</code>是<code>AFNetworking</code>用来保证HTTP请求安全的类，它被<code>AFURLSessionManager</code>持有，如果你在<code>AFURLSessionManager</code>的实现文件中搜索self.securityPolicy，你只会得到三条结果：</p>
<ol>
<li>初始化<code>self.securityPolicy = [AFSecurityPolicy defaultPolicy]</code></li>
<li>收到连接层的验证请求时</li>
<li>任务接收到验证请求时</li>
</ol>
<p>在API调用上，后两者都调用了<code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code>方法来判断当前服务器是否被信任，我们会在接下来的文章中具体介绍这个方法的实现的作用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</div><div class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</div><div class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</div><div class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</div><div class="line">                <span class="keyword">if</span> (credential) &#123;</div><div class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (completionHandler) &#123;</div><div class="line">        completionHandler(disposition, credential);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有传入<code>taskDidReceiveAuthenticationChallenge</code> block，只有在上述方法返回YES时，才会获得认证凭证<code>credential</code>。</p>
<h4 id="引入AFNetworkingReachabilityManager监控网络状态"><a href="#引入AFNetworkingReachabilityManager监控网络状态" class="headerlink" title="引入AFNetworkingReachabilityManager监控网络状态"></a>引入AFNetworkingReachabilityManager监控网络状态</h4><hr>
<p>与<code>AFSecurityPolicy</code>相同，<code>AFURLSessionManager</code>对网络状态的监控是由<code>AFNetworkReachabilityManager</code>来负责的，它仅仅是持有一个<code>AFNetworkReachabilityManager</code>的对象。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><hr>
<ul>
<li><code>AFURLSessionManager</code>是对<code>NSURLSession</code>的封装</li>
<li>它通过<code>- [AFURLSessionManager dataTaskWithRequest:completionHandler:]</code>等接口创建<code>NSURLSessionDataTask</code>的实例</li>
<li>持有一个字典<code>mutableTaskDelegatesKeyedByTaskIdentifier</code>管理这些data task 实例</li>
<li>引入<code>AFURLSessionManagerTaskDelegate</code>来对传入的<code>uploadProgressBlock</code>        <code>downloadProgressBlock</code> <code>completionHandler</code> 在合适的时间进行调用</li>
<li>实现了全部的代理方法来提供block接口</li>
<li>通过方法调剂在data task 状态改变时，发出通知</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络是APP开发中非常重要的一部分，除非这个APP是本地自玩，否则就离不开网络。在iOS开发中，我们一般都会去使用别人造好的轮子，其中最有名也最常用的非&lt;code&gt;AFNetworking&lt;/code&gt;莫属。这篇文章就深入探讨一下&lt;code&gt;AFNetworking&lt;/code&gt;是如何工作的。&lt;/p&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;我们先来看看&lt;code&gt;AFNetworking&lt;/code&gt;整个架构体系：&lt;/p&gt;
&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/guiyongdong/Resource/blob/master/hexoImage/af2.png?raw=true&quot;/&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;首先，我们有两个问题需要了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用NSURLSession发出HTTP请求&lt;/li&gt;
&lt;li&gt;如何使用AFNetworking发出HTTP请求&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.guiyongdong.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://www.guiyongdong.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码分析</title>
    <link href="http://www.guiyongdong.com/2017/01/15/SDWebImage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.guiyongdong.com/2017/01/15/SDWebImage源码分析/</id>
    <published>2017-01-15T07:14:25.000Z</published>
    <updated>2017-02-05T11:34:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDWebImage是一个开源的第三方库，它提供了UIImageView的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：</p>
<ol>
<li>提供UIImageView的一个分类，以支持网络图片的加载与缓存管理</li>
<li>一个异步的图片加载器</li>
<li>一个异步的内存+磁盘图片缓存</li>
<li>支持GIF图片</li>
<li>支持WebP图片</li>
<li>后台图片解压缩处理</li>
<li>确保同一个URL不会被反复加载</li>
<li>确保下载及缓存时，主线程不被堵塞</li>
</ol>
<p>从github上对SDWebImage使用情况可以看出，SDWebImage在图片下载及缓存的处理还是被认可的。在本文中，我们主要从源码的角度来分析一下SDWebImage的实现机制。讨论的内容将主要集中在图片的下载及缓存，而不包含对GIF图片及WebP图片的支持操作。不过在3.8.2版本以后，SDWebImage将会使用NSURLSession代替原来的NSURLConnection，主要是更新的是下载功能部分。具体变化可以看:<a href="https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImage-4.0-Migration-guide.md" target="_blank" rel="external">点这里</a>。目前截止到当前时间，最新的版本为4.0.0-beta2,这篇文章是在4.0.0-beta2基础上进行剖析。</p>
<a id="more"></a>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>在下载的过程中，程序会根据设置的不同的下载选项，执行不同的操作。下载选项由枚举<code>SDWebImageDownloaderOptions</code>定义，具体如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageDownloaderOptions) &#123;</div><div class="line">    SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下请求不使用NSURLCache，如果设置该选项，则以默认的缓存策略来使用NSURLCache</span></div><div class="line">    SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 如果从NSURLCache缓存中读取图片，则使用nil作为参数来调用完成block</span></div><div class="line">    SDWebImageDownloaderIgnoreCachedResponse = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    </div><div class="line">	<span class="comment">// 在iOS 4+系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外的时间来完成后台下载。如果后台任务终止，则操作会被取消</span></div><div class="line">    SDWebImageDownloaderContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie</span></div><div class="line">    SDWebImageDownloaderHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 允许不受信任的SSL证书。主要用于测试目的。</span></div><div class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 将图片下载放到高优先级队列中</span></div><div class="line">    SDWebImageDownloaderHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看出，这些选项主要涉及到下载的优先级、缓存、后台任务执行、cookie处理以及认证几个方面.</p>
<h4 id="下载顺序"><a href="#下载顺序" class="headerlink" title="下载顺序"></a>下载顺序</h4><p>SDWebImage的下载操作是按一定顺序来处理的，它定义了两种下载顺序，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SDWebImageDownloaderExecutionOrder) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 以队列的方式，按照先进先出的顺序下载。这是默认的下载顺序</span></div><div class="line">    SDWebImageDownloaderFIFOExecutionOrder,</div><div class="line">    </div><div class="line">    <span class="comment">// 以栈的方式，按照后进先出的顺序下载。</span></div><div class="line">    SDWebImageDownloaderLIFOExecutionOrder</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="下载管理器"><a href="#下载管理器" class="headerlink" title="下载管理器"></a>下载管理器</h4><p>SDWebImageDownloader下载管理器是一个单例5类，它主要负责图片的下载操作的管理。图片的下载是放在一个NSOperationQueue操作队列中来完成的，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;</div></pre></td></tr></table></figure>
<p>默认情况下，队列最大并发数是6.如果需要的话，我们可以通过SDWebImageDownloader类的<code>maxConcurrentDownloads</code>属性来修改。</p>
<p>所有下载操作的网络响应序列化处理是放在一个自定义的并行调度队列中来处理的，其声明及定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;</div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        ...</div><div class="line">        _barrierQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageDownloaderBarrierQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">		...</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个图片的下载都会对应一些回调操作，如下载进度回调，下载完成回调等，这些回调操作是以block形式来呈现，为此在<code>SDWebImageDownloader.h</code>中定义了几个block，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 下载进度</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageDownloaderProgressBlock)(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize);</div><div class="line"><span class="comment">// 下载完成</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageDownloaderCompletedBlock)(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished);</div><div class="line"><span class="comment">// Header过滤</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span> *(^SDWebImageDownloaderHeadersFilterBlock)(<span class="built_in">NSURL</span> *url, <span class="built_in">NSDictionary</span> *headers);</div></pre></td></tr></table></figure>
<p>图片下载的这些回调信息存储在SDWebImageDownloader类的<code>URLOperations</code>属性中，该属性是一个字典，key是图片的URL地址，value则是一个<code>SDWebImageDownloaderOperation</code>对象，包含每个图片的多组回调信息。由于我们允许多个图片同时下载，因此可能会有多个线程同时操作<code>URLOperations</code>属性。为了保证<code>URLOperations</code>操作（添加、删除）的线程安全性，SDWebImageDownloader将这些操作作为一个个任务放到barrierQueue队列中，并设置屏障来确保同一时间只有一个线程操作<code>URLOperations</code>属性，我们以添加操作为例，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123;</div><div class="line">    </div><div class="line">	...</div><div class="line">	</div><div class="line">    <span class="comment">// 1. 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLOperations进行操作</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];</div><div class="line">        <span class="keyword">if</span> (!operation) &#123;</div><div class="line">        	<span class="comment">//2. 处理第一次URL的下载</span></div><div class="line">            operation = createCallback();</div><div class="line">            <span class="keyword">self</span>.URLOperations[url] = operation;</div><div class="line"></div><div class="line">            __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</div><div class="line">            operation.completionBlock = ^&#123;</div><div class="line">              SDWebImageDownloaderOperation *soperation = woperation;</div><div class="line">              <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</div><div class="line">              <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</div><div class="line">                  [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</div><div class="line">              &#125;;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. 处理同一URL的同步下载请求的单个下载</span></div><div class="line">        <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line"></div><div class="line">        token = [SDWebImageDownloadToken new];</div><div class="line">        token.url = url;</div><div class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整个下载管理器对于下载请求的管理都是放在<code>downloadImageWithURL:options:progress:completed:</code>方法里面来处理的，该方法调用了上面所提到的<code>addProgressCallback:andCompletedBlock:forURL:createCallback:</code>方法来将请求的信息存入管理器中，同时在创建回调的block中创建新的操作，配置之后将其放入<code>downloadQueue</code>操作队列中，最后方法返回新创建的操作。其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">        <span class="comment">//超时时间</span></div><div class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</div><div class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">            timeoutInterval = <span class="number">15.0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 1. 创建请求对象，并根据options参数设置其属性</span></div><div class="line">        <span class="comment">// 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作</span></div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. 将操作加入到操作队列downloadQueue中</span></div><div class="line">        <span class="comment">// 如果是LIFO顺序，则将新的操作作为原队列中最后一个操作的依赖，然后将新操作设置为最后一个操作</span></div><div class="line">        [sself.downloadQueue addOperation:operation];</div><div class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，每个下载操作的超时时间可以通过downloadTimeout属性来设置，默认值为15秒。</p>
<h4 id="下载操作"><a href="#下载操作" class="headerlink" title="下载操作"></a>下载操作</h4><p>每个图片的下载操作都是一个Operation操作。。我们在上面分析过这个操作的创建及加入操作队列的过程。现在我们来看看单个操作的具体实现。</p>
<p>SDWebImage定义了一个协议，即SDWebImageOperation作为图片下载操作的基础协议。它只声明了一个cancel方法，用于取消操作。协议的具体声明如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageOperation</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line">- (<span class="keyword">void</span>)cancel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>SDWebImage还定义了一个下载协议，即SDWebImageDownloaderOperationInterface，它允许用户自定义下载操作，当然，SDWebImage也提供了自己的下载类，即<code>SDWebImageDownloaderOperation</code>，它继承自NSOperation，并采用了<code>SDWebImageOperation</code>和<code>SDWebImageDownloaderOperationInterface</code>协议。并且实现他们的代理方法。</p>
<p>对于图片的下载，SDWebImageDownloaderOperation完全依赖于URL加载系统中的NSURLSession类。我们先来分析一下SDWebImageDownloaderOperation类中对于图片实际数据的下载处理，即NSURLSessionDataDelegate和NSURLSessionDataDelegate各个代理方法的实现。(ps 有关NSURLSession类的具体介绍<a href="http://www.guiyongdong.com/2016/11/18/NSURLSession%E4%B8%8ENSURLConnection%E5%8C%BA%E5%88%AB/">请戳这里</a>)</p>
<p>我们前面说过SDWebImageDownloaderOperation类是继承自NSOperation类。它没有简单的实现main方法，而是采用更加灵活的start方法，以便自己管理下载的状态。</p>
<p>在start方法中，创建了我们下载所使用的NSURLSession对象，开启了图片的下载，同时抛出一个下载开始的通知。当然，如果我们期望下载在后台处理，则只需要配置我们的下载选项，使其包含SDWebImageDownloaderContinueInBackground选项。start方法的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    	<span class="comment">// 管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">            [<span class="keyword">self</span> reset];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">		...</div><div class="line"></div><div class="line">        <span class="built_in">NSURLSession</span> *session = <span class="keyword">self</span>.unownedSession;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.unownedSession) &#123;</div><div class="line">        		<span class="comment">//如果session为空，创建session</span></div><div class="line">            <span class="built_in">NSURLSessionConfiguration</span> *sessionConfig = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">            sessionConfig.timeoutIntervalForRequest = <span class="number">15</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.ownedSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfig</div><div class="line">                                                              delegate:<span class="keyword">self</span></div><div class="line">                                                         delegateQueue:<span class="literal">nil</span>];</div><div class="line">            session = <span class="keyword">self</span>.ownedSession;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//创建下载任务</span></div><div class="line">        <span class="keyword">self</span>.dataTask = [session dataTaskWithRequest:<span class="keyword">self</span>.request];</div><div class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//开启下载任务</span></div><div class="line">    [<span class="keyword">self</span>.dataTask resume];</div><div class="line">	</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</div><div class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">            progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>, <span class="keyword">self</span>.request.URL);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. 在主线程抛出下载开始通知</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先看看NSURLSessionDataDelegate代理的具体实现：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</div><div class="line">    <span class="comment">//接收到服务器响应</span></div><div class="line">    <span class="keyword">if</span> (![response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] || (((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode &lt; <span class="number">400</span> &amp;&amp; ((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode != <span class="number">304</span>)) &#123;</div><div class="line">    	<span class="comment">//如果服务器状态码正常，并且不是304，(因为304表示远程图片并没有改变，当前缓存的图片就可以使用)拿到图片的大小。并进度回调</span></div><div class="line">        <span class="built_in">NSInteger</span> expected = response.expectedContentLength &gt; <span class="number">0</span> ? (<span class="built_in">NSInteger</span>)response.expectedContentLength : <span class="number">0</span>;</div><div class="line">        <span class="keyword">self</span>.expectedSize = expected;</div><div class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">            progressBlock(<span class="number">0</span>, expected, <span class="keyword">self</span>.request.URL);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//根据返回数据大小创建一个数据Data容器</span></div><div class="line">        <span class="keyword">self</span>.imageData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:expected];</div><div class="line">        <span class="keyword">self</span>.response = response;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        		<span class="comment">//发送接收到服务器响应通知</span></div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">    	<span class="comment">//状态码错误</span></div><div class="line">        <span class="built_in">NSUInteger</span> code = ((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode;</div><div class="line">        </div><div class="line">        <span class="comment">//判断是不是304</span></div><div class="line">        <span class="keyword">if</span> (code == <span class="number">304</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> cancelInternal];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [<span class="keyword">self</span>.dataTask cancel];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        		<span class="comment">//发出停止下载通知</span></div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:<span class="keyword">self</span>];</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//错误回调</span></div><div class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode userInfo:<span class="literal">nil</span>]];</div><div class="line">			<span class="comment">//重置</span></div><div class="line">        [<span class="keyword">self</span> done];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (completionHandler) &#123;</div><div class="line">        completionHandler(<span class="built_in">NSURLSessionResponseAllow</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    <span class="comment">//1. 接收服务器返回数据 往容器中追加数据</span></div><div class="line">    [<span class="keyword">self</span>.imageData appendData:data];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//2. 获取已下载数据总大小</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = <span class="keyword">self</span>.imageData.length;</div><div class="line"></div><div class="line">        <span class="comment">// 3. 更新数据源，我们需要传入所有数据，而不仅仅是新数据</span></div><div class="line">        <span class="built_in">CGImageSourceRef</span> imageSource = <span class="built_in">CGImageSourceCreateWithData</span>((__bridge <span class="built_in">CFDataRef</span>)<span class="keyword">self</span>.imageData, <span class="literal">NULL</span>);</div><div class="line">        <span class="comment">// 4. 首次获取到数据时，从这些数据中获取图片的长、宽、方向属性值</span></div><div class="line">        <span class="keyword">if</span> (width + height == <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">            <span class="keyword">if</span> (properties) &#123;</div><div class="line">                <span class="built_in">NSInteger</span> orientationValue = <span class="number">-1</span>;</div><div class="line">                <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;height);</div><div class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelWidth);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;width);</div><div class="line">                val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyOrientation);</div><div class="line">                <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberNSIntegerType, &amp;orientationValue);</div><div class="line">                <span class="built_in">CFRelease</span>(properties);</div><div class="line"></div><div class="line">                <span class="comment">// 5. 当绘制到Core Graphics时，我们会丢失方向信息，这意味着有时候由initWithCGIImage创建的图片</span></div><div class="line">                <span class="comment">//    的方向会不对，所以在这边我们先保存这个信息并在后面使用。</span></div><div class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></div><div class="line">                orientation = [[<span class="keyword">self</span> <span class="keyword">class</span>] orientationFromPropertyValue:(orientationValue == <span class="number">-1</span> ? <span class="number">1</span> : orientationValue)];</div><div class="line"><span class="meta">#endif</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 6. 图片还未下载完成</span></div><div class="line">        <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; totalSize &lt; <span class="keyword">self</span>.expectedSize) &#123;</div><div class="line">            <span class="comment">// 7. 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张</span></div><div class="line">            <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></div><div class="line">            <span class="comment">// 8. 适用于iOS变形图像的解决方案。我的理解是由于iOS只支持RGB颜色空间，所以在此对下载下来的图片做个颜色空间转换处理。</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">                <span class="keyword">const</span> size_t partialHeight = <span class="built_in">CGImageGetHeight</span>(partialImageRef);</div><div class="line">                <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">                <span class="built_in">CGContextRef</span> bmContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, width * <span class="number">4</span>, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</div><div class="line">                <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">                <span class="keyword">if</span> (bmContext) &#123;</div><div class="line">                    <span class="built_in">CGContextDrawImage</span>(bmContext, (<span class="built_in">CGRect</span>)&#123;.origin.x = <span class="number">0.0</span>f, .origin.y = <span class="number">0.0</span>f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(bmContext);</div><div class="line">                    <span class="built_in">CGContextRelease</span>(bmContext);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                    partialImageRef = <span class="literal">nil</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">            <span class="comment">// 9. 对图片进行缩放、解码操作</span></div><div class="line">            <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line"><span class="meta">#if SD_UIKIT || SD_WATCH</span></div><div class="line">                <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:partialImageRef scale:<span class="number">1</span> orientation:orientation];</div><div class="line"><span class="meta">#elif SD_MAC</span></div><div class="line">                <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:partialImageRef size:<span class="built_in">NSZeroSize</span>];</div><div class="line"><span class="meta">#endif</span></div><div class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">                <span class="built_in">UIImage</span> *scaledImage = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">                    image = [<span class="built_in">UIImage</span> decodedImageWithImage:scaledImage];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    image = scaledImage;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">                </div><div class="line">                [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="literal">NO</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">CFRelease</span>(imageSource);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">        progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize, <span class="keyword">self</span>.request.URL);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，在下载完成或下载失败后，会调用NSURLSessionTaskDelegate的<code>- (void)URLSession: task: didCompleteWithError:</code>代理方法，并清除连接，并抛出下载停止的通知。如果下载成功，则会处理完整的图片数据，对其进行适当的缩放与解压缩操作，以提供给完成回调使用。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>下载的核心其实就是利用NSURLSession对象来加载数据。每个图片的下载都由一个Operation操作来完成，并将这些操作放到一个操作队列中。这样可以实现图片的并发下载。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>为了减少网络流量的消耗，我们都希望下载下来的图片缓存到本地，下次再去获取同一张图片时，可以直接从本地获取，而不再从远程服务器获取。这样做的一个好处是提升了用户体验，用户第二次查看同一幅图片时，能快速从本地获取图片直接呈现给用户。</p>
<p>SDWebImage提供了对图片缓存的支持，而该功能是由SDImageCache类完成的。该类负责处理内存缓存及一个可选的磁盘缓存。其中磁盘缓存的写操作是异步的，这样就不会对UI操作造成影响。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>另外说明，在4.0以后新添加一个缓存配置类<code>SDImageCacheConfig</code> ,主要是一些缓存策略的配置。其头文件定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">是否在缓存的时候解压缩，默认是YES 可以提高性能 但是会耗内存。 当使用SDWebImage 因为内存而崩溃 可以将其设置为NO</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 是否禁用 iCloud 备份 默认YES</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDisableiCloud;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 内存缓存  默认YES</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldCacheImagesInMemory;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 最大磁盘缓存时间 默认一周 单位秒</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxCacheAge;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 最大缓存容量 0 表示无限缓存  单位字节</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxCacheSize;</div></pre></td></tr></table></figure>
<h4 id="内存缓存及磁盘缓存"><a href="#内存缓存及磁盘缓存" class="headerlink" title="内存缓存及磁盘缓存"></a>内存缓存及磁盘缓存</h4><p>内存缓存的处理使用NSCache对象来实现的。NSCache是一个类似与集合的容器。它存储key-value对，这一点类似于NSDictionary类。我们通常使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序员来说不是紧要的，在内存紧张时会被丢弃。</p>
<p>磁盘缓存的处理则是使用NSFileManager对象来实现的。图片存储的位置是位于Caches文件夹中的default文件夹下。另外，SDImageCache还定义了一个串行队列，来异步存储图片。</p>
<p>内存缓存与磁盘缓存相关变量的声明及定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDImageCache</span> ()</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Properties</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSCache</span> *memCache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;</div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> ioQueue;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDImageCache</span> </span>&#123;</div><div class="line">    <span class="built_in">NSFileManager</span> *_fileManager;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns</div><div class="line">                       diskCacheDirectory:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)directory &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        <span class="built_in">NSString</span> *fullNamespace = [<span class="string">@"com.hackemist.SDWebImageCache."</span> stringByAppendingString:ns];</div><div class="line">        </div><div class="line">        <span class="comment">// 队列</span></div><div class="line">        _ioQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageCache"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">        <span class="comment">//缓存配置</span></div><div class="line">        _config = [[SDImageCacheConfig alloc] init];</div><div class="line">        </div><div class="line">        <span class="comment">// 内存缓存</span></div><div class="line">        _memCache = [[AutoPurgeCache alloc] init];</div><div class="line">        _memCache.name = fullNamespace;</div><div class="line"></div><div class="line">        <span class="comment">// 初始化磁盘缓存路径</span></div><div class="line">        <span class="keyword">if</span> (directory != <span class="literal">nil</span>) &#123;</div><div class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> makeDiskCachePath:ns];</div><div class="line">            _diskCachePath = path;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">dispatch_sync</span>(_ioQueue, ^&#123;</div><div class="line">            _fileManager = [<span class="built_in">NSFileManager</span> new];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>SDImageCache提供了大量方法来缓存、获取、移除、及清空图片。而对于每一个图片，为了方便地在内存或磁盘中对它进行这些操作，我们需要一个key值来索引它。在内存中，我们将其作为NSCache的key值，而在磁盘中，我们用作这个key作为图片的文件名。对于一个远程服务器下载的图片，其url实作为这个key的最佳选择了。我们在后面会看到这个key值得重要性。</p>
<h4 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h4><p>我们先来看看图片的缓存操作，该操作会在内存中放置一份缓存，而如果确定需要缓存到磁盘，则将磁盘缓存操作作为一个task放到串行队列中处理。在iOS中，会先检测图片是PNG还是JPEG，并将其转换为相应的图片数据，最后将数据写入到磁盘中(文件名是对key值做MD5摘要后的串)。缓存操作的基础方法是：<code>-storeImage:imageData:forKey:toDisk:completion:</code>,它的具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</div><div class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</div><div class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</div><div class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</div><div class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</div><div class="line">    <span class="keyword">if</span> (!image || !key) &#123;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 内存缓存 将其存入NSCache中，同时传入图片的消耗值</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</div><div class="line">        [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入ioQueue中</span></div><div class="line">    <span class="keyword">if</span> (toDisk) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">            <span class="built_in">NSData</span> *data = imageData;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (!data &amp;&amp; image) &#123;</div><div class="line">            		<span class="comment">//如果imageData为nil 需要确定图片是PNG还是JPEG。PNG图片容易检测，因为有一个唯一签名。PNG图像的前8个字节总是包含以下值：137 80 78 71 13 10 26 10	</span></div><div class="line">            		<span class="comment">//判断 图片是何种类型 使用 sd_imageFormatForImageData 来判断</span></div><div class="line">            		<span class="comment">// SDImageFormat 是一个枚举  其定义如下：</span></div><div class="line"><span class="comment">//                typedef NS_ENUM(NSInteger, SDImageFormat) &#123;</span></div><div class="line"><span class="comment">//                    SDImageFormatUndefined = -1,</span></div><div class="line"><span class="comment">//                    SDImageFormatJPEG = 0,</span></div><div class="line"><span class="comment">//                    SDImageFormatPNG,</span></div><div class="line"><span class="comment">//                    SDImageFormatGIF,</span></div><div class="line"><span class="comment">//                    SDImageFormatTIFF,</span></div><div class="line"><span class="comment">//                    SDImageFormatWebP</span></div><div class="line"><span class="comment">//                &#125;;</span></div><div class="line">                SDImageFormat imageFormatFromData = [<span class="built_in">NSData</span> sd_imageFormatForImageData:data];</div><div class="line">                <span class="comment">//根据图片类型 转成data</span></div><div class="line">                data = [image sd_imageDataAsFormat:imageFormatFromData];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 4. 创建缓存文件并存储图片</span></div><div class="line">            [<span class="keyword">self</span> storeImageDataToDisk:data forKey:key];</div><div class="line">            <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    completionBlock();</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="查询图片"><a href="#查询图片" class="headerlink" title="查询图片"></a>查询图片</h4><p>如果我们想在内存或磁盘中查询是否有key指定的图片，则可以分别使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//快速查询图片是否已经磁盘缓存 不返回图片 只做快速查询 异步操作</span></div><div class="line">- (<span class="keyword">void</span>)diskImageExistsWithKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key completion:(<span class="keyword">nullable</span> SDWebImageCheckCacheCompletionBlock)completionBlock;</div><div class="line"><span class="comment">//异步查询图片 不管是内存缓存还是磁盘缓存</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</div><div class="line"><span class="comment">//从内存中查询图片</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//从磁盘中查询图片</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//同步查询图片，不管是内存缓存还是磁盘缓存</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</div></pre></td></tr></table></figure>
<p>其实<code>- (nullable UIImage *)imageFromCacheForKey:(nullable NSString *)key</code>内部实现是调用了<code>- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key</code>和<code>- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key</code>方法，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">// 从缓存中查找图片</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 从磁盘中查找图片</span></div><div class="line">    image = [<span class="keyword">self</span> imageFromDiskCacheForKey:key];</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们再来看看异步查询图片的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// 1. 首先查看内存缓存，如果查找到，则直接回调doneBlock并返回</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//进行了是否是GIF的判断</span></div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2. 如果内存中没有，则在磁盘中查找。如果找到，则将其放到内存缓存，并调用doneBlock回调</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// do not call the completion if cancelled</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                <span class="comment">//进行内存缓存</span></div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="移除图片"><a href="#移除图片" class="headerlink" title="移除图片"></a>移除图片</h4><p>图片的移除操作则可以使用以下方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//从内存和磁盘中移除图片</span></div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion;</div><div class="line"><span class="comment">//从内存 或 可选磁盘中移除图片</span></div><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion;</div></pre></td></tr></table></figure>
<p>我们可以选择同时移除内存及磁盘上的图片,或者只移除内存中的图片。</p>
<h4 id="清理图片"><a href="#清理图片" class="headerlink" title="清理图片"></a>清理图片</h4><p>磁盘缓存图片的操作可以分为完全清空和部分清理。完全清空操作是直接把缓存的文件夹移除，部分清理是清理掉过时的旧图片，清空操作有以下方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">//清除内存缓存</span></div><div class="line">- (<span class="keyword">void</span>)clearMemory;</div><div class="line"></div><div class="line"><span class="comment">//完全清空磁盘缓存</span></div><div class="line">- (<span class="keyword">void</span>)clearDiskOnCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion;</div><div class="line"></div><div class="line"><span class="comment">//清空旧图片</span></div><div class="line">- (<span class="keyword">void</span>)deleteOldFilesWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</div></pre></td></tr></table></figure>
<p>而部分清理则是根据我们设定的一些参数来移除一些文件，这里主要有两个指标：文件的缓存有效期及最大缓存空间大小。文件的缓存有效期可以通过<code>SDImageCacheConfig</code>类的<code>maxCacheAge</code>属性来设置，默认是1周的时间。如果文件的缓存时间超过这个时间值，则将其移除。而最大缓存空间大小是通过<code>maxCacheSize</code>属性来设置的，如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。清理的操作在<code>-deleteOldFilesWithCompletionBlock:</code>方法中，其实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)deleteOldFilesWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line"></div><div class="line">        <span class="comment">// 1. 该枚举器预先获取缓存文件的有用的属性</span></div><div class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                                   includingPropertiesForKeys:resourceKeys</div><div class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></div><div class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.config.maxCacheAge];</div><div class="line">        <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *&gt; *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 2. 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作</span></div><div class="line">        <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</div><div class="line">            <span class="built_in">NSError</span> *error;</div><div class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</div><div class="line"></div><div class="line">            <span class="comment">// 3. 跳过文件夹</span></div><div class="line">            <span class="keyword">if</span> (error || !resourceValues || [resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 4. 移除早于有效期的老文件</span></div><div class="line">            <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</div><div class="line">            <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">                [urlsToDelete addObject:fileURL];</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 5. 存储文件的引用并计算所有文件的总大小，以备后用</span></div><div class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</div><div class="line">            cacheFiles[fileURL] = resourceValues;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</div><div class="line">            [_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//6.如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最老的文件</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.config.maxCacheSize) &#123;</div><div class="line">            <span class="comment">// 7. 以设置的最大缓存大小的一半作为清理目标</span></div><div class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.config.maxCacheSize / <span class="number">2</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 8. 按照最后修改时间来排序剩下的缓存文件</span></div><div class="line">            <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></div><div class="line">                                                                     usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</div><div class="line">                                                                         <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</div><div class="line">                                                                     &#125;];</div><div class="line"></div><div class="line">            <span class="comment">// 9. 删除文件，直到缓存总大小降到我们期望的大小</span></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</div><div class="line">                <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</div><div class="line">                    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = cacheFiles[fileURL];</div><div class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>以上分析了图片缓存操作，当然，除了上面讲的几个操作，SDWebImage类还提供了一些辅助方法。如获取缓存大小、缓存中图片的数量、判断缓存中是否存在某个key指定的图片。另外，SDWebImage类提供了一个单例方法的实现，所以我们可以将其当做单例对象来处理。</p>
<h3 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h3><p>在实际的运用中，我们并不直接使用SDWebImageDownloader类及SDImageCache类来执行图片的下载及缓存。为了方便用户的使用，SDWebImage提供了SDWebImageManager对象来管理图片的下载与缓存。而我们经常用到的诸如<code>UIImageView+WebCache</code>等控件的分类都是基于SDWebImageManager对象的，该对象将一个下载器和一个图片缓存绑定在一起，并对外提供两个只读属性来获取它们，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageManager</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> &lt;SDWebImageManagerDelegate&gt; delegate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDImageCache *imageCache;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) SDWebImageDownloader *imageDownloader;</div><div class="line">...</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从上面的代码中我们还可以看到一个delegate属性，它是一个<code>id &lt;SDWebImageManagerDelegate&gt;</code>对象。<code>SDWebImageManagerDelegate</code>声明了两个可选实现的方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 控制当图片在缓存中没有找到时，应该下载哪个图片</span></div><div class="line">- (<span class="built_in">BOOL</span>)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(<span class="built_in">NSURL</span> *)imageURL;</div><div class="line"><span class="comment">// 允许在图片已经被下载完成且被缓存到磁盘或内存前立即转换</span></div><div class="line">- (<span class="built_in">UIImage</span> *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(<span class="built_in">UIImage</span> *)image withURL:(<span class="built_in">NSURL</span> *)imageURL;</div></pre></td></tr></table></figure>
<p>这两个代理方法会在SDWebImageManager的<code>-downloadImageWithURL:options:progress:completed:</code>方法中调用，而这个方法是SDWebImageManager类的核心所在。我们来看看它具体的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 前面省略n行。主要作了如下处理：</span></div><div class="line">    <span class="comment">// 1. 判断url的合法性</span></div><div class="line">    <span class="comment">// 2. 创建SDWebImageCombinedOperation对象</span></div><div class="line">    <span class="comment">// 3. 查看url是否是之前下载失败过的</span></div><div class="line">    <span class="comment">// 4. 如果url为nil，或者在不可重试的情况下是一个下载失败过的url，则直接返回操作对象并调用完成回调</span></div><div class="line"></div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//先去缓存中查找图片，如果图片不存在  或者 当前图片的下载模式是 SDWebImageRefreshCached 开始下载</span></div><div class="line">        <span class="keyword">if</span> ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</div><div class="line">            ...</div><div class="line">            </div><div class="line">            <span class="comment">//下载</span></div><div class="line">            SDWebImageDownloadToken *subOperationToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    <span class="comment">// 操作被取消，则不做任务事情</span></div><div class="line">                    </div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                    <span class="comment">// 如果出错，则调用完成回调，并将url放入下载失败url数组中	</span></div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    ...</div><div class="line">                    </div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        <span class="comment">// 在全局队列中并行处理图片的缓存</span></div><div class="line">                        <span class="comment">// 首先对图片做个转换操作，该操作是代理对象实现的</span></div><div class="line">                        <span class="comment">// 然后对图片做缓存处理</span></div><div class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? <span class="literal">nil</span> : downloadedData) forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                            &#125;</div><div class="line">                            </div><div class="line">                            ...</div><div class="line">                        &#125;);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                        &#125;</div><div class="line">                        ...</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 下载完成并缓存后，将操作从队列中移除</span></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">                [<span class="keyword">self</span>.imageDownloader cancel:subOperationToken];</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            &#125;;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">            ...</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这个方法，我们没有做过多的解释。其主要就是下载图片并根据操作选项缓存图片。上面这个下载方法的操作选项参数是由枚举<code>SDWebImageOptions</code>来定义的，这个操作中的一些选项是与<code>SDWebImageDownloaderOptions</code>中的选项对应的，我们来看看这个<code>SDWebImageOptions</code>选项都有哪些：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageOptions) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，当URL下载失败时，URL会被列入黑名单，导致库不会再去重试，该标记用于禁用黑名单</span></div><div class="line">    SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，图片下载开始于UI交互，该标记禁用这一特性，这样下载延迟到UIScrollView减速时</span></div><div class="line">    SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 该标记禁用磁盘缓存</span></div><div class="line">    SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 该标记启用渐进式下载，图片在下载过程中是渐渐显示的，如同浏览器一下。</span></div><div class="line">    <span class="comment">// 默认情况下，图像在下载完成后一次性显示</span></div><div class="line">    SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 即使图片缓存了，也期望HTTP响应cache control，并在需要的情况下从远程刷新图片。</span></div><div class="line">    <span class="comment">// 磁盘缓存将被NSURLCache处理而不是SDWebImage，因为SDWebImage会导致轻微的性能下载。</span></div><div class="line">    <span class="comment">// 该标记帮助处理在相同请求URL后面改变的图片。如果缓存图片被刷新，则完成block会使用缓存图片调用一次</span></div><div class="line">    <span class="comment">// 然后再用最终图片调用一次</span></div><div class="line">    SDWebImageRefreshCached = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 在iOS 4+系统中，当程序进入后台后继续下载图片。这将要求系统给予额外的时间让请求完成</span></div><div class="line">    <span class="comment">// 如果后台任务超时，则操作被取消</span></div><div class="line">    SDWebImageContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES;来处理存储在NSHTTPCookieStore中的cookie</span></div><div class="line">    SDWebImageHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 允许不受信任的SSL认证</span></div><div class="line">    SDWebImageAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，图片下载按入队的顺序来执行。该标记将其移到队列的前面，</span></div><div class="line">    <span class="comment">// 以便图片能立即下载而不是等到当前队列被加载</span></div><div class="line">    SDWebImageHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 默认情况下，占位图片在加载图片的同时被加载。该标记延迟占位图片的加载直到图片已以被加载完成</span></div><div class="line">    SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</div><div class="line">    </div><div class="line">    <span class="comment">// 通常我们不调用动画图片的transformDownloadedImage代理方法，因为大多数转换代码可以管理它。</span></div><div class="line">    <span class="comment">// 使用这个票房则不任何情况下都进行转换。</span></div><div class="line">    SDWebImageTransformAnimatedImage = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>大家再看<code>-downloadImageWithURL:options:progress:completed:</code>，可以看到两个<code>SDWebImageOptions</code>与<code>SDWebImageDownloaderOptions</code>中的选项是如何对应起来的，在此不多做解释。</p>
<h3 id="视图扩展"><a href="#视图扩展" class="headerlink" title="视图扩展"></a>视图扩展</h3><p>我们在使用SDWebImage的时候，使用最多的是<code>UIImageView+WebCache</code>中的针对<code>UIImageView</code>的扩展方法，这些扩展方法将<code>UIImageView</code>与<code>WebCache</code>集成在一起，来让<code>UIImageView</code>对象拥有异步下载和缓存远程图片的能力。在4.0.0版本以后，给UIView新增了好多方法，其中最之前<code>UIImageView+WebCache</code>最核心的方法<code>-sd_setImageWithURL:placeholderImage:options:progress:completed:</code>，现在使用的是<code>UIView+WebCache</code>中新增的方法<code>sd_internalSetImageWithURL:placeholderImage:options:operationKey:setImageBlock:progress:completed:</code>,其使用<code>SDWebImageManager</code>单例对象下载并缓存图片，完成后将图片赋值给<code>UIImageView</code>对象的image属性，以使图片显示出来，其具体实现如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</div><div class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock &#123;</div><div class="line">    </div><div class="line">	...</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (url) &#123;</div><div class="line">        <span class="comment">// check if activityView is enabled or not</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> sd_showActivityIndicatorView]) &#123;</div><div class="line">            [<span class="keyword">self</span> sd_addActivityIndicator];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line">        <span class="comment">// 使用SDWebImageManager单例对象来下载图片</span></div><div class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">            [sself sd_removeActivityIndicator];</div><div class="line">            <span class="keyword">if</span> (!sself) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            dispatch_main_async_safe(^&#123;</div><div class="line">                <span class="keyword">if</span> (!sself) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                    <span class="comment">// 图片下载完后显示图片</span></div><div class="line">                    [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                    [sself sd_setNeedsLayout];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                        [sself sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                        [sself sd_setNeedsLayout];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了扩展<code>UIImageView</code>之外，SDWebImage还扩展了<code>UIView</code>、<code>UIButton</code>、<code>MKAnnotationView</code>等视图类，大家可以参考源码。</p>
<p>当然，如果不想使用这些扩展，则可以直接使用SDWebImageManager来下载图片，这也是很OK的。</p>
<h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><p>SDWebImage的主要任务就是图片的下载和缓存。为了支持这些操作，它主要使用了以下知识点：</p>
<ul>
<li><code>dispatch_barrier_sync</code>函数：该方法用于对操作设置等待，确保在执行完任务后才会执行后续操作。该方法常用于确保类的线程安全性操作。</li>
<li><code>NSMutableURLRequest</code>：用于创建一个网络请求对象，我们可以根据需要来配置请求报头等信息。</li>
<li><code>NSOperation</code>及<code>NSOperationQueue</code>：操作队列是Objective-C中一种高级的并发处理方法，现在它是基于GCD来实现的。相对于GCD来说，操作队列的优点是可以取消在任务处理队列中的任务，另外在管理操作间的依赖关系方面也容易一些。对SDWebImage中我们就看到了如何使用依赖将下载顺序设置成后进先出的顺序。(有兴趣的同学可以看看我这篇博客-&gt;<a href="http://www.guiyongdong.com/2016/09/18/%E8%81%8A%E4%B8%80%E8%81%8ANSOperation%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/">聊一聊NSOperation的那些事</a>)</li>
<li>NSURLSession：用于网络请求及响应处理。在iOS7.0后，苹果推出了一套新的网络请求接口，即NSURLSession类。(有兴趣的同学可以看看我这篇博客-&gt;<a href="http://www.guiyongdong.com/2016/11/18/NSURLSession%E4%B8%8ENSURLConnection%E5%8C%BA%E5%88%AB/">NSURLSession与NSURLConnection区别</a>)</li>
<li>开启一个后台任务。</li>
<li><code>NSCache</code>类：一个类似于集合的容器。它存储key-value对，这一点类似于NSDictionary类。我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。</li>
<li>清理缓存图片的策略：特别是最大缓存空间大小的设置。如果所有缓存文件的总大小超过这一大小，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间。</li>
<li>对图片的解压缩操作：这一操作可以查看<code>SDWebImageDecoder.m</code>中<code>+decodedImageWithImage</code>方法的实现。</li>
<li>对GIF图片的处理</li>
<li>对WebP图片的处理</li>
<li>对cell的重用机制的解决，利用runtime的关联对象，会为imageView对象关联一个下载列表，当tableView滑动时，imageView重设数据源（url）时，会cancel掉下载列表中所有的任务，然后开启一个新的下载任务。这样子就保证了只有当前可见的cell对象的imageView对象关联的下载任务能够回调，不会发生image错乱。</li>
</ul>
<p>感兴趣的同学可以深入研究一下这些知识点。当然，这只是其中一部分，更多的知识还有待大家去发掘。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SDWebImage是一个开源的第三方库，它提供了UIImageView的一个分类，以支持从远程服务器下载并缓存图片的功能。它具有以下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供UIImageView的一个分类，以支持网络图片的加载与缓存管理&lt;/li&gt;
&lt;li&gt;一个异步的图片加载器&lt;/li&gt;
&lt;li&gt;一个异步的内存+磁盘图片缓存&lt;/li&gt;
&lt;li&gt;支持GIF图片&lt;/li&gt;
&lt;li&gt;支持WebP图片&lt;/li&gt;
&lt;li&gt;后台图片解压缩处理&lt;/li&gt;
&lt;li&gt;确保同一个URL不会被反复加载&lt;/li&gt;
&lt;li&gt;确保下载及缓存时，主线程不被堵塞&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从github上对SDWebImage使用情况可以看出，SDWebImage在图片下载及缓存的处理还是被认可的。在本文中，我们主要从源码的角度来分析一下SDWebImage的实现机制。讨论的内容将主要集中在图片的下载及缓存，而不包含对GIF图片及WebP图片的支持操作。不过在3.8.2版本以后，SDWebImage将会使用NSURLSession代替原来的NSURLConnection，主要是更新的是下载功能部分。具体变化可以看:&lt;a href=&quot;https://github.com/rs/SDWebImage/blob/master/Docs/SDWebImage-4.0-Migration-guide.md&quot;&gt;点这里&lt;/a&gt;。目前截止到当前时间，最新的版本为4.0.0-beta2,这篇文章是在4.0.0-beta2基础上进行剖析。&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://www.guiyongdong.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://www.guiyongdong.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 运行时之六：拾遗</title>
    <link href="http://www.guiyongdong.com/2017/01/03/Objective-C-Runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E5%85%AD%EF%BC%9A%E6%8B%BE%E9%81%97/"/>
    <id>http://www.guiyongdong.com/2017/01/03/Objective-C-Runtime-运行时之六：拾遗/</id>
    <published>2017-01-03T07:08:47.000Z</published>
    <updated>2017-03-09T07:03:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇基本介绍了runtime中的大部分功能，包括对类与对象、成员变量与属性、方法与消息、分类与协议的处理。runtime大部分的功能都是围绕这几点来实现的。</p>
<p>本章的内容并不算重点，主要针对前文中对Objective-C Runtime Reference内容遗漏的地方做些补充。当然这并不能包含所有的内容。runtime还有许多内容。</p>
<a id="more"></a>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>在Objective-C中，如果我们需要在类的方法中调用父类的方法时，通常都会用到<code>super</code>，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span>	<span class="title">MyViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">	[<span class="keyword">super</span> viewDidLoad];</div><div class="line">	<span class="comment">// do something</span></div><div class="line">	...</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>如何使用super我们都知道。现在的问题是，它是如何工作的呢？</p>
<p>首先我们需要知道的是super与self不同。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。为了理解这一点，我们先来看看super的定义</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_super &#123; <span class="keyword">id</span> receiver; Class superClass; &#125;;</div></pre></td></tr></table></figure>
<p>这个结构体有两个成员：</p>
<ul>
<li>receiver：即消息的实际接收者</li>
<li>superClass：指针当前类的父类</li>
</ul>
<p>当我们使用super来接收消息时，编译器会生成一个objc_super结构体。就上面的例子而言，这个结构体的receiver就是MyViewController对象，与self相同；superClass指向MyViewController的父类UIViewController。</p>
<p>接下来，发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数，其声明如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> objc_msgSendSuper ( <span class="keyword">struct</span> objc_super *<span class="keyword">super</span>, SEL op, ... );</div></pre></td></tr></table></figure>
<p>该函数第一个参数即为前面生成的objc_super结构体，第二个参数是方法的selector。该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找viewDidLoad的selector，找到后以objc-&gt;receiver去调用这个selector，而此时的操作流程就是如下方式了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">objc_msgSend(objc_super-&gt;receiver, <span class="keyword">@selector</span>(viewDidLoad))</div></pre></td></tr></table></figure>
<p>由于objc_super-&gt;receiver就是self本身，所以该方法实际与下面这个调用是相同的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">objc_msgSend(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewDidLoad))</div></pre></td></tr></table></figure>
<p>为了便于理解，我们看以下实例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self class: %@"</span>, <span class="keyword">self</span>.class);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super class: %@"</span>, <span class="keyword">super</span>.class);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>调用MyClass的test方法后，其输出是：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">03.256</span> [<span class="number">824</span>:<span class="number">209297</span>] <span class="keyword">self</span> <span class="keyword">class</span>: MyClass</div><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">03.256</span> [<span class="number">824</span>:<span class="number">209297</span>] <span class="keyword">super</span> <span class="keyword">class</span>: MyClass</div></pre></td></tr></table></figure>
<p>从上例中可以看到，两者的输出都是MyClass。</p>
<h4 id="库相关操作"><a href="#库相关操作" class="headerlink" title="库相关操作"></a>库相关操作</h4><p>库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取所有加载的Objective-C框架和动态库的名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyImageNames ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取指定类所在动态库</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getImageName ( Class cls );</div><div class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyClassNamesForImage ( <span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure>
<p>通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"获取指定类所在动态库"</span>);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"UIView's Framework: %s"</span>, class_getImageName(<span class="built_in">NSClassFromString</span>(<span class="string">@"UIView"</span>)));</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"获取指定库或框架中所有类的类名"</span>);</div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** classes = objc_copyClassNamesForImage(class_getImageName(<span class="built_in">NSClassFromString</span>(<span class="string">@"UIView"</span>)), &amp;outCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, classes[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">2014-11-08 12:57:32.689 [747:184013] 获取指定类所在动态库</div><div class="line">2014-11-08 12:57:32.690 [747:184013] UIView's Framework: /System/Library/Frameworks/UIKit.framework/UIKit</div><div class="line">2014-11-08 12:57:32.690 [747:184013] 获取指定库或框架中所有类的类名</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: UIKeyboardPredictiveSettings</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: _UIPickerViewTopFrame</div><div class="line">2014-11-08 12:57:32.691 [747:184013] class name: _UIOnePartImageView</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewSelectionBar</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerWheelView</div><div class="line">2014-11-08 12:57:32.692 [747:184013] class name: _UIPickerViewTestParameters</div><div class="line">......</div></pre></td></tr></table></figure>
<h4 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h4><p>我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></div><div class="line">IMP imp_implementationWithBlock ( <span class="keyword">id</span> block );</div><div class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></div><div class="line"><span class="keyword">id</span> imp_getBlock ( IMP anImp );</div><div class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></div><div class="line"><span class="built_in">BOOL</span> imp_removeBlock ( IMP anImp );</div></pre></td></tr></table></figure>
<ul>
<li>imp_implementationWithBlock函数：参数block的签名必须是method_return_type ^(id self, method_args …)形式的。该方法能让我们使用block作为IMP。如下代码所示：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyRuntimeBlock</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span>	</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyRuntimeBlock</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">// 测试代码</span></div><div class="line">IMP imp = imp_implementationWithBlock(^(<span class="keyword">id</span> obj, <span class="built_in">NSString</span> *str) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str);</div><div class="line">&#125;);</div><div class="line">class_addMethod(MyRuntimeBlock.class, <span class="keyword">@selector</span>(testBlock:), imp, <span class="string">"v@:@"</span>);</div><div class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</div><div class="line">[runtime performSelector:<span class="keyword">@selector</span>(testBlock:) withObject:<span class="string">@"hello world!"</span>];</div></pre></td></tr></table></figure>
<p>输出结果是</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-09</span> <span class="number">14</span>:<span class="number">03</span>:<span class="number">19.779</span> [<span class="number">1172</span>:<span class="number">395446</span>] hello world!</div></pre></td></tr></table></figure>
<h4 id="弱引用操作"><a href="#弱引用操作" class="headerlink" title="弱引用操作"></a>弱引用操作</h4><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 加载弱引用指针引用的对象并返回</span></div><div class="line"><span class="keyword">id</span> objc_loadWeak ( <span class="keyword">id</span> *location );</div><div class="line"><span class="comment">// 存储__weak变量的新值</span></div><div class="line"><span class="keyword">id</span> objc_storeWeak ( <span class="keyword">id</span> *location, <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure>
<ul>
<li>objc_loadWeak函数：该函数加载一个弱指针引用的对象，并在对其做retain和autoreleasing操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用__weak变量的表达式中使用。</li>
<li>objc_storeWeak函数：该函数的典型用法是用于__weak变量做为赋值对象时。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>至此，本系列对runtime的整理已完结。当然这只是对runtime的一些基础知识的归纳，力图起个抛砖引玉的作用。还有许多关于runtime有意思东西还需要读者自己去探索发现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几篇基本介绍了runtime中的大部分功能，包括对类与对象、成员变量与属性、方法与消息、分类与协议的处理。runtime大部分的功能都是围绕这几点来实现的。&lt;/p&gt;
&lt;p&gt;本章的内容并不算重点，主要针对前文中对Objective-C Runtime Reference内容遗漏的地方做些补充。当然这并不能包含所有的内容。runtime还有许多内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C-Runtime运行时之五：协议与分类</title>
    <link href="http://www.guiyongdong.com/2016/12/18/Objective-C-Runtime%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%BA%94%EF%BC%9A%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%88%86%E7%B1%BB/"/>
    <id>http://www.guiyongdong.com/2016/12/18/Objective-C-Runtime运行时之五：协议与分类/</id>
    <published>2016-12-18T06:25:59.000Z</published>
    <updated>2017-03-09T07:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C中的分类允许我们通过一个类添加方法来扩充它（但是通过category不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。</p>
<p>Objective-C中的协议是普遍存在的接口定义方式，即在一个类中通过<code>@protocol</code>定义接口，在另外类中实现接口，这种接口定义方式也成为“delegation”模式，<code>@protocol</code>声明了可以被其他任何类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。</p>
<p>在本章中，我们来看看runtime对分类与协议的支持。</p>
<a id="more"></a>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><h5 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h5><p>Category是表示一个指向分类的结构体的指针，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_category *Category;</div><div class="line"><span class="keyword">struct</span> objc_category &#123;</div><div class="line">    <span class="keyword">char</span> *category_name                          OBJC2_UNAVAILABLE;	<span class="comment">// 分类名</span></div><div class="line">    <span class="keyword">char</span> *class_name                             OBJC2_UNAVAILABLE;	<span class="comment">// 分类所属的类名</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list *instance_methods    OBJC2_UNAVAILABLE;	<span class="comment">// 实例方法列表</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list *class_methods       OBJC2_UNAVAILABLE;	<span class="comment">// 类方法列表</span></div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols         OBJC2_UNAVAILABLE;	<span class="comment">// 分类所实现的协议列表</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个结构体主要包含了分类定义的实例方法与类方法，其中<code>instance_methods</code>列表是元类方法列表的一个子集。</p>
<h5 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h5><p>Protocol的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object Protocol;</div></pre></td></tr></table></figure>
<p>我们可以看到，Protocol其实就是一个对象结构体。</p>
<h5 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h5><p>Runtime并没有在<code>&lt;objc/runtime.h&gt;</code>头文件中提供针对分类的操作函数。因为这些分类中的信息都包含在<code>objc_class</code>中，我们可以通过针对<code>objc_class</code>的操作函数来获取分类的信息。如下里所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)method1;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span></span></div><div class="line">- (<span class="keyword">void</span>)method1 &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"测试objc_class中的方法列表是否包含分类中的方法"</span>);</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</div><div class="line">    Method method = methodList[i];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_getName(method_getName(method));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"RuntimeCategoryClass's method: %s"</span>, name);</div><div class="line">    <span class="keyword">if</span> (strcmp(name, sel_getName(<span class="keyword">@selector</span>(method2)))) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"分类方法method2在objc_class的方法列表中"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其输出是：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">2014-11-08 10:36:39.213 [561:151847] 测试objc_class中的方法列表是否包含分类中的方法</div><div class="line">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method2</div><div class="line">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass's method: method1</div><div class="line">2014-11-08 10:36:39.215 [561:151847] 分类方法method2在objc_class的方法列表中</div></pre></td></tr></table></figure>
<p>而对于Protocol，runtime提供了一系列函数来对其进行操作，这些函数包括：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回指定的协议</span></div><div class="line">Protocol * objc_getProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></div><div class="line">Protocol ** objc_copyProtocolList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 创建新的协议实例</span></div><div class="line">Protocol * objc_allocateProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 在运行时中注册新创建的协议</span></div><div class="line"><span class="keyword">void</span> objc_registerProtocol ( Protocol *proto );</div><div class="line"><span class="comment">// 为协议添加方法</span></div><div class="line"><span class="keyword">void</span> protocol_addMethodDescription ( Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></div><div class="line"><span class="keyword">void</span> protocol_addProtocol ( Protocol *proto, Protocol *addition );</div><div class="line"><span class="comment">// 为协议添加属性</span></div><div class="line"><span class="keyword">void</span> protocol_addProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"><span class="comment">// 返回协议名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * protocol_getName ( Protocol *p );</div><div class="line"><span class="comment">// 测试两个协议是否相等</span></div><div class="line"><span class="built_in">BOOL</span> protocol_isEqual ( Protocol *proto, Protocol *other );</div><div class="line"><span class="comment">// 获取协议中指定条件的方法的方法描述数组</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></div><div class="line"><span class="keyword">struct</span> objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</div><div class="line"><span class="comment">// 获取协议中的属性列表</span></div><div class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 获取协议的指定属性</span></div><div class="line">objc_property_t protocol_getProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</div><div class="line"><span class="comment">// 获取协议采用的协议</span></div><div class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></div><div class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</div></pre></td></tr></table></figure>
<ul>
<li><code>objc_getProtocol</code>函数，需要注意的是如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是nil。</li>
<li><code>objc_copyProtocolList</code>函数，获取的数值需要使用free来释放。</li>
<li><code>objc_allcateProtocol</code>函数，如果同名的协议已经存在，则返回nil.</li>
<li><code>objc_registerProtocol</code>函数，创建一个新的协议后，必须调用该函数以在运行时钟注册新的协议。协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议。</li>
</ul>
<p>需要强调的是，协议一旦注册后就不能修改，即无法再通过调用<code>protocol_addMethodDescription</code>、<code>protocol_addProtocol</code>和<code>protocol_addProperty</code>往协议中添加方法等。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Runtime并没有提供过多的函数来处理分类。对于协议，我们可以动态地创建协议，并向其添加方法、属性及继承的协议，并在运行时动态地获取这些信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C中的分类允许我们通过一个类添加方法来扩充它（但是通过category不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。&lt;/p&gt;
&lt;p&gt;Objective-C中的协议是普遍存在的接口定义方式，即在一个类中通过&lt;code&gt;@protocol&lt;/code&gt;定义接口，在另外类中实现接口，这种接口定义方式也成为“delegation”模式，&lt;code&gt;@protocol&lt;/code&gt;声明了可以被其他任何类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。&lt;/p&gt;
&lt;p&gt;在本章中，我们来看看runtime对分类与协议的支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 运行时之四：Method Swizzling</title>
    <link href="http://www.guiyongdong.com/2016/12/09/Objective-C-Runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E5%9B%9B%EF%BC%9AMethod-Swizzling/"/>
    <id>http://www.guiyongdong.com/2016/12/09/Objective-C-Runtime-运行时之四：Method-Swizzling/</id>
    <published>2016-12-09T05:02:51.000Z</published>
    <updated>2017-03-09T07:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>理解<code>Method Swizzling</code>是学习Runtime机制的一个很好的机会。<code>Method Swizzling</code>是改变一个<code>selector</code>的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中<code>selector</code>对应的函数，来修改方法的实现。</p>
<a id="more"></a>
<p>例如，我们想跟踪在程序中每一个ViewController展示给用户的次数：当然，我们可以在每个ViewController的viewDidAppear中添加跟踪代码，但是这太过麻烦，需要在每个ViewController中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController，UITableController，UINavigationController及其他UIKit中ViewController的子类，这样会产生许多重复的代码。</p>
<p>这种情况下，我们就可以使用<code>Method Swizzling</code>，如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></div><div class="line">+ (<span class="keyword">void</span>)load &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];         </div><div class="line">        <span class="comment">// When swizzling a class method, use the following:</span></div><div class="line">        <span class="comment">// Class class = object_getClass((id)self);</span></div><div class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</div><div class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</div><div class="line">        <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</div><div class="line">                originalSelector,</div><div class="line">                method_getImplementation(swizzledMethod),</div><div class="line">                method_getTypeEncoding(swizzledMethod));</div><div class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</div><div class="line">            class_replaceMethod(<span class="keyword">class</span>,</div><div class="line">                swizzledSelector,</div><div class="line">                method_getImplementation(originalMethod),</div><div class="line">                method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark - Method Swizzling</span></div><div class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这里，我们通过<code>Method Swizzling</code>修改了UIViewController的<code>@selector(viewWillAppear:)</code>对应的函数指针，使其实现指向了我们自定义的<code>xxx_viewWillAppear</code>的实现。这样，当UIViewController及其子类的对象调用<code>viewWillAppear</code>时，都会打印一条日志信息。</p>
<p>上面的例子很好地展示了使用<code>Method Swizlling</code>来一个类中注入一些我们新的操作。当然，还有许多场景可以使用<code>Mehtod Swizlling</code>，在此不多举例。在此我们说说使用<code>method Swizlling</code>需要注意的一些问题。</p>
<h3 id="Swizzling应该总是在-load中执行"><a href="#Swizzling应该总是在-load中执行" class="headerlink" title="Swizzling应该总是在+load中执行"></a>Swizzling应该总是在+load中执行</h3><p>在Objective-C中，运行时会自动调用每个类的两个方法。<code>+load</code><em>会在类初始加载时调用</em>，<code>+initialize</code><em>会在第一次调用类的类方法或实例方法之前被调用</em>。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。</p>
<h3 id="Swizzling应该总是在dispatch-once中执行"><a href="#Swizzling应该总是在dispatch-once中执行" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a>Swizzling应该总是在dispatch_once中执行</h3><p>与上面相同，因为<code>swizzling</code>会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的<code>dispatch_once</code>可以确保这种行为，我们应该将其作为<code>method swizzling</code>的最佳实践。</p>
<h3 id="选择器、方法与实现"><a href="#选择器、方法与实现" class="headerlink" title="选择器、方法与实现"></a>选择器、方法与实现</h3><p>在Objective-C中，选择器(<code>selector</code>)、方法(<code>method</code>)和实现(<code>implementation</code>)是运行时中一个特殊点，虽然在一般情况下，这些术语更多的是用在消息发送的过程描述中。</p>
<p>以下是<code>Objective-C Runtime Reference</code>中的对这几个术语一些描述：</p>
<ul>
<li><code>Selector(typedef struct objc_selector *SEL)</code>：用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。</li>
<li><code>Method(typedef struct objc_method *Method)</code>：在类定义中表示方法的类型</li>
<li><code>Implementation(typedef id (*IMP)(id, SEL, ...))</code>：这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。</li>
</ul>
<p>理解这几个术语之间的关系最好的方式是：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(Method)，其中key是一个特定名称，即选择器(SEL)，其对应一个实现(IMP)，即指向底层C函数的指针。</p>
<p>为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。</p>
<h3 id="调用-cmd"><a href="#调用-cmd" class="headerlink" title="调用_cmd"></a>调用_cmd</h3><p>我们回过头来看看前面新的方法的实现代码：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated];</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的<code>[self xxx_viewWillAppear:animated]</code>已经被重新指定到UIViewController类的<code>-viewWillAppear:</code>中。在这种情况下，不会产生无限循环。不过如果我们调用的是<code>[self viewWillAppear:animated]</code>，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为<code>xxx_viewWillAppear:</code>了。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Swizzling通常被称作是一种黑魔法，容易产生不可预知的行为和无法预见的后果。虽然它不是最安全的，但如果遵从以下几点预防措施的话，还是比较安全的：</p>
<ol>
<li>总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。</li>
<li>避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。</li>
<li>明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读<code>Objective-C Runtime Reference</code>和查看<code>&lt;objc/runtime.h&gt;</code>头文件以了解事件是如何发生的。</li>
<li>小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解&lt;code&gt;Method Swizzling&lt;/code&gt;是学习Runtime机制的一个很好的机会。&lt;code&gt;Method Swizzling&lt;/code&gt;是改变一个&lt;code&gt;selector&lt;/code&gt;的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中&lt;code&gt;selector&lt;/code&gt;对应的函数，来修改方法的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 运行时之三：方法与消息</title>
    <link href="http://www.guiyongdong.com/2016/11/25/Objective-C-Runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B6%88%E6%81%AF/"/>
    <id>http://www.guiyongdong.com/2016/11/25/Objective-C-Runtime-运行时之三：方法与消息/</id>
    <published>2016-11-25T06:05:08.000Z</published>
    <updated>2017-03-09T07:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。</p>
<a id="more"></a>
<h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>SEL又叫选择器，是表示一个方法的<code>selector</code>的指针，其定义如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure></p>
<p><code>objc_selector</code>结构体的详细定义没有在<code>&lt;objc/runtime.h&gt;</code>头文件中找到。方法的<code>selector</code>用于表示运行时方法的名字。Objective-C在编译时，会根据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的标识)，这个标识就是<code>SEL</code>。如下代码所示:<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">SEL sel1 = <span class="keyword">@selector</span>(method1);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"sel : %p"</span>, sel1);</div></pre></td></tr></table></figure></p>
<p>上面的输出结果为：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-30</span> <span class="number">18</span>:<span class="number">40</span>:<span class="number">07.518</span> RuntimeTest[<span class="number">52734</span>:<span class="number">466626</span>] sel : <span class="number">0x100002d72</span></div></pre></td></tr></table></figure></p>
<p>两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的SEL就是一样的，每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行。相同的方法只能对应一个SEL。这也就导致Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。如果某个类中定义以下两个方法：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">int</span>)width;</div><div class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)width;</div></pre></td></tr></table></figure></p>
<p>这样的定义被认为是一种编译错误，所以我们不能像C++,C#那样。而是需要像下面这样来声明：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)setWidthIntValue:(<span class="keyword">int</span>)width;</div><div class="line">-(<span class="keyword">void</span>)setWidthDoubleValue:(<span class="keyword">double</span>)width;</div></pre></td></tr></table></figure></p>
<p>当然，不同的类可以拥有相同的Selector，这个没有问题。不同的类的实例对象执行相同的Selector时，会在各自的方法列表中根据Selector去寻找自己对应的IMP。</p>
<p>工程中的所有SEL组成一个Set集合，Set的特点就是唯一，因此SEL是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无与伦比！但是，一个问题，就是数据增多会增大hash冲突而导致的性能下降(或是没有冲突，因为也可能用的是prefecthash)。但不管使用什么样的方法加速，如果能够将总量减少（多个方法可能对应同一个SEL）。那将是最犀利的方法。那么，我们就不难理解，为什么SEL仅仅是函数名了。</p>
<p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>
<p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL：</p>
<ul>
<li><code>sel_registerName</code>函数</li>
<li>Objective-C编译器提供的<code>@selector()</code></li>
<li><code>NSSelectorFromString()</code>方法</li>
</ul>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...)</div></pre></td></tr></table></figure></p>
<p>这个函数使用当前CPU架构实现的标准C调用约定。第一个参数是指向self的指针（如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针），第二个参数是方法选择器（selector），接下来是方法的实际参数列表。</p>
<p>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每一个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<p>通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>介绍完SEL和IMP，我们就可以来讲讲Method了。Method用于表示类定义的方法，定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</div><div class="line"><span class="keyword">struct</span> objc_method &#123;</div><div class="line">    SEL method_name                	OBJC2_UNAVAILABLE;	<span class="comment">// 方法名</span></div><div class="line">    <span class="keyword">char</span> *method_types                	OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp             			OBJC2_UNAVAILABLE;	<span class="comment">// 方法实现</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有个SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。具体的操作流程我们将在下面讨论。</p>
<h5 id="objc-method-description"><a href="#objc-method-description" class="headerlink" title="objc_method_description"></a>objc_method_description</h5><p><code>objc_method_description</code>定义了一个Objective-C方法，其定义如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_method_description &#123; SEL name; <span class="keyword">char</span> *types; &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="方法相关操作函数"><a href="#方法相关操作函数" class="headerlink" title="方法相关操作函数"></a>方法相关操作函数</h3><p>Runtime提供了一系列的方法来处理与方法相关的操作。包括方法本身及SEL。本节我们介绍一下这些函数。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法操作相关函数包括以下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 调用指定方法的实现</span></div><div class="line"><span class="keyword">id</span> method_invoke ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></div><div class="line"><span class="keyword">void</span> method_invoke_stret ( <span class="keyword">id</span> receiver, Method m, ... );</div><div class="line"><span class="comment">// 获取方法名</span></div><div class="line">SEL method_getName ( Method m );</div><div class="line"><span class="comment">// 返回方法的实现</span></div><div class="line">IMP method_getImplementation ( Method m );</div><div class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * method_getTypeEncoding ( Method m );</div><div class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyReturnType ( Method m );</div><div class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">char</span> * method_copyArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index );</div><div class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getReturnType ( Method m, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回方法的参数的个数</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments ( Method m );</div><div class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></div><div class="line"><span class="keyword">void</span> method_getArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len );</div><div class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></div><div class="line"><span class="keyword">struct</span> objc_method_description * method_getDescription ( Method m );</div><div class="line"><span class="comment">// 设置方法的实现</span></div><div class="line">IMP method_setImplementation ( Method m, IMP imp );</div><div class="line"><span class="comment">// 交换两个方法的实现</span></div><div class="line"><span class="keyword">void</span> method_exchangeImplementations ( Method m1, Method m2 );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数<code>receiver</code>不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><code>method_getName</code>函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li>
<li><code>method_getReturnType</code>函数，类型字符串会被拷贝到dst中。</li>
<li><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</li>
</ul>
<h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h4><p>选择器相关的操作函数包括：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * sel_getName ( SEL sel );</div><div class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></div><div class="line">SEL sel_registerName ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法</span></div><div class="line">SEL sel_getUid ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</div><div class="line"><span class="comment">// 比较两个选择器</span></div><div class="line"><span class="built_in">BOOL</span> sel_isEqual ( SEL lhs, SEL rhs );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>sel_registerName</code>函数：在我们将一个方法添加到类定义时，我们必须在<code>Objective Runtime</code>系统中注册一个方法名以获取方法的选择器。</li>
</ul>
<h3 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h3><p>在Objective-C中，消息直到运行时在绑定到方法实现上。编译器会将消息表达式<code>[receiver message]</code>转化为一个消息函数的调用，即<code>objc_msgSend</code>。这个函数将消息接收者和方法名作为其基础参数，如以下所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">objc_msgSend(receiver, selector)</div></pre></td></tr></table></figure></p>
<p>如果消息中还有其他参数，则该方法的形式如下所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</div></pre></td></tr></table></figure></p>
<p>这个函数完成了动态绑定的所有事情：</p>
<ol>
<li>首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以需要依赖接收者的类来找到确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ol>
<p>消息的关键在于我们前面章节讨论过的结构体<code>Objc_class</code>，这个结构体有两个字段是我们在消息分发的关注的：</p>
<ol>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即<code>methodLists</code></li>
</ol>
<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中isa指针也会被初始化，让对象可以访问类及类的继承体系。</p>
<p>下图演示了这样一个消息的基本框架：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/runtime1.png?raw=true"><br></div>

<p>当消息发送给一个对象时，<code>objc_msgSend</code>通过对象的isa指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到selector，则通过<code>objc_msgSend</code>结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的selector。依此，会一直沿用类的继承体系到达NSObject类。一旦定位到selector，函数就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到selector，则会走消息转发流程，这个我们在后面讨论。</p>
<p>为了加速消息的处理，运行时系统缓存使用过的selector及对应的方法的地址。这点我们在前面讨论对，不再重复。</p>
<h4 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h4><p><code>objc_msgSend</code>有两个隐藏参数：</p>
<ol>
<li>消息接收对象</li>
<li>方法的selector</li>
</ol>
<p>这两个参数为方法的实现提供了调用者的信息。之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明。它们是在编译器被插入实现代码的。</p>
<p>虽然这些参数没有显示声明，但在代码中仍然可以引用它们。我们可以使用self来引用接收者对象，使用<code>_cmd</code>来引用选择器。代码如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- strange</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span>  target = getTheReceiver();</div><div class="line">    SEL method = getTheMethod();</div><div class="line">    <span class="keyword">if</span> ( target == <span class="keyword">self</span> || method == _cmd )</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> [target performSelector:method];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，这两个参数我们用的比较多的是self,<code>_cmd</code>在实际中用的比较少。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>Runtime中方法的动态绑定让我们写代码时更具灵活性。如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来的那么直接。当然，方法的缓存一定程度上解决了这一问题。</p>
<p>我们上面提到过，我们想要避开这种动态绑定方法，我们可以获取方法实现的地址，然后想调用函数一样来直接调用它。特别是当我们需要一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>
<p>NSObject类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p>
<p>我们通过以下代码来看看<code>methodForSelector:</code>的使用：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">1000</span> ; i++)</div><div class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</div></pre></td></tr></table></figure></p>
<p>这里需要注意的就是函数指针的前两个参数必须是id和SEL。</p>
<p>当然这种方式只适合于在类似于for循环这种情况下频繁调用同一方法，以提高性能的情况。另外，<code>methodForSelector:</code>是由Cocoa运行时提供的；它不是Objective-C语言的特性。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>当一个对象能接收到一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定的消息时，又会发生什么事呢？默认情况下，如果是以<code>[object message]</code>的方式调用方法，如果<code>object</code>无法响应<code>message</code>消息时，编译器会报错。但如果是以<code>perfrom...</code>的形式来调用，则需要等到运行时才能确定object是否能接收<code>message</code>消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(method)]) &#123;</div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method)];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过，我们这边想讨论下不使用<code>respondsToSelector:</code>判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓’<em>消息转发(message forwarding)</em>‘机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，通过控制台，我们可以看到以下异常信息：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940</div><div class="line">*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[SUTRuntimeMethod method]: unrecognized selector sent to instance 0x100111940'</div></pre></td></tr></table></figure></p>
<p>这段异常信息实际上是由NSObject的<code>doesNotRecognizeSelector</code>方法抛出来的。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>下面我们详细讨论一下这三个步骤。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>对象在接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)。在这个方法中，我们有机会为该未知消息新增一个“处理方法”。不过使用该方法的前提是我们已经实现了该“处理方法”，只需要在运行时通过<code>class_addMethod</code>函数动态添加到类里面就可以了。如下代码所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line">	</div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</div><div class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method1"</span>]) &#123;</div><div class="line">        class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">"@:"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过这种方案更多的是为了实现<code>@dynamic</code>属性。</p>
<h4 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h4><p>如果在上一步无法处理消息，则Runtime会继续调用以下方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>
<p>如果一个对象实现了这个方法，并返回一个非nil得结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是<code>self</code>吱声，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理<code>aSelector</code>，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其他对象处理该消息，我们便可以用这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。如下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethodHelper</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethodHelper</span></span></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %p"</span>, <span class="keyword">self</span>, _cmd);</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SUTRuntimeMethod</span> () </span>&#123;</div><div class="line">    SUTRuntimeMethodHelper *_helper;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SUTRuntimeMethod</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)object &#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</div><div class="line">        _helper = [[SUTRuntimeMethodHelper alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)test &#123;</div><div class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method2)];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"forwardingTargetForSelector"</span>);</div><div class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(aSelector);</div><div class="line">    <span class="comment">// 将消息转发给_helper来处理</span></div><div class="line">    <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@"method2"</span>]) &#123;</div><div class="line">        <span class="keyword">return</span> _helper;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这一步适合于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h4 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h4><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</div></pre></td></tr></table></figure></p>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其他对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在<code>anInvocation</code>中，包括<code>selector</code>,目标（<code>target</code>）和参数。我们可以在<code>forwardInvocation</code>方法中选择将消息转发给其他对象。</p>
<p><code>forwardInvocation</code>方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在<code>anInvocation</code>中的消息对象。这个对象不需要能处理所有未知消息。</li>
<li>使用<code>anInvocation</code>作为参数，将消息发送给选中的对象。<code>anInvocation</code>将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去出发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重新写以下方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector</div></pre></td></tr></table></figure></p>
<p>消息转发机制使用从这个方法中获取的信息来创建<code>NSInvocation</code>对象。因此我们必须重写这个方法，为给定的selector提供一个合适的签名方法。</p>
<p>完整的示例如下所示：<br><figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</div><div class="line">    <span class="keyword">if</span> (!signature) &#123;</div><div class="line">        <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</div><div class="line">            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> signature;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</div><div class="line">    <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:_helper];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NSObject的<code>forwardInvocation:</code>方法实现只是简单调用了<code>doesNotRecognizeSelector:</code>方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>从某种意义上来讲，<code>forwardInvocation:</code>就像一个未知消息的分发中心，将这些未知的消息转发给其他对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>
<h4 id="消息转发与多重继承"><a href="#消息转发与多重继承" class="headerlink" title="消息转发与多重继承"></a>消息转发与多重继承</h4><p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</p>
<p>不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如<code>respondsToSelector:</code>和<code>isKindOfClass:</code>只能用于继承体系，而不能用于转发链。便如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span> ( [<span class="keyword">super</span> respondsToSelector:aSelector])</div><div class="line">		<span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">/* Here, test whether the aSelector message can     *</span></div><div class="line">		 * be forwarded to another object and whether that  *</div><div class="line">		 * object can respond to it. Return YES if it can.  */</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">NO</span>; 	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在此，我们已经了解了Runtime中消息发送和转发的基本机制。这也是Runtime的强大之处，通过它，我们可以为程序增加很多动态的行为，虽然我们在实际开发中很少直接使用这些机制(如直接调用objc_msgSend)，但了解它们有助于我们更多地去了解底层的实现。其实在实际的编码过程中，我们也可以灵活地使用这些机制，去实现一些特殊的功能，如hook操作等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们讨论了Runtime中对类和对象的处理，及对成员变量与属性的处理。这一章，我们就要开始讨论Runtime中最有意思的一部分：消息处理机制。我们将详细讨论消息的发送及消息的转发。不过在讨论消息之前，我们先来了解一下与方法相关的一些内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime运行时之二：成员变量与属性</title>
    <link href="http://www.guiyongdong.com/2016/11/24/Objective-C-Runtime%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%BA%8C-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.guiyongdong.com/2016/11/24/Objective-C-Runtime运行时之二-成员变量与属性/</id>
    <published>2016-11-24T07:39:47.000Z</published>
    <updated>2017-03-09T07:03:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面一篇文章中，我们介绍了Runtime中与类和对象相关的内容，从这章开始，我们将讨论类实现细节相关的内容，主要包括类中成员变量，属性，方法，协议与分类的实现。</p>
<p>本章的主要内容将聚集在Runtime对成员变量与属性的处理。在讨论之前，我们先介绍一个重要的概念：类型编码。</p>
<a id="more"></a>
<h3 id="类型编码-Type-Encoding"><a href="#类型编码-Type-Encoding" class="headerlink" title="类型编码(Type Encoding)"></a>类型编码(Type Encoding)</h3><p>作为对Runtime的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起。这种编码方案在其他情况下也是非常有用的，因此我们可以使用@encode编译器指令来获取它。当给定一个类型时，@encode返回这个类型的字符串编码。这些类型可以是诸如int、指针这样的基本类型，也可以是结构体、类等类型。事实上，任何可以作为sizeof()操作参数的类型都可以    用于@encode()。</p>
<p>一个数组的类型编码位于方括号中；其中包含数组元素的个数及元素类型。如下所示：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">float</span> a[] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>&#125;;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"array encoding type: %s"</span>, <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(a)));</div></pre></td></tr></table></figure></p>
<p>输出是：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-28</span> <span class="number">11</span>:<span class="number">44</span>:<span class="number">54.731</span> RuntimeTest[<span class="number">942</span>:<span class="number">50791</span>] array encoding type: [<span class="number">3</span>f]</div></pre></td></tr></table></figure></p>
<p>其他类型可参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">Type Encoding</a>,在此不细说。</p>
<p>对于属性而言，还会有一些特殊的类型编码，以表明属性是只读、拷贝、retain等等，详情可以参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW6" target="_blank" rel="external">Property Type String</a></p>
<h3 id="成员变量、属性"><a href="#成员变量、属性" class="headerlink" title="成员变量、属性"></a>成员变量、属性</h3><p>Runtime中关于成员变量和属性的相关数据结构并不多，只有三个，并且都很简单。不过还有个非常实用但可能经常被忽视的特性，即关联对象，我们将在这小节中详细讨论。</p>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><h5 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h5><p>Ivar是表示实例变量的类型，其实际是指向objc_ivar结构体的指针，其定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</div><div class="line"><span class="keyword">struct</span> objc_ivar &#123;</div><div class="line">    <span class="keyword">char</span> *ivar_name              OBJC2_UNAVAILABLE;	<span class="comment">// 变量名</span></div><div class="line">    <span class="keyword">char</span> *ivar_type             	OBJC2_UNAVAILABLE;	<span class="comment">// 变量类型</span></div><div class="line">    <span class="keyword">int</span> ivar_offset            		OBJC2_UNAVAILABLE;	<span class="comment">// 基地址偏移字节</span></div><div class="line"><span class="meta">#ifdef __LP64__</span></div><div class="line">    <span class="keyword">int</span> space                 		OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h5><p>objc_property_t是表示Objective-C声明的属性的类型，其实际是指向objc_property结构体的指针，其定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</div></pre></td></tr></table></figure>
<h5 id="objc-property-attribute-t"><a href="#objc-property-attribute-t" class="headerlink" title="objc_property_attribute_t"></a>objc_property_attribute_t</h5><p>objc_property_attribute_t定义了属性的特性(attribute)，它是一个结构体，定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">// 特性名</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          <span class="comment">// 特性值</span></div><div class="line">&#125; objc_property_attribute_t;</div></pre></td></tr></table></figure>
<h4 id="关联对象-Associated-Object"><a href="#关联对象-Associated-Object" class="headerlink" title="关联对象(Associated Object)"></a>关联对象(Associated Object)</h4><p>关联对象是Runtime中一个非常实用的特性，不过可能很容易被忽视。</p>
<p>关联对象类似于成员变量，不过是在运行时添加的。我们通常会把成员变量(Ivar)放在类声明的头文件中，或者放在类实现的<code>@implementation</code>后面。但这有一个缺点，我们不能再分类中添加成员变量。如果我们尝试在分类中添加新的成员变量，编译器会报错。</p>
<p>我们可能希望通过使用(甚至是滥用)全局变量来解决这个问题。但这些都不是Ivar，因为他们不会连接到一个单独的实例。因此，这种方法很少使用。</p>
<p>Objective-C针对这一问题，提供了一个解决方案：即关联对象(Associated Object)。</p>
<p>我们可以把关联对象想象成一个Objective-C对象(如字典),这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个void指针(const void*)。我们还需要制定一个内存管理策略，以告诉Runtime如何管理这个对象的内存。这个内存管理的策略可以由以下值指定：</p>
<pre><code>OBJC_ASSOCIATION_ASSIGN                //assign
OBJC_ASSOCIATION_RETAIN_NONATOMIC    //retain  nonatomic
OBJC_ASSOCIATION_COPY_NONATOMIC        //copy nonatomic
OBJC_ASSOCIATION_RETAIN                    // retain
OBJC_ASSOCIATION_COPY                    //copy
</code></pre><p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的策略是assign，则宿主释放时，关联对象不会被释放；而如果指定的是retain或者是copy，则宿主释放时，关联对象会被释放。我们甚至可以选择是否是自动retain/copy。当我们需要在多个线程中处理访问对象的多线程代码时，这就非常有用了。</p>
<p>我们将一个对象连接到其它对象所需要做的就是下面两行代码：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> myKey;</div><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);</div></pre></td></tr></table></figure></p>
<p>在这种情况下，self对象将获取一个新的关联的对象anObject，且内存管理策略是自动retain关联对象，当self对象释放时，会自动release关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，这种情况下，先前的关联对象会被妥善地处理掉，并且新的对象会使用它的内存。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> anObject = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;myKey);</div></pre></td></tr></table></figure>
<p>我们可以使用<code>objc_removeAssociatedObjects</code>函数来移除一个关联对象，或者使用<code>objc_setAssociatedObject</code>函数将key指定的关联对象设置为nil。</p>
<p>我们下面来用实例演示一下关联对象的使用方法。</p>
<p>假定我们想要动态地将一个Tap手势操作连接到任何UIView中，并且根据需要指定点击后的实际操作。这时候我们就可以将一个手势对象及操作的block对象关联到我们的UIView对象中。这项任务分两部分。首先，如果需要，我们要创建一个手势识别对象并将它及block做为关联对象。如下代码所示：</p>
<p>首先创建一个UIView的分类<br><em>UIView+GG.h</em><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> (<span class="title">GG</span>)</span></div><div class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p><em>UIView+GG.m</em><br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"UIView+GG.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *kDTActionHandlerTapGestureKey;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> * ;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIView</span> (<span class="title">GG</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</div><div class="line">    <span class="comment">//获取关联对象（手势）</span></div><div class="line">    <span class="built_in">UITapGestureRecognizer</span> *gesture = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey);</div><div class="line">    <span class="comment">//如果关联对象(手势)为空，创建UIView的关联对象 UITapGestureRecognizer对象</span></div><div class="line">    <span class="keyword">if</span> (!gesture)</div><div class="line">    &#123;</div><div class="line">        gesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(__handleActionForTapGesture:)];</div><div class="line">        [<span class="keyword">self</span> addGestureRecognizer:gesture];</div><div class="line">        <span class="comment">//创建完UITapGestureRecognizer对象，并设置为当前UIView的关联对象。</span></div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置block为UIView的关联对象。</span></div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(<span class="built_in">UITapGestureRecognizer</span> *)gesture</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (gesture.state == <span class="built_in">UIGestureRecognizerStateRecognized</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//获取关联对象(block)</span></div><div class="line">        <span class="keyword">void</span>(^action)(<span class="keyword">void</span>) = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kDTActionHandlerTapBlockKey);</div><div class="line">        <span class="keyword">if</span> (action)</div><div class="line">        &#123;</div><div class="line">            action();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这段代码，我们分别定义了两个key，作为我们关联对象的key。在<code>- (void)setTapActionWithBlock:(void (^)(void))block</code>方法中，我们检测了手势识别的关联对象。如果没有，则创建并建立关联关系。同时，将传入的块对象连接到指定的key上。注意block对象的关联内存管理策略。<br>手势识别对象需要一个<code>target</code>和<code>action</code>，所以接下来我们定义了处理方法：<code>- (void)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture</code>。我们需要检测手势识别对象的状态，因为我们只需要在点击手势识别出来时才执行操作。</p>
<p>从上面的例子我们可以看到，关联对象使用起来并不复杂。它让我们可以动态地增强类现有的功能。我们可以在编码中灵活地运用这一特性。</p>
<h4 id="成员变量、属性的操作方法"><a href="#成员变量、属性的操作方法" class="headerlink" title="成员变量、属性的操作方法"></a>成员变量、属性的操作方法</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>成员变量操作包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取成员变量名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getName ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量类型编码</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ivar_getTypeEncoding ( Ivar v );</div><div class="line"><span class="comment">// 获取成员变量的偏移量</span></div><div class="line">ptrdiff_t ivar_getOffset ( Ivar v );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>ivar_getOffset</code>函数，对于类型id或其它对象类型的实例变量，可以调用<code>object_getIvar</code>和<code>object_setIvar</code>来直接访问成员变量，而不适用偏移量。</li>
</ul>
<h5 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h5><p>关联对象操作函数包括以下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 设置关联对象</span></div><div class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</div><div class="line"><span class="comment">// 获取关联对象</span></div><div class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</div><div class="line"><span class="comment">// 移除关联对象</span></div><div class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</div></pre></td></tr></table></figure></p>
<p>关联对象及相关实例已经在前面讨论过了，在此不再重复。</p>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>属性操作相关函数包括以下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取属性名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性特性描述字符串</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( objc_property_t property );</div><div class="line"><span class="comment">// 获取属性中指定的特性</span></div><div class="line"><span class="keyword">char</span> * property_copyAttributeValue ( objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</div><div class="line"><span class="comment">// 获取属性的特性列表</span></div><div class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>property_copyAttributeValue</code>函数，返回的<code>char*</code>在使用完后需要调用free()释放。</li>
<li><code>property_copyAttributeList</code>函数，返回值在使用完后需要调用free()释放。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>假定这样一个场景，我们从服务端两个不同的接口获取相同的字典数据，但这两个接口是由两个人写的，相同的信息使用了不同的字段表示。我们接收到数据时，可将这些数据保存在相同的对象中。对象类如下定义：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyObject</span>: <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>    *   name;                  </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span>    *   status;                 </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>接口A、B返回的字典数据如下所示：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">@&#123;<span class="string">@"name1"</span>: <span class="string">"张三"</span>, <span class="string">@"status1"</span>: <span class="string">@"start"</span>&#125;</div><div class="line">@&#123;<span class="string">@"name2"</span>: <span class="string">"张三"</span>, <span class="string">@"status2"</span>: <span class="string">@"end"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>通常的方法是写两个方法分别做转换，不过如果能灵活地运用Runtime的话，可以只实现一个转换，为此，我们需要先定义一个映射字典(全局变量)<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *map = <span class="literal">nil</span>;</div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span>	</span></div><div class="line">+ (<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    map = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    map[<span class="string">@"name1"</span>]                = <span class="string">@"name"</span>;</div><div class="line">    map[<span class="string">@"status1"</span>]              = <span class="string">@"status"</span>;</div><div class="line">    map[<span class="string">@"name2"</span>]                = <span class="string">@"name"</span>;</div><div class="line">    map[<span class="string">@"status2"</span>]              = <span class="string">@"status"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>上面的代码将两个字典中不同的字段映射到<code>MyObject</code>中相同的属性上，这样，转换方法可如下处理：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setDataWithDic:(<span class="built_in">NSDictionary</span> *)dic</div><div class="line">&#123;</div><div class="line">    [dic enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">        <span class="built_in">NSString</span> *propertyKey = [<span class="keyword">self</span> propertyForKey:key];</div><div class="line">        <span class="keyword">if</span> (propertyKey)</div><div class="line">        &#123;</div><div class="line">            objc_property_t property = class_getProperty([<span class="keyword">self</span> <span class="keyword">class</span>], [propertyKey UTF8String]);</div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> 针对特殊数据类型做处理</span></div><div class="line">            <span class="built_in">NSString</span> *attributeString = [<span class="built_in">NSString</span> stringWithCString:property_getAttributes(property) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">            ...</div><div class="line">            [<span class="keyword">self</span> setValue:obj forKey:propertyKey];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，一个属性能否通过上面这种方式来处理的前提是其支持KVC。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章中我们讨论了Runtime中与成员变量和属性相关的内容。成员变量与属性是类的数据基础，合理地使用Runtime中的相关操作能让我们更加灵活地来处理与类数据相关的工作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面一篇文章中，我们介绍了Runtime中与类和对象相关的内容，从这章开始，我们将讨论类实现细节相关的内容，主要包括类中成员变量，属性，方法，协议与分类的实现。&lt;/p&gt;
&lt;p&gt;本章的主要内容将聚集在Runtime对成员变量与属性的处理。在讨论之前，我们先介绍一个重要的概念：类型编码。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C Runtime 运行时之一：类与对象</title>
    <link href="http://www.guiyongdong.com/2016/11/21/Objective-C-Runtime-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.guiyongdong.com/2016/11/21/Objective-C-Runtime-运行时之一：类与对象/</id>
    <published>2016-11-21T09:22:10.000Z</published>
    <updated>2017-03-09T07:03:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具有灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样，让它所有的工作可以正常运行。这个运行时系统即<code>Objc Runtime</code>。<code>Objc Runtime</code>其实就是一个<code>Runtime</code>库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<a id="more"></a>
<p><code>Runtime</code>库主要做下面几件事：</p>
<ul>
<li>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被Runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</li>
<li>找出方法的最终执行代码：当程序执行<code>[object doSomething]</code>时，会向消息接收者(object)发送一条信息(doSomething)，Runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。</li>
</ul>
<p>Objective-C Runtime目前有两个版本：<code>Modern Runtime</code>和<code>Legacy Runtime</code>。<code>Modern Runtime</code>覆盖了64位的<code>Mac OS X Apps</code>还有<code>iOS AppS</code>,<code>Legacy Runtime</code>是早期用来给32位<code>Mac OS X Apps</code> 用的，也就是可以不用管就是了。</p>
<p>在这一系列文章中，我们将介绍Runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。CFRuntime的代码是开源的，我们可以在这里<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">https://opensource.apple.com/tarballs/CF/</a>下载整个CoreFoundation的源码来看。 在本文中，我们先来介绍一下类和对象，这是面向对象的基础，我们看看在Runtime中，类是如何体现的。</p>
<h3 id="类与对象基础数据结构"><a href="#类与对象基础数据结构" class="headerlink" title="类与对象基础数据结构"></a>类与对象基础数据结构</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>Objective-C类是由Class类型来表示的，它实际上是指向objc_class结构体的指针。它的定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div></pre></td></tr></table></figure></p>
<p>查看<code>objc/runtime.h</code>中<code>objc_class</code>结构体的定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                   	OBJC2_UNAVAILABLE;	<span class="comment">// 父类</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                      	OBJC2_UNAVAILABLE;	<span class="comment">// 类名</span></div><div class="line">    <span class="keyword">long</span> version                          	OBJC2_UNAVAILABLE;	<span class="comment">// 类的版本信息，默认为0</span></div><div class="line">    <span class="keyword">long</span> info                            	OBJC2_UNAVAILABLE;	<span class="comment">// 类信息，供运行期使用的一些位标识</span></div><div class="line">    <span class="keyword">long</span> instance_size                   	OBJC2_UNAVAILABLE;	<span class="comment">// 该类的实例变量大小</span></div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars         	OBJC2_UNAVAILABLE;	<span class="comment">// 该类的成员变量链表</span></div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists 	OBJC2_UNAVAILABLE;	<span class="comment">// 方法定义的链表</span></div><div class="line">    <span class="keyword">struct</span> objc_cache *cache              	OBJC2_UNAVAILABLE;	<span class="comment">// 方法缓存</span></div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols 	OBJC2_UNAVAILABLE;	<span class="comment">// 协议链表</span></div><div class="line"><span class="meta">#endif</span></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure></p>
<p>在这个定义中，下面几个字段是我们感兴趣的</p>
<ol>
<li><strong>isa</strong>: 需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类),我们会在后面介绍它。</li>
<li><strong>super_class</strong>：指向该类的父类，如果该类已经是最顶层的跟类(如NSObject或者NSProxy)，则super_class为NULL。</li>
<li><strong>cache</strong>: 用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才到methodLists中查找方法。这样，对于那些经常用到的方法的调用，提高了调用的效率。</li>
<li><strong>version</strong>：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ol>
<p>针对cache,我们用下面例子来说明其执行过程：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [[<span class="built_in">NSArray</span> alloc] init];</div></pre></td></tr></table></figure></p>
<p>其流程是：</p>
<ol>
<li><code>[NSArray alloc]</code>先被执行。因为NSArray没有<code>+alloc</code>方法，于是去父类NSObject去查找。</li>
<li>检测NSObject是否响应<code>+alloc</code>方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把<code>isa</code>指针指向NSArray类。同时，<code>+alloc</code>也被加进cache列表里面。</li>
<li>接着，执行<code>-init</code>方法，如果NSArray响应该方法，则直接将其加入<code>cache</code>；如果不响应，则去父类查找。</li>
<li>在后期的操作中，如果再以<code>[[NSArray alloc] init]</code>这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</li>
</ol>
<h4 id="objc-object与id"><a href="#objc-object与id" class="headerlink" title="objc_object与id"></a>objc_object与id</h4><p><code>objc_object</code>是表示一个类的实例的结构体，它的定义如下(<code>objc/objc.h</code>)：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_object &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</div></pre></td></tr></table></figure>
<p>可以看到，这个结构体只是一个指针，即指向其类的isa指针，这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。</p>
<p>另外还有我们常见的id，它是一个objc_object结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void*指针类型的作用。</p>
<h4 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h4><p>上面提到了objc_class结构体中的cache字段，它用于缓存调用过的方法。这个字段是一个指向objc_cache结构体的指针，其定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_cache &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</div><div class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>该结构体的字段描述如下：</p>
<ol>
<li><strong>mask</strong>：一个整数，指定分配的缓存buket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。</li>
<li><strong>occupied</strong>：一个整数，指定实际占用的缓存bucket的总数。</li>
<li><strong>buckets</strong>：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能为MULL，表示这个缓存buket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。</li>
</ol>
<h4 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h4><p>在上面我们提到，所有的类本身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。如：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> array];</div></pre></td></tr></table></figure></p>
<p>这个例子中，<code>+array</code>消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就有一个问题了，这个isa指针指向哪里呢？为了调用<code>+array</code>方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">meta-<span class="keyword">class</span>是一个类对象的类。</div></pre></td></tr></table></figure></p>
<p>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法，而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p>
<p>meta-class之所以重要，是因为它存储着一个类的所有方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>
<p>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。</p>
<p>通过上面的描述，再加上对objc_class结构中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图所示:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/class-diagram.jpg?raw=true" alt="image"><br></div>

<p>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。</p>
<p>讲了这么多，我们还是来写个例子吧：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> TestMetaClass(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"This objcet is %p"</span>, <span class="keyword">self</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Class is %@, super class is %@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], [<span class="keyword">self</span> superclass]);</div><div class="line">    Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Following the isa pointer %d times gives %p"</span>, i, currentClass);</div><div class="line">        currentClass = objc_getClass((__bridge <span class="keyword">void</span> *)currentClass);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's class is %p"</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"NSObject's meta class is %p"</span>, objc_getClass((__bridge <span class="keyword">void</span> *)[<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark -</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">void</span>)ex_registerClassPair &#123;</div><div class="line">    Class newClass = objc_allocateClassPair([<span class="built_in">NSError</span> <span class="keyword">class</span>], <span class="string">"TestClass"</span>, <span class="number">0</span>);</div><div class="line">    class_addMethod(newClass, <span class="keyword">@selector</span>(testMetaClass), (IMP)TestMetaClass, <span class="string">"v@:"</span>);</div><div class="line">    objc_registerClassPair(newClass);</div><div class="line">    <span class="keyword">id</span> instance = [[newClass alloc] initWithDomain:<span class="string">@"some domain"</span> code:<span class="number">0</span> userInfo:<span class="literal">nil</span>];</div><div class="line">    [instance performSelector:<span class="keyword">@selector</span>(testMetaClass)];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这个例子是在运行时创建了一个NSError的子类TestClass，然后为这个子类添加一个方法testMetaClass，这个方法的实现是TestMetaClass函数。</p>
<p>运行后，打印结果是:<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">2014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x0</div><div class="line">2014-10-20 22:57:07.353 mountain[1303:41490] NSObject's class is 0xe10000</div><div class="line">2014-10-20 22:57:07.354 mountain[1303:41490] NSObject's meta class is 0x0</div></pre></td></tr></table></figure></p>
<p>我们在for循环中，我们通过objc_getClass来获取对象的isa,并将其打印出来，依此一直回溯到NSObject的meta-class。分析打印结果，可以看到最后指针指向的地址是0x0，即NSObject的meta-class的类地址。</p>
<p>这里需要注意的是：我们在一个类对象调用class方法是无法获取meta-class,它只是返回一个类而已。</p>
<h3 id="类与对象操作函数"><a href="#类与对象操作函数" class="headerlink" title="类与对象操作函数"></a>类与对象操作函数</h3><p>runtime提供了大量的函数来操作类和对象。类的操作方法大部分是以<code>class_</code>为前缀的，而对象的操作方法大部分是以<code>objc_</code>或<code>object_</code>为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>
<h4 id="类相关操作函数"><a href="#类相关操作函数" class="headerlink" title="类相关操作函数"></a>类相关操作函数</h4><p>我们可以回过头去看看<code>objc_class</code>的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些函数。并在最后以实例来演示这些函数的具体方法。</p>
<h5 id="类名-name"><a href="#类名-name" class="headerlink" title="类名(name)"></a>类名(name)</h5><p>类名操作的函数主要有：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取类的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( Class cls );</div></pre></td></tr></table></figure></p>
<ul>
<li>对于<code>class_getName</code>函数，如果传入的cls为Nil，则返回一个nil</li>
</ul>
<h5 id="父类-super-class-和元类-meta-class"><a href="#父类-super-class-和元类-meta-class" class="headerlink" title="父类(super_class)和元类(meta-class)"></a>父类(super_class)和元类(meta-class)</h5><p>父类和元类操作的函数主要有：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取类的父类</span></div><div class="line">Class class_getSuperclass ( Class cls );</div><div class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></div><div class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>class_getSuperclass</code>函数，当cls为nil或者cls为根类时，返回nil。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的。</li>
<li><code>class_isMetaClass</code>函数，如果cls是元类，则返回YES，如果否或者传入的cls为nil，则返回NO。</li>
</ul>
<h5 id="实例变量大小-instance-size"><a href="#实例变量大小-instance-size" class="headerlink" title="实例变量大小(instance_size)"></a>实例变量大小(instance_size)</h5><p>实例变量大小操作的函数有：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取实例大小</span></div><div class="line">size_t class_getInstanceSize ( Class cls );</div></pre></td></tr></table></figure></p>
<h5 id="成员变量-ivars-及属性"><a href="#成员变量-ivars-及属性" class="headerlink" title="成员变量(ivars)及属性"></a>成员变量(ivars)及属性</h5><p>在<code>objc_class</code>中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：<br>1.成员变量操作函数，主要包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></div><div class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取类成员变量的信息</span></div><div class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 添加成员变量</span></div><div class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"><span class="comment">// 获取整个成员变量列表</span></div><div class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>class_getInstanceVariable</code>函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。</li>
<li><code>class_getClassVariable</code>函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</li>
<li>Objective-C不支持往已经存在的类中添加实例变量，因此不管是系统库提供的类，还是我们自己定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以用<code>class_addIvar</code>函数了。不过需要注意的是，这个方法只能在<code>objc_allocateClassPair</code>函数与<code>objc_registerClassPair</code>之间调用。另外，这个类也不能是元类。成员变量的按字节最小对其量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</li>
<li><code>class_copyIvarList</code>函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。</li>
</ul>
<p>2.属性操作函数，主要包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取指定的属性</span></div><div class="line">objc_property_t class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 获取属性列表</span></div><div class="line">objc_property_t * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 为类添加属性</span></div><div class="line"><span class="built_in">BOOL</span> class_addProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div><div class="line"><span class="comment">// 替换类的属性</span></div><div class="line"><span class="keyword">void</span> class_replaceProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</div></pre></td></tr></table></figure></p>
<p>这一种方法也是针对ivars来操作，不过只操作那些属性的值。我们在后面会介绍属性时会再遇到这些函数。</p>
<p>3.在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理strong/weak引用。这几个函数定义如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> uint8_t * class_getIvarLayout ( Class cls );</div><div class="line"><span class="keyword">void</span> class_setIvarLayout ( Class cls, <span class="keyword">const</span> uint8_t *layout );</div><div class="line"><span class="keyword">const</span> uint8_t * class_getWeakIvarLayout ( Class cls );</div><div class="line"><span class="keyword">void</span> class_setWeakIvarLayout ( Class cls, <span class="keyword">const</span> uint8_t *layout );</div></pre></td></tr></table></figure></p>
<p>但通常情况下，我们不需要主动去调用这些方法，在调用<code>objc_registerClassPair</code>时，会生成合理的布局。在此不详细介绍这些函数。</p>
<h5 id="方法-methodLists"><a href="#方法-methodLists" class="headerlink" title="方法(methodLists)"></a>方法(methodLists)</h5><p>方法操作主要有以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 添加方法</span></div><div class="line"><span class="built_in">BOOL</span> class_addMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"><span class="comment">// 获取实例方法</span></div><div class="line">Method class_getInstanceMethod ( Class cls, SEL name );</div><div class="line"><span class="comment">// 获取类方法</span></div><div class="line">Method class_getClassMethod ( Class cls, SEL name );</div><div class="line"><span class="comment">// 获取所有方法的数组</span></div><div class="line">Method * class_copyMethodList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 替代方法的实现</span></div><div class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</div><div class="line"><span class="comment">// 返回方法的具体实现</span></div><div class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</div><div class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</div><div class="line"><span class="comment">// 类实例是否响应指定的selector</span></div><div class="line"><span class="built_in">BOOL</span> class_respondsToSelector ( Class cls, SEL sel );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>class_addMethod</code>的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用<code>method_setImplementation</code>。一个Objective-C方法是一个简单的C函数，它至少包含两个参数self和_cmd。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethodIMP</span><span class="params">(id self, SEL <span class="number">_</span>cmd)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// implementation ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已经存在。另外，参数types是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。</p>
<ul>
<li><code>class_getInstanceMethod</code>、<code>class_getClassMethod</code>函数,与<code>class_copyMethodList</code>不同的是，这两个函数都会去搜索父类的实现。</li>
<li><code>class_copyMethodList</code>函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用<code>class_copyMethodList(object_getClass(cls),&amp;count)</code>(一个类的实例方法定义在元类里面)。该列表不包含父类实现的方法。<code>outCount</code>参数返回方法的个数。在获取到列表后，我们需要使用free()方法来释放它。</li>
<li><code>class_replaceMethod</code>函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于<code>class_addMethod</code>函数一样会添加方法；如果类中已经存在name指定的方法，则类似与<code>method_setImplementation</code>一样替代原方法的实现。</li>
<li><code>class_getMethodImplementation</code>函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比<code>method_getImplementation(class_getInstanceMethod(cls,name))</code>更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应selector，则返回的函数指针将是运行时消息转发机制的一部分。</li>
<li><code>class_respondsToSelector</code>函数，我们通常使用NSObject类的<code>respondsToSelector:</code>或<code>instanceRespondToSelector:</code>方法来达到同样的目的。</li>
</ul>
<h5 id="协议-objc-protocol-list"><a href="#协议-objc-protocol-list" class="headerlink" title="协议(objc_protocol_list)"></a>协议(objc_protocol_list)</h5><p>协议相关的操作包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 添加协议</span></div><div class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</div><div class="line"><span class="comment">// 返回类是否实现指定的协议</span></div><div class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</div><div class="line"><span class="comment">// 返回类实现的协议列表</span></div><div class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>class_conformsToProtocol</code>函数可以使用NSObject类的<code>conformsToProtocol:</code>方法来代替。</li>
<li><code>class_copyProtocolList</code>函数返回的是一个数组，在使用后我们需要使用free()手动释放。</li>
</ul>
<h5 id="版本-version"><a href="#版本-version" class="headerlink" title="版本(version)"></a>版本(version)</h5><p>版本相关的操作包含以下函数：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取版本号</span></div><div class="line"><span class="keyword">int</span> class_getVersion ( Class cls );</div><div class="line"><span class="comment">// 设置版本号</span></div><div class="line"><span class="keyword">void</span> class_setVersion ( Class cls, <span class="keyword">int</span> version );</div></pre></td></tr></table></figure></p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>runtime还提供了两个函数工<code>CoreFoundation</code>和<code>tool-free bridging</code>使用，即：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">Class objc_getFutureClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="keyword">void</span> objc_setFutureClass ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure></p>
<p>通常我们不直接使用这两个函数。</p>
<h5 id="实例-Example"><a href="#实例-Example" class="headerlink" title="实例(Example)"></a>实例(Example)</h5><p>上面列举了大量类操作的函数，下面我们写个实例，来看看这些函数的实例效果：</p>
<p>我们创建一个类MyClass，并且给雷添加一些实例变量和方法。</p>
<p><strong>MyClass.h</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *array;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method1;</div><div class="line">- (<span class="keyword">void</span>)method2;</div><div class="line">+ (<span class="keyword">void</span>)classMethod1;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><strong>MyClass.m</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</div><div class="line">    <span class="built_in">NSInteger</span> _instance1;</div><div class="line">    <span class="built_in">NSString</span> *_instance2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> integer;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></div><div class="line"></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"调用类方法 classMethod1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method1 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用实例方法 method1"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method2 &#123;</div><div class="line">	<span class="built_in">NSLog</span>(<span class="string">@"调用实例方法 method2"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"arg1 : %ld, arg2 : %@"</span>,arg1,arg2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在ViewController中的<code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</code>方法中调用例子:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    MyClass *myClass = [[MyClass alloc] init];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</div><div class="line">    Class cls = myClass.class;</div><div class="line">    </div><div class="line">    <span class="comment">//类名</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>,class_getName(cls));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//父类</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"super class name: %s"</span>,class_getName(class_getSuperclass(cls)));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//是否是元类</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyClass is %@ a meta-class"</span>,class_isMetaClass(cls)?<span class="string">@""</span>:<span class="string">@"not"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//元类</span></div><div class="line">    Class meta_class = objc_getMetaClass(class_getName(cls));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s's meta-class is  %s"</span>,class_getName(cls),class_getName(meta_class));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//变量实例大小</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"instance size: %zu"</span>,class_getInstanceSize(cls));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//成员变量</span></div><div class="line">    Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; outCount; i++) &#123;</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"instance variable's name:%s at index: %d"</span>,ivar_getName(ivar),i);</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">    <span class="comment">//指定名称的成员变量</span></div><div class="line">    Ivar string = class_getInstanceVariable(cls, <span class="string">"_string"</span>);</div><div class="line">    <span class="keyword">if</span> (string != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"instanve variable %s"</span>,ivar_getName(string));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//属性操作</span></div><div class="line">    objc_property_t *properties = class_copyPropertyList(cls, &amp;outCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; outCount; i++) &#123;</div><div class="line">        objc_property_t property = properties[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"property's name : %s"</span>,property_getName(property));</div><div class="line">    &#125;</div><div class="line">    free(properties);</div><div class="line">    <span class="comment">//指定名称的属性</span></div><div class="line">    objc_property_t array = class_getProperty(cls, <span class="string">"_array"</span>);</div><div class="line">    <span class="keyword">if</span> (array != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"property %s"</span>,property_getName(array));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//方法操作 </span></div><div class="line">    Method *methods = class_copyMethodList(cls, &amp;outCount);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; outCount; i++) &#123;</div><div class="line">        Method method = methods[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"method's signature: %s"</span>,method_getName(method));</div><div class="line">    &#125;</div><div class="line">    free(methods);</div><div class="line">    <span class="comment">//指定方法名实例方法</span></div><div class="line">    Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">    <span class="keyword">if</span> (method1 != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"instance method: %s "</span>,method_getName(method1));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//指定方法名类方法</span></div><div class="line">    Method classMethod = class_getClassMethod(cls, <span class="keyword">@selector</span>(classMethod1));</div><div class="line">    <span class="keyword">if</span> (classMethod != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"class method :%s"</span>,method_getName(classMethod));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断是否实现某方法</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyClass is %@ responsd to selector: method3WithArg1:arg2:"</span>,class_respondsToSelector(cls, <span class="keyword">@selector</span>(method3WithArg1:arg2:))?<span class="string">@""</span>:<span class="string">@"not"</span>);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//获取指定方法实现</span></div><div class="line">    IMP imp = class_getMethodImplementation(cls, <span class="keyword">@selector</span>(method1));</div><div class="line">    imp();</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//协议</span></div><div class="line">    Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(cls, &amp;outCount);</div><div class="line">    Protocol *protocol;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; outCount; i++) &#123;</div><div class="line">        protocol = protocols[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"protocol name:%s"</span>,protocol_getName(protocol));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"MyClass is %@ responsed to protocol %s"</span>,class_conformsToProtocol(cls, protocol)?<span class="string">@""</span>:<span class="string">@"not"</span>,protocol_getName(protocol));</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---------------------------------"</span>);</div><div class="line">   </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>控制台输出如下：<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] class name: MyClass</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] super class name: NSObject</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] MyClass is not a meta-class</div><div class="line">2016-11-23 18:07:47.583 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] MyClass's meta-class is  MyClass</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] instance size: 48</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] instance variable's name:_instance1 at index: 0</div><div class="line">2016-11-23 18:07:47.584 RuntimeDemo[3598:309543] instance variable's name:_instance2 at index: 1</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] instance variable's name:_array at index: 2</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] instance variable's name:_string at index: 3</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] instance variable's name:_integer at index: 4</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] instanve variable _string</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.585 RuntimeDemo[3598:309543] property's name : integer</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] property's name : array</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] property's name : string</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] method's signature: method1</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] method's signature: method3WithArg1:arg2:</div><div class="line">2016-11-23 18:07:47.586 RuntimeDemo[3598:309543] method's signature: method2</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: integer</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: setInteger:</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: setArray:</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: .cxx_destruct</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: string</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: setString:</div><div class="line">2016-11-23 18:07:47.587 RuntimeDemo[3598:309543] method's signature: array</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] instance method: method1 </div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] MyClass is  responsd to selector: method3WithArg1:arg2:</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] 调用实例方法 method1</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] ---------------------------------</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] protocol name:NSCopying</div><div class="line">2016-11-23 18:07:47.588 RuntimeDemo[3598:309543] protocol name:NSCoding</div><div class="line">2016-11-23 18:07:47.589 RuntimeDemo[3598:309543] MyClass is  responsed to protocol NSCoding</div></pre></td></tr></table></figure></p>
<h4 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h4><p>runtime的强大之处在于它能在运行时创建类和对象。</p>
<h5 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h5><p>动态创建类涉及到以下几个函数：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 创建一个新类和元类</span></div><div class="line">Class objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes);</div><div class="line"><span class="comment">// 销毁一个类及其相关联的类</span></div><div class="line"><span class="keyword">void</span> objc_disposeClassPair ( Class cls );</div><div class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></div><div class="line"><span class="keyword">void</span> objc_registerClassPair ( Class cls );</div></pre></td></tr></table></figure>
<ul>
<li><code>objc_allocateClassPair</code>函数：如果我们要创建一个根类，则superclass指定为Nil。<code>extraBytes</code>通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。</li>
<li><code>objc_registerClassPair</code>函数：为了创建一个新类，我们需要调用<code>objc_allocateClassPair</code>。然后使用诸如<code>class_addMethod</code>,<code>class_addIvar</code>等函数来为新的类添加方法、实例变量和属性等。完成这些后，我们需要调用<code>objc_registerClassPair</code>函数来注册类，之后这个类就可以在程序中使用了。实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</li>
<li><code>objc_disposeClassPair</code>函数：用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或者其子类的实例时，则不能针对类调用该方法。</li>
</ul>
<p>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">"MySubClass"</span>, <span class="number">0</span>);</div><div class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">"v@:"</span>);</div><div class="line">class_addIvar(cls, <span class="string">"_ivar1"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">"i"</span>);</div><div class="line">objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</div><div class="line">objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</div><div class="line">objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</div><div class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</div><div class="line">class_addProperty(cls, <span class="string">"property2"</span>, attrs, <span class="number">3</span>);</div><div class="line">objc_registerClassPair(cls);</div><div class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</div><div class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</div></pre></td></tr></table></figure></p>
<p>程序的输出如下：</p>
<pre><code>2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1
</code></pre><h5 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h5><p>动态创建对象的函数如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 创建类实例</span></div><div class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</div><div class="line"><span class="comment">// 在指定位置创建类实例</span></div><div class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</div><div class="line"><span class="comment">// 销毁类实例</span></div><div class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure>
<ul>
<li><code>class_createInstance</code>函数：创建实例时，会在默认的内存区域为类分配内存。<code>extraBytes</code>参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</li>
</ul>
<p>调用<code>class_createInstance</code>的效果与<code>+alloc</code>方法类似。不过在使用<code>class_createInstance</code>时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line"> </div><div class="line"><span class="keyword">id</span> str1 = [theObject init];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 <span class="keyword">class</span>]);</div><div class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 <span class="keyword">class</span>]);</div></pre></td></tr></table></figure></p>
<p>输出的结果是：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] <span class="built_in">NSString</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] __NSCFConstantString</div></pre></td></tr></table></figure></p>
<p>可以看到，使用<code>class_createInstance</code>函数获取的是NSString实例，而不是类簇中的默认站位符类<code>__NSCFConstantString</code>。</p>
<ul>
<li><p><code>objc_constructInstance</code>函数：在指定的位置(bytes)创建类实例。</p>
</li>
<li><p><code>objc_destructInstance</code>函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</p>
</li>
</ul>
<h5 id="实例操作函数"><a href="#实例操作函数" class="headerlink" title="实例操作函数"></a>实例操作函数</h5><p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<p>1.针对整个对象进行操作的函数，这类函数包括<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回指定对象的一份拷贝</span></div><div class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</div><div class="line"><span class="comment">// 释放指定对象占用的内存</span></div><div class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</div></pre></td></tr></table></figure></p>
<p>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，以为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就可以使用以上几个函数来处理这种情况，如下代码所示：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</div><div class="line">object_setClass(newB, MyClass.class);</div><div class="line">object_dispose(a);</div></pre></td></tr></table></figure></p>
<p>2.针对对象实例变量进行操作的函数，这类函数包含：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 修改类实例的实例变量的值</span></div><div class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</div><div class="line"><span class="comment">// 获取对象实例变量的值</span></div><div class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</div><div class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></div><div class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象中实例变量的值</span></div><div class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</div><div class="line"><span class="comment">// 设置对象中实例变量的值</span></div><div class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</div></pre></td></tr></table></figure></p>
<p>如果实例变量的Ivar已经知道，那么调用<code>object_getIvar</code>会比<code>object_getInstanceVariable</code>函数快，相同情况下，<code>object_setIvar</code>也比<code>object_setInstanceVariable</code>快。</p>
<p>3.针对对象的类进行操作的函数，这类函数包含：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 返回给定对象的类名</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 返回对象的类</span></div><div class="line">Class object_getClass ( <span class="keyword">id</span> obj );</div><div class="line"><span class="comment">// 设置对象的类</span></div><div class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</div></pre></td></tr></table></figure></p>
<h5 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h5><p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用<code>objc_addClass</code>函数来注册它们。runtime提供了一系列函数来获取类定义相关的信息，这些函数主要包括：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 获取已注册的类定义的列表</span></div><div class="line"><span class="keyword">int</span> objc_getClassList ( Class *buffer, <span class="keyword">int</span> bufferCount );</div><div class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></div><div class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</div><div class="line"><span class="comment">// 返回指定类的类定义</span></div><div class="line">Class objc_lookUpClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line">Class objc_getRequiredClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div><div class="line"><span class="comment">// 返回指定类的元类</span></div><div class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</div></pre></td></tr></table></figure></p>
<ul>
<li><code>objc_getClassList</code>函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。</li>
</ul>
<p>下面代码演示了该函数的用法：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> numClasses;</div><div class="line">Class * classes = <span class="literal">NULL</span>;</div><div class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</div><div class="line">    classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</div><div class="line">    numClasses = objc_getClassList(classes, numClasses);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"number of classes: %d"</span>, numClasses);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</div><div class="line">        Class cls = classes[i];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));</div><div class="line">    &#125;</div><div class="line">    free(classes);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] number of classes: <span class="number">1282</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: DDTokenRegexp</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _NSMostCommonKoreanCharsKeySet</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_xpc_dictionary</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSFileCoordinator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSAssertionHandler</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: PFUbiquityTransactionLogMigrator</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSNotification</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: <span class="built_in">NSKeyValueNilSetEnumerator</span></div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: OS_tcp_connection_tls_session</div><div class="line"><span class="number">2014</span><span class="number">-10</span><span class="number">-23</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">8437</span>:<span class="number">188589</span>] <span class="keyword">class</span> name: _PFRoutines</div><div class="line">......还有大量输出</div></pre></td></tr></table></figure></p>
<ul>
<li>获取类定义的方法有三个：<code>objc_lookUpClass</code>,<code>objc_getClass</code>和<code>objc_getRequiredClass</code>。如果类在运行时未注册，则<code>objc_lookUpClass</code>会返回nil，而<code>objc_getClass</code>会调用类处理回调，并再次确认该类是否注册，如果确认未注册，则返回nil。而<code>objc_getRequiredClass</code>函数的操作与<code>objc_getClass</code>相同，只不过如果没有找到类，则会杀死进程。</li>
<li><code>objc_getMetaClass</code>函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在这一章中我们介绍了Runtime运行时中与类和对象相关的数据结构，通过这些数据函数，我们可以管窥Objective-C底层面向对象实现的一些信息。另外，通过丰富的操作函数，可以灵活地对这些数据进行操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具有灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。&lt;/p&gt;
&lt;p&gt;这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样，让它所有的工作可以正常运行。这个运行时系统即&lt;code&gt;Objc Runtime&lt;/code&gt;。&lt;code&gt;Objc Runtime&lt;/code&gt;其实就是一个&lt;code&gt;Runtime&lt;/code&gt;库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="Runtime" scheme="http://www.guiyongdong.com/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>NSURLSession与NSURLConnection区别</title>
    <link href="http://www.guiyongdong.com/2016/11/18/NSURLSession%E4%B8%8ENSURLConnection%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.guiyongdong.com/2016/11/18/NSURLSession与NSURLConnection区别/</id>
    <published>2016-11-18T06:09:19.000Z</published>
    <updated>2017-03-09T07:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去面试，被问了一道AFNetworking2.0和3.0有什么区别，当时心想，这谁不知道啊，随口答到：2.0使用的NSURLConnection,3.0使用的是NSURLSession,人家又问NSURLSesstion和NSURLConnection有什么区别，瞬间傻眼了，支支吾吾只是说出了缓存策略的不同。亡羊补牢，为时未晚，这篇博客就讲解一下它们两者到底有什么区别。</p>
<a id="more"></a>
<h4 id="使用现状"><a href="#使用现状" class="headerlink" title="使用现状"></a>使用现状</h4><p>NSURLSession是NSURLConnection的替代者，在2013年苹果全球开发者大会上（WWDC2013）随iOS7一起发布的，是对NSURLConnection进行了重构优化后的新的网络接口。从iOS9开始，NSURLConnection中发送请求的两个方法已经过期（同步请求，异步请求）,初始化网络连接的方法也被设置为过期，系统不再推荐使用，建议使用NSURLSession发送网络请求。NSURLConnection被废弃的主要接口：</p>
<pre><code>- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate startImmediately:(BOOL)startImmediately NS_DEPRECATED(10_5, 10_11, 2_0, 9_0, &quot;Use NSURLSession (see NSURLSession.h)&quot;) __WATCHOS_PROHIBITED;

- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate NS_DEPRECATED(10_3, 10_11, 2_0, 9_0, &quot;Use NSURLSession (see NSURLSession.h)&quot;) __WATCHOS_PROHIBITED;
+ (nullable NSURLConnection*)connectionWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate NS_DEPRECATED(10_3, 10_11, 2_0, 9_0, &quot;Use NSURLSession (see NSURLSession.h)&quot;) __WATCHOS_PROHIBITED;
//异步请求
+ (void)sendAsynchronousRequest:(NSURLRequest*) request
                          queue:(NSOperationQueue*) queue
              completionHandler:(void (^)(NSURLResponse* __nullable response, NSData* __nullable data, NSError* __nullable connectionError)) handler NS_DEPRECATED(10_7, 10_11, 5_0, 9_0, &quot;Use [NSURLSession dataTaskWithRequest:completionHandler:] (see NSURLSession.h&quot;) __WATCHOS_PROHIBITED;
//同步请求             
+ (nullable NSData *)sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse * __nullable * __nullable)response error:(NSError **)error NS_DEPRECATED(10_3, 10_11, 2_0, 9_0, &quot;Use [NSURLSession dataTaskWithRequest:completionHandler:] (see NSURLSession.h&quot;) __WATCHOS_PROHIBITED;
</code></pre><h4 id="普通任务和上传"><a href="#普通任务和上传" class="headerlink" title="普通任务和上传"></a>普通任务和上传</h4><p>NSURLSession针对下载/上传等复杂的网络操作提供了专门的解决方案，针对普通、上传和下载分别对应三种不同的网络请求任务：NSURLSessionDataTask,NSURLSessionUploadTask和NSURLSessionDownloadTask。创建的task都是挂起状态，需要resume才能启动。</p>
<p>当服务器返回的数据较小时,NSURLSession与NSURLConnection执行普通任务的操作步骤没有区别。<br>执行上传任务时，NSURLSession与NSURLConnection一样需要设置POST请求的请求体进行上传。</p>
<h4 id="下载任务方式"><a href="#下载任务方式" class="headerlink" title="下载任务方式"></a>下载任务方式</h4><p>NSURLConnection下载文件时，先是将整个文件下载到内存，然后再写入到沙盒，如果文件比较大，就会出现内存暴涨的情况。</p>
<p>而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件中，不会出现内存暴涨的情况，但是在下载完成后会把tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。（后面会详细说）</p>
<h4 id="请求方法的控制"><a href="#请求方法的控制" class="headerlink" title="请求方法的控制"></a>请求方法的控制</h4><p>NSURLConnection实例化对象，实例化开始，默认请求就发送(同步发送),不需要调用start方法。而cancel可以停止请求的发送，停止后不能继续访问，需要创建新的请求。</p>
<p>NSURLSession有三个控制方法，取消(cancel)、暂停(suspend)、继续(resume)，暂停以后可以通过继续恢复当前的请求任务。</p>
<h4 id="断点续传的方式"><a href="#断点续传的方式" class="headerlink" title="断点续传的方式"></a>断点续传的方式</h4><p>NSURLConnection进行断点下载，通过设置访问请求的HTTPHeaderField的Range属性，开启运行循环，NSURLConnection的代理方法作为运行循环的事件源，接收到下载数据时代理方法就会持续调用，并使用NSOutputStream管道流进行数据保存。</p>
<p>NSURLSession进行断点下载，当暂停下载任务后，如果downloadTask（下载任务）为非空，调用<code>cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler</code>这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个NSData参数resumeData，如果resumeData非空，我们就保存这个对象到视图控制器的resumeData属性中，在点击再次下载时，通过调用<code>[ [self.session downloadTaskWithResumeData:self.resumeData]resume]</code>方法进行继续下载操作</p>
<p>经过以上比较可以发现，使用NSURLSession进行断点下载更加便捷.</p>
<h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>NSURLSession的构造方法<code>（sessionWithConfiguration:delegate:delegateQueue）</code>中有一个NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比较与NSURLConnection依赖与一个全局的配置对象，缺乏灵活性而言，NSURLSession有很大的改进了。(关于配置信息，后面会讲解到)</p>
<p>通过以上几点，大概知道了NSURLSession和NSURLConnection的区别，想必下载再遇到这样的问题不会支支吾吾了。下面来点NSURLSession的干货。</p>
<hr>
<p><strong><p align="center">干货开始</p></strong></p>
<hr>
<h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h3><p>NSURLSession 为 HTTP 数据传输提供一系列的接口，而使用 NSURLSession 总共只需要三步：</p>
<ol>
<li>创建NSURLSession对象</li>
<li>通过 NSURLSession 的实例创建 Task</li>
<li>执行 Task</li>
</ol>
<h5 id="如何获取Session对象"><a href="#如何获取Session对象" class="headerlink" title="如何获取Session对象"></a>如何获取Session对象</h5><p> 1.获取默认的 Session 对象</p>
<pre><code>/*
 * 用于基本的网络请求，可以几行代码就获取 URL 的内容，使用简单
 * 无法不断的获取服务器返回的数据
 * 无法修改默认的连接行为
 * 身份验证的能力有限
 * 任务在后台时无法上传和下载
 */
+ (NSURLSession *)sharedSession;
</code></pre><p> 2.自定义 Session 对象</p>
<pre><code> // 不用代理
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;
// 用代理
+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration
                                  delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate
                             delegateQueue:(nullable NSOperationQueue *)queue;
</code></pre><p>在使用自定义方式创建NSURLSession对像时，都需要传入一个NSURLSessionConfiguration参数，这个参数是对Session的网络请求的基本配置。那这个NSURLSessionConfiguration都有哪些配置呢？接着往下看</p>
<h3 id="NSURLSessionConfiguration"><a href="#NSURLSessionConfiguration" class="headerlink" title="NSURLSessionConfiguration"></a>NSURLSessionConfiguration</h3><p>有三个方法来创建NSURLSessionConfiguration:</p>
<ul>
<li><strong>defaultSessionConfiguration</strong> 使用全局的cache，cookie,使用硬盘来缓存数据。</li>
<li><strong>ephemeralSessionConfiguration</strong> 临时session配置，与默认配置相比，这个配置不会将缓存、cookie等存在本地，只会存在内存里，所以当程序退出时，所有的数据都会消失</li>
<li><strong>backgroundSessionConfiguration</strong> 后台session配置，与默认配置类似，不同的是会在后台开启另一个线程来处理网络数据。</li>
</ul>
<p>一旦创建了NSURLSessionConfiguration就可以给它设置各种属性</p>
<p><strong>看NSURLSessionConfiguration的头文件:</strong></p>
<pre><code>@interface NSURLSessionConfiguration : NSObject &lt;NSCopying&gt;

/* 三种创建方式 */

+ (NSURLSessionConfiguration *)defaultSessionConfiguration;
+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;
+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0);

/* 当使用上述第三种方式创建后台sessionConfiguration时可以读到初始化时传入的唯一标识，其他创建方式都为空 */
@property (nullable, readonly, copy) NSString *identifier;

/* 
缓存策略，默认值是NSURLRequestUseProtocolCachePolicy
 */
@property NSURLRequestCachePolicy requestCachePolicy;

/* 给request指定每次接收数据超时间隔，如果下一次接受新数据用时超过该值，则发送一个请求超时给该request。默认为60s */
@property NSTimeInterval timeoutIntervalForRequest;

/* 给指定resource设定一个超时时间，resource需要在时间到达之前完成。默认是7天。 */
@property NSTimeInterval timeoutIntervalForResource;

/* 指定网络传输类型。精切指出传输类型，可以让系统快速响应，提高传输质量，延长电池寿命等。
typedef NS_ENUM(NSUInteger, NSURLRequestNetworkServiceType)
{
    NSURLNetworkServiceTypeDefault = 0,    // 普通网络传输，默认使用这个
    NSURLNetworkServiceTypeVoIP = 1,    // 网络语音通信传输，只能在VoIP使用
    NSURLNetworkServiceTypeVideo = 2,    // 影像传输
    NSURLNetworkServiceTypeBackground = 3, // 网络后台传输，优先级不高时可使用。对用户不需要的网络操作可使用
    NSURLNetworkServiceTypeVoice = 4       // 语音传输
};
 */
@property NSURLRequestNetworkServiceType networkServiceType;

/* 是否使用蜂窝网络，默认是yes. */
@property BOOL allowsCellularAccess;

/* 是否由系统根据性能自动裁量后台任务。默认值是NO。同sessionSendsLaunchEvent一样，只对后台configuration有效。 */
@property (getter=isDiscretionary) BOOL discretionary NS_AVAILABLE(10_10, 7_0);

/* 
如果要为app的插件提供session，需要给这个值赋值
 */
@property (nullable, copy) NSString *sharedContainerIdentifier NS_AVAILABLE(10_10, 8_0);

/* 
 表示当后台传输结束时，是否启动app.这个属性只对 后台sessionConfiguration 生效，其他configuration类型会自动忽略该值。默认值是YES。
 */
@property BOOL sessionSendsLaunchEvents NS_AVAILABLE(NA, 7_0);

/* 
指定了会话连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性,默认为NULL
*/
@property (nullable, copy) NSDictionary *connectionProxyDictionary;

/* 确定是否支持SSLProtocol版本的会话
 */
@property SSLProtocol TLSMinimumSupportedProtocol;

/* 
确定是否支持SSLProtocol版本的会话
*/
@property SSLProtocol TLSMaximumSupportedProtocol;

/* 
它可以被用于开启HTTP管道，这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的
 */
@property BOOL HTTPShouldUsePipelining;

/* 
默认为yes,是否提供来自shareCookieStorge的cookie，如果想要自己提供cookie，可以使用HTTPAdditionalHeaders来提供。
 */
@property BOOL HTTPShouldSetCookies;

/* Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage. */
@property NSHTTPCookieAcceptPolicy HTTPCookieAcceptPolicy;

/* 
指定了一组默认的可以设置出站请求的数据头。这对于跨会话共享信息，如内容类型，语言，用户代理，身份认证，是很有用的。
例如：
    @{@&quot;Accept&quot;: @&quot;application/json&quot;,
     @&quot;Accept-Language&quot;: @&quot;en&quot;,
     @&quot;Authorization&quot;: authString,
     @&quot;User-Agent&quot;: userAgentString
   }
 */
@property (nullable, copy) NSDictionary *HTTPAdditionalHeaders;

/* 
同时连接一个host的最大数。iOS默认是4.APP是作为一个整体来看的
 */
@property NSInteger HTTPMaximumConnectionsPerHost;

/* 
存储cookie，清除存储，直接set为nil即可。
对于默认和后台的session，使用sharedHTTPCookieStorage。
对于短暂的session，cookie仅仅储存到内存，session失效时会自动清除。
 */
@property (nullable, retain) NSHTTPCookieStorage *HTTPCookieStorage;

/* 
证书存储，如果不使用，可set为nil.
默认和后台session，默认使用的sharedCredentialStorage.
短暂的session使用一个私有存储在内存中。session失效会自动清除。
 */
@property (nullable, retain) NSURLCredentialStorage *URLCredentialStorage;

/* 
缓存NSURLRequest的response。
默认的configuration，默认值的是sharedURLCache。
后台的configuration，默认值是nil
短暂的configuration，默认一个私有的cache于内存，session失效，cache自动清除。
*/
@property (nullable, retain) NSURLCache *URLCache;

/* Enable extended background idle mode for any tcp sockets created.    Enabling this mode asks the system to keep the socket open
 *  and delay reclaiming it when the process moves to the background (see https://developer.apple.com/library/ios/technotes/tn2277/_index.html) 
 */
@property BOOL shouldUseExtendedBackgroundIdleMode NS_AVAILABLE(10_11, 9_0);

/* 
处理NSURLRequest的NSURLProtocol的子类。
重要:对后台Session失效。
 */
@property (nullable, copy) NSArray&lt;Class&gt; *protocolClasses;

@end
</code></pre><p>现在，我们知道如何来创建一个Session对象了，创建完Session对象，根据一个Request对象我们就可以发送网络请求了。下面看一下NSURLSession的头文件中的这些方法，如图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/NSURLSession1.png?raw=true"><br></div>

<p>从这些方法中得知，分别返回了<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>，<code>NSURLSessionStreamTask</code> 这四个类的对象，那么这四个类是干什么呢？我们接着往下看。</p>
<h3 id="URLSessionTask"><a href="#URLSessionTask" class="headerlink" title="URLSessionTask"></a>URLSessionTask</h3><p>NSURLSessionTask是一个抽象类，其下有4个实体子类可以直接使用：<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>、<code>NSURLSessionStreamTask</code>。这四个子类封装了现代程序四个最基本的网络任务：获取数据，比如JSON或者XML，上传文件和下载文件还有数据流的获取。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/NSURLSessionTask.png?raw=true"><br></div>

<p>NSURLSession比NSURLConnection最方便的地方就是任务可以暂停，继续。在网络请求中，真正去执行下载或者上传任务的就是URLSessionTask，我们来看一下它常用的方法：</p>
<p><code>- (void)resume;</code> 当使用NSURLSession创建一个NSURLSessionTask任务时，要手动调用此方法，任务才会开启，而NSURLConnection默认开启。</p>
<p><code>- (void)suspend;</code> 暂停任务方法，手动调用会暂停当前任务，再次开启此任务时，会从紧接上次任务开始，会面会说到如何暂停任务再开启任务。</p>
<p><code>- (void)cancel;</code> 取消任务。</p>
<p>NSURLSessionTask还有个属性，<code>@property (readonly) NSURLSessionTaskState state;</code> 此属性标识当前任务的状态，枚举类型</p>
<pre><code>typedef NS_ENUM(NSInteger, NSURLSessionTaskState) {
    NSURLSessionTaskStateRunning = 0,                     /* 正在执行 */
    NSURLSessionTaskStateSuspended = 1,                   /* 暂停状态 */
    NSURLSessionTaskStateCanceling = 2,                   /* 取消状态*/
    NSURLSessionTaskStateCompleted = 3,                   /* 任务完成状态 */
}
</code></pre><p>上面说到的四个类，都直接或间接继承NSURLSessionTask，所有NSURLSessionTask的方法或者属性这四个类都有，那么，简单说一下这四个类都是干什么的。</p>
<h4 id="NSURLSessionDataTask"><a href="#NSURLSessionDataTask" class="headerlink" title="NSURLSessionDataTask"></a>NSURLSessionDataTask</h4><p>NSURLSessionDataTask是开发中使用频率最高的，我们平常使用的GET和POST请求都是通过它来实现的，如果请求的数据简单并且不需要对获取的数据进行复杂操作，我们使用 Block 解析返回的数据即可。具体代码如下：</p>
<h5 id="简单-Get-请求"><a href="#简单-Get-请求" class="headerlink" title="简单 Get 请求"></a>简单 Get 请求</h5><pre><code>/**
 *  简单 GET 请求
  */
- (void)getWithsharedSession
{
  // 获取默认 Session
  NSURLSession *session = [NSURLSession sharedSession];
  // 创建 URL
  NSURL *url = [NSURL URLWithString:@&quot;https://www.baidu.com/s?wd=test&quot;];
  // 创建任务 task
  NSURLSessionDataTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
    // 获取数据后解析并输出
     NSString *dataStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    NSLog(@&quot;%@&quot;,dataStr);
  }];
  // 启动任务
  [task resume];
}
</code></pre><h5 id="简单-POST-请求"><a href="#简单-POST-请求" class="headerlink" title="简单 POST 请求"></a>简单 POST 请求</h5><pre><code>/**
 *  简单 Post 请求，POST 和 GET 请求在于对 request 的处理不同，其余和 GET 相同
 */
- (void)postWithSharedSession
{
  // 获取默认 Session
  NSURLSession *session = [NSURLSession sharedSession];
  // 创建 URL
  NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/login&quot;];
  // 创建 request
  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
  // 请求方法
  request.HTTPMethod = @&quot;POST&quot;;
  // 请求体
  request.HTTPBody = [@&quot;username=1234&amp;pwd=4321&quot; dataUsingEncoding:NSUTF8StringEncoding];
  // 创建任务 task
  NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
          // 获取数据后解析并输出
          NSLog(@&quot;%@&quot;,[NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);
  }];
  // 启动任务
  [task resume];
}
</code></pre><p>另外我们也可以设置session的代理来实时的监听数据，我们可以使用NSURLSession的<code>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;</code>和<code>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue;</code>这两个方法来设置代理，具体的协议为<code>NSURLSessionDelegate</code>，它有四个直接或间接子协议<code>NSURLSessionTaskDelegate</code>，<code>NSURLSessionDownloadDelegate</code>和 <code>NSURLSessionStreamDelegate</code>、<code>NSURLSessionDataDelegate</code>。具体代理方法如下：</p>
<pre><code>//创建有代理的session
- (void)sessionDataDelegate
{
    // 创建带有代理方法的自定义 session
    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];

    // 创建任务
    NSURLSessionDataTask *task = [session dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://120.25.226.186:32812/login?username=1234&amp;pwd=4321&quot;]]];

    // 启动任务
    [task resume];
}

#pragma mark -
#pragma mark - NSURLSessionDelegate

// 1. 接收到服务器的响应
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler
{
    NSLog(@&quot;接收到服务器的响应&quot;);
    // 必须设置对响应进行允许处理才会执行后面两个操作。
    completionHandler(NSURLSessionResponseAllow);
}

// 2. 接收到服务器的数据（可能调用多次）
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data {
    // 处理每次接收的数据
    NSLog(@&quot;接受到服务器的数据%s&quot;,__func__);
}

// 3. 请求成功或者失败（如果失败，error有值）
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {
    // 请求完成,成功或者失败的处理
    NSLog(@&quot;SessionTask %s&quot;,__func__);
}
</code></pre><h4 id="NSURLSessionDownloadTask"><a href="#NSURLSessionDownloadTask" class="headerlink" title="NSURLSessionDownloadTask"></a>NSURLSessionDownloadTask</h4><p>NSURLSessionDownloadTask在下载文件的时候，是将数据一点点地写入本地的临时文件。所以在 completionHandler 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：</p>
<pre><code>/**
 *  NSURLSessionDownloadTask 下载任务
 */
- (void)downLoad
{
    NSURLSession *session = [NSURLSession sharedSession];
    NSURL *url = [NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/images/minion_01.png&quot;] ;
    NSURLSessionDownloadTask *task = [session downloadTaskWithURL:url completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error) {
        // location 是沙盒中 tmp 文件夹下的一个临时 url，文件下载后会存到这个位置，由于 tmp 中的文件随时可能被删除，所以我们需要自己需要把下载的文件挪到 Caches 文件夹中
        NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename];
        // 剪切文件
        [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:path] error:nil];
        NSLog(@&quot;%@&quot;,[NSThread currentThread]);
        //切记当前为子线程，
        dispatch_async(dispatch_get_main_queue(), ^{
            self.imageView.image = [UIImage imageNamed:path];
        });

    }];
    // 启动任务
    [task resume];
}
</code></pre><p>代理方法下载</p>
<pre><code>/**
 *  NSURLSessionDownloadTask 代理
 */
- (void)sessionDownloadTaskDelegate
{
  // 创建带有代理方法的自定义 session
  NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];

  // 创建任务
  NSURLSessionDownloadTask *task = [session downloadTaskWithURL:[NSURL URLWithString:@&quot;http://120.25.226.186:32812/resources/images/minion_02.png&quot;]];

  // 启动任务
  [task resume];
}
#pragma mark -
#pragma mark -NSURLSessionDownloadDelegate
/**
 *  写入临时文件时调用
 *  @param bytesWritten              本次写入大小
 *  @param totalBytesWritten         已写入文件大小
 *  @param totalBytesExpectedToWrite 请求的总文件的大小
 */
- (void)URLSession:(NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite
{
    //可以监听下载的进度
  CGFloat progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
  NSLog(@&quot;downloadTask %f&quot;,progress);
}

// 2. 下载完成调用
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location
{
  // location 还是一个临时路径,需要自己挪到需要的路径（caches 文件夹）
  NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];
  [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:filePath] error:nil];
  NSLog(@&quot;downloadTask 移动文件路径&quot;);
}
</code></pre><h5 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h5><p>说一下开发中经常用到的断点续传。在开发中，我们经常由于某种原因，在下载或上传的时候往往不能一次性下载或上传完，有可能下载或上传了一半就终止了，这时候当条件满足继续下载或上传时，我们不希望从头开始，这时候就可以使用断点续传。它的大概思路是：</p>
<ul>
<li>某种限制，续传暂停</li>
<li>将暂停后数据（当前数据）保存起来–_resumeData = resumeData;</li>
<li>条件允许续传时，使用resumeData创建新的NSURLSessionTask</li>
</ul>
<p>代码：</p>
<pre><code>- (IBAction)startDowning:(id)sender {


    if (_resumeData) {
        _downloadTask = [_session downloadTaskWithResumeData:_resumeData];
    }else {
        _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:nil];
        _request = [[NSURLRequest alloc] initWithURL:[NSURL URLWithString:@&quot;http://image.baidu.com/search/down?tn=download&amp;ipn=dwnl&amp;word=download&amp;ie=utf8&amp;fr=result&amp;url=http%3A%2F%2Fb.zol-img.com.cn%2Fdesk%2Fbizhi%2Fimage%2F6%2F960x600%2F1427787678554.jpg&amp;thumburl=http%3A%2F%2Fimg3.imgtn.bdimg.com%2Fit%2Fu%3D1996019669%2C1779575266%26fm%3D21%26gp%3D0.jpg&quot;]];
        _downloadTask = [_session downloadTaskWithRequest:_request];
    }
    [_downloadTask resume];
}

- (IBAction)stopDowning:(id)sender {
    if (_downloadTask) {
        __weak typeof (self)weakSelf = self;
        [_downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) {
            NSLog(@&quot;%@&quot;,resumeData);
            weakSelf.resumeData = resumeData;
            weakSelf.downloadTask = nil;
        }];
    }
}

#pragma mark -
#pragma mark - NSURLSessionDownloadDelegate

- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location {
    NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:downloadTask.response.suggestedFilename];
    // 剪切文件
    [[NSFileManager defaultManager] moveItemAtURL:location toURL:[NSURL fileURLWithPath:path] error:nil];

    dispatch_async(dispatch_get_main_queue(), ^{
        self.imageView.image = [UIImage imageNamed:path];
    });
}
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
    CGFloat progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
    NSLog(@&quot;downloadTask %f&quot;,progress);
    dispatch_async(dispatch_get_main_queue(), ^{
        self.progressView.progress = progress;
    });

}
</code></pre><p><strong>注意：</strong>上面的代码是不会断点续传的，原因是这个图片的url不支持断点续传，在断点续传时，要和服务器配合好。</p>
<h4 id="NSURLSessionUploadTask"><a href="#NSURLSessionUploadTask" class="headerlink" title="NSURLSessionUploadTask"></a>NSURLSessionUploadTask</h4><p>在 NSURLSession 中，文件上传主要使用两种方式：</p>
<pre><code>- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;
- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;
</code></pre><p>我们这里使用第二个方法，表单的形式上传数据</p>
<pre><code>- (void)upload {
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://api.weibo.com/2/statuses/public_timeline.json&quot;]];
    //设置HTTP请求方式  GET / POST
    [request setHTTPMethod:@&quot;POST&quot;];
    //设置请求头
    NSString *boundary = @&quot;hwg&quot;;
    [request setValue:[NSString stringWithFormat: @&quot;multipart/form-data;%@&quot;, boundary]forHTTPHeaderField:@&quot;Content-type&quot;];
    //设置请求体
    //获取上传的图片的data
    NSData *data = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;xiaoxin&quot; ofType:@&quot;jpeg&quot;]];
    //此处添加需要看清楚内容
    NSData *body =  [self httpFormDataBodyWithBoundary:boundary params:@{@&quot;access_token&quot;:@&quot;2.00cYYKWF6EKpiB3883361b1dJiZ4eD&quot;,@&quot;status&quot;:@&quot;哈哈，这是我测试NSURLSession上传文件的微博&quot;} fieldName:@&quot;pic&quot; fileName:@&quot;pic.png&quot; fileContentType:@&quot;image/png&quot; data:data];
    NSURLSession *session = [NSURLSession sharedSession];
    NSURLSessionUploadTask *upload_task = [session uploadTaskWithRequest:request fromData:body completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
        NSLog(@&quot;upload  success&quot;);
    }];
    //必须要 resume
    [upload_task resume];
}

#pragma mark-拼接请求体
- (NSData *)httpFormDataBodyWithBoundary:(NSString *)boundary
                                 params:(NSDictionary *)params
                              fieldName:(NSString *)fieldName
                               fileName:(NSString *)fileName
                        fileContentType:(NSString *)fileContentType
                                   data:(NSData *)fileData {

    NSString *preBoundary = [NSString stringWithFormat:@&quot;--%@&quot;,boundary];
    NSString *endBoundary = [NSString stringWithFormat:@&quot;--%@--&quot;,boundary];
    NSMutableString *body = [[NSMutableString alloc] init];
    //遍历
    for (NSString *key in params) {
        //得到当前的key
        //如果key不是当前的pic，说明value是字符类型，比如name：Boris
        //添加分界线，换行，必须使用\r\n
        [body appendFormat:@&quot;%@\r\n&quot;,preBoundary];
        //添加字段名称换2行
        [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;\r\n\r\n&quot;,key];
        //添加字段值
        [body appendFormat:@&quot;%@\r\n&quot;,[params objectForKey:key]];

    }
    //添加分界线，换行
    [body appendFormat:@&quot;%@\r\n&quot;,preBoundary];
    //声明pic字段，文件名为boris.png
    [body appendFormat:@&quot;Content-Disposition: form-data; name=\&quot;%@\&quot;; filename=\&quot;%@\&quot;\r\n&quot;,fieldName,fileName];
    //声明上传文件的格式
    [body appendFormat:@&quot;Content-Type: %@\r\n\r\n&quot;,fileContentType];
    //声明结束符
    NSString *endStr = [NSString stringWithFormat:@&quot;\r\n%@&quot;,endBoundary];
    //声明myRequestData，用来放入http  body
    NSMutableData *myRequestData = [NSMutableData data];
    //将body字符串转化为UTF8格式的二进制
    [myRequestData appendData:[body dataUsingEncoding:NSUTF8StringEncoding]];
    //将image的data加入
    [myRequestData appendData:fileData];
    //加入结束符--hwg--
    [myRequestData appendData:[endStr dataUsingEncoding:NSUTF8StringEncoding]];
    return myRequestData;
}
</code></pre><p>这里我们需要拼接一个表单数据，才能够上传数据。 当然，我们也可以用代理方法来监听上传的进度</p>
<pre><code>- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task
   didSendBodyData:(int64_t)bytesSent
    totalBytesSent:(int64_t)totalBytesSent
totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {
    CGFloat progress = 1.0 * totalBytesSent / bytesSent;
    NSLog(@&quot;downloadTask %f&quot;,progress);
}
</code></pre><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>以上就是我今天总结的，哪里有问题还希望大家提出意见。其实在开发中，我们很少使用到这些，因为总是有一些牛人为我们封装了各种功能的强大库，比如网络类，最常用的就是AFNetworking。人家的库为什么好用，说白了就是各种情况都考虑到了。所有我们要学的还是人家的编程思想。接下来，我会做一个专题，研究一下各大平常使用到的库，它们到底牛在哪里，敬请阅读！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天去面试，被问了一道AFNetworking2.0和3.0有什么区别，当时心想，这谁不知道啊，随口答到：2.0使用的NSURLConnection,3.0使用的是NSURLSession,人家又问NSURLSesstion和NSURLConnection有什么区别，瞬间傻眼了，支支吾吾只是说出了缓存策略的不同。亡羊补牢，为时未晚，这篇博客就讲解一下它们两者到底有什么区别。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="NSURLSession" scheme="http://www.guiyongdong.com/tags/NSURLSession/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://www.guiyongdong.com/2016/11/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.guiyongdong.com/2016/11/15/排序算法总结/</id>
    <published>2016-11-15T03:40:05.000Z</published>
    <updated>2016-11-16T08:26:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十大排序算法比较图"><a href="#十大排序算法比较图" class="headerlink" title="十大排序算法比较图"></a>十大排序算法比较图</h3><hr>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/15.png?raw=true"><br></div>



<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<p><strong>算法描述</strong><br><strong>冒冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</strong></p>
<p><strong>算法实现</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortBubble:(NSMutableArray *)targetArray {
    BOOL flag = true;  //flag 用来做标记
    NSInteger num = 0; //标记总比较次数
    for (NSInteger i = 0; i &lt; targetArray.count&amp;&amp;flag; i++) { //若flag为true  则退出循环
        flag = false;   //初始是false
        for (NSInteger j = 0; j &lt; targetArray.count - i-1; j++) {
            num++;
            NSLog(@&quot;---%ld&quot;,num);
            if ([targetArray[j] integerValue] &gt; [targetArray[j+1] integerValue]) {
                id temp = targetArray[j];
                targetArray[j] = targetArray[j+1];
                targetArray[j+1] = temp;
                flag = true;
            }
        }
    }
    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><a id="more"></a>
<p><strong>时间复杂度:</strong><br>分析一下它的时间复杂度。当最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据上面的代码可以推断就是n-1次的比较。没有数据交换，时间复杂度是O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较:1+2+3+…+(n-1)=n(n-1)/2次，因此总的时间复杂度是O(n<sup>2</sup>)。</p>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/16.gif?raw=true"><br></div>



<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><hr>
<p><strong>算法描述</strong><br><strong>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</strong></p>
<p><strong>算法实现</strong></p>
<ol>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortSimple:(NSMutableArray *)targetArray {
    NSInteger min;
    for (NSInteger i = 0; i &lt; targetArray.count - 1; i++) {
        min = i; //将当前下标定义为最小值下标
        for (NSInteger j = i + 1; j &lt; targetArray.count; j++) {
            if (targetArray[min] &gt; targetArray[j]) { //如果有小于当前最小值得关键字
                min = j; //将此关键字的下标赋值给min
            }
        }
        if (i != min) {  //如果min和i不相等  说明找到最小值，交换
            id temp = targetArray[i];
            targetArray[i] = targetArray[min];
            targetArray[min] = temp;
        }
    }
    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><p><strong>时间复杂度：</strong><br>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第i趟排序需要进行n-i次关键字的比较，此时需要比较n-1+n-2+…+1=n(n-1)/2次。而对于交换次数而言，当最好的时候，交换为0次，最差的时候，也就是初始降序时2，交换次数为n-1次，基于最终的排序时间是比较与交换的次数总和，因此，总的时间复杂度依然为O(n<sup>2</sup>)。</p>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/17.gif?raw=true"><br></div>


<p>应该说，尽管与冒泡排序的时间复杂度同为O(n<sup>2</sup>)，但简单选择排序的性能上还是要略优于冒泡排序。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><hr>
<p><strong>算法描述</strong></p>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p><strong>算法实现</strong></p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortInsertion:(NSMutableArray *)targetArray {
    for (NSInteger i = 1; i &lt; targetArray.count; i++) {
        id key = targetArray[i];
        NSInteger j = i - 1;
        while (j &gt;= 0 &amp;&amp; targetArray[j] &gt; key) {
            targetArray[j+1] = targetArray[j];
            j--;
        }
        targetArray[j+1]=key;
    }
    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：输入数组按升序排列。T(n) = O(n)</li>
<li>最坏情况：输入数组按降序排列。T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/18.gif?raw=true"><br></div>


<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr>
<p><strong>算法描述</strong><br>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p>
<p><strong>算法实现</strong><br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortShell:(NSMutableArray *)targetArray {
    NSInteger increment = targetArray.count;
    NSInteger i,j;
    do {
        increment = increment/3+1;//增量序列
        for (i=increment; i&lt;targetArray.count; i++) {
            if ([targetArray[i] integerValue] &lt; [targetArray[i-increment] integerValue]) {
                id temp = targetArray[i];
                for (j=i-increment; j&gt;=0&amp;&amp;[targetArray[j] integerValue] &gt; [temp integerValue]; j-=increment) {
                    targetArray[j+increment] = targetArray[j];
                }
                targetArray[j+increment] = temp;
            }
        }

    } while (increment &gt; 1);

    NSLog(@&quot;%@&quot;,targetArray);
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog n)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/19.jpg?raw=true"><br></div>


<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<p><strong>算法描述</strong><br>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>算法实现</strong></p>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortHeap:(NSMutableArray *)targetArray {
    NSInteger heapSize = targetArray.count;
    id temp;
    //建堆
    for (NSInteger i = heapSize/2-1; i&gt;=0; i--) {
        [self heapify:targetArray index:i lenght:heapSize];
    }
    //堆排序
    for (NSInteger j = heapSize-1; j &gt;= 1; j--) {
        temp = targetArray[0];
        targetArray[0] = targetArray[j];
        targetArray[j] = temp;
        [self heapify:targetArray index:0 lenght:--heapSize];
    }
    NSLog(@&quot;%@&quot;,targetArray);
}

- (void)heapify:(NSMutableArray *)targetArray index:(NSInteger)x lenght:(NSInteger)len {
    NSInteger l=2*x+1,r=2*x+2,largest=x;
    id temp;
    if (l &lt; len &amp;&amp; [targetArray[l] integerValue] &gt; [targetArray[largest] integerValue]) {
        largest = l;
    }
    if (r &lt; len &amp;&amp; [targetArray[r] integerValue] &gt; [targetArray[largest] integerValue]) {
        largest = r;
    }
    if (largest != x) {
        temp = targetArray[x];
        targetArray[x] = targetArray[largest];
        targetArray[largest] = temp;
        [self heapify:targetArray index:largest lenght:len];
    }
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/20.gif?raw=true"><br></div>


<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<p><strong>算法描述</strong><br>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p><strong>算法实现</strong></p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>- (NSMutableArray *)sortMerge:(NSMutableArray *)targetArray {
    NSInteger len = targetArray.count;
    NSInteger middle = len/2;
    if (len &lt; 2) {
        return targetArray;
    }
    NSMutableArray *leftArray = [NSMutableArray arrayWithArray:[targetArray subarrayWithRange:NSMakeRange(0, middle)]];
    NSMutableArray *rightArray = [NSMutableArray arrayWithArray:[targetArray subarrayWithRange:NSMakeRange(middle, len-middle)]];
    NSMutableArray *array = [self merge:[self sortMerge:leftArray] right:[self sortMerge:rightArray]];
    NSLog(@&quot;%@&quot;,array);
    return array;

}

- (NSMutableArray *)merge:(NSMutableArray *)leftArray right:(NSMutableArray *)rightArray {
    NSMutableArray *resultArray = [NSMutableArray array];
    while (leftArray.count &amp;&amp; rightArray.count) {
        if ([leftArray[0] integerValue] &lt;= [rightArray[0] integerValue]) {
            [resultArray addObject:leftArray[0]];
            [leftArray removeObjectAtIndex:0];
        }else {
            [resultArray addObject:rightArray[0]];
            [rightArray removeObjectAtIndex:0];
        }
    }
    while (leftArray.count) {
        [resultArray addObject:leftArray[0]];
        [leftArray removeObjectAtIndex:0];
    }
    while (rightArray.count) {
        [resultArray addObject:rightArray[0]];
        [rightArray removeObjectAtIndex:0];
    }

    return resultArray;
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/21.gif?raw=true"><br></div>


<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr>
<p><strong>算法描述</strong><br>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><strong>算法实现</strong><br>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><strong>代码：</strong></p>
<pre><code>- (void)sortQuick:(NSMutableArray *)targetArray {
    [self quick:targetArray left:0 right:targetArray.count-1];
    NSLog(@&quot;%@&quot;,targetArray);
}

- (void)quick:(NSMutableArray *)targetArray left:(NSInteger)left right:(NSInteger)right {
    NSInteger pivot;
    if (left &lt; right) {
        pivot = [self partition:targetArray left:left right:right];
        [self quick:targetArray left:left right:pivot-1];
        [self quick:targetArray left:pivot+1 right:right];
    }
}

- (NSInteger)partition:(NSMutableArray *)targetArray left:(NSInteger)left right:(NSInteger)right {
    id pivotKey = targetArray[left];
    id temp;
    while (left &lt; right) {
        while (left &lt; right &amp;&amp; [targetArray[right] integerValue] &gt; [pivotKey integerValue]) {
            right--;
        }
        temp = targetArray[left];
        targetArray[left] = targetArray[right];
        targetArray[right] = temp;
        while (left &lt; right &amp;&amp; [targetArray[left] integerValue] &lt;= [pivotKey integerValue]) {
            left++;
        }
        temp = targetArray[left];
        targetArray[left] = targetArray[right];
        targetArray[right] = temp;
    }

    return left;
}
</code></pre><p><strong>时间复杂度：</strong></p>
<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
<p><strong>动图演示：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/22.gif?raw=true"><br></div>














]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;十大排序算法比较图&quot;&gt;&lt;a href=&quot;#十大排序算法比较图&quot; class=&quot;headerlink&quot; title=&quot;十大排序算法比较图&quot;&gt;&lt;/a&gt;十大排序算法比较图&lt;/h3&gt;&lt;hr&gt;
&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/15.png?raw=true&quot; /&gt;&lt;br&gt;&lt;/div&gt;



&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;算法描述&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;冒冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法实现&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大，就交换它们两个；&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个；&lt;/li&gt;
&lt;li&gt;重复步骤1~3，直到排序完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)sortBubble:(NSMutableArray *)targetArray {
    BOOL flag = true;  //flag 用来做标记
    NSInteger num = 0; //标记总比较次数
    for (NSInteger i = 0; i &amp;lt; targetArray.count&amp;amp;&amp;amp;flag; i++) { //若flag为true  则退出循环
        flag = false;   //初始是false
        for (NSInteger j = 0; j &amp;lt; targetArray.count - i-1; j++) {
            num++;
            NSLog(@&amp;quot;---%ld&amp;quot;,num);
            if ([targetArray[j] integerValue] &amp;gt; [targetArray[j+1] integerValue]) {
                id temp = targetArray[j];
                targetArray[j] = targetArray[j+1];
                targetArray[j+1] = temp;
                flag = true;
            }
        }
    }
    NSLog(@&amp;quot;%@&amp;quot;,targetArray);
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://www.guiyongdong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>查找算法之线性索引查找法</title>
    <link href="http://www.guiyongdong.com/2016/11/14/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>http://www.guiyongdong.com/2016/11/14/查找算法之线性索引查找法/</id>
    <published>2016-11-14T07:28:07.000Z</published>
    <updated>2016-11-15T03:42:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构，<strong>索引就是把一个关键字与它对应的记录相关联的过程，</strong>一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。</p>
<p>索引按照结构可以分为线性索引、树形索引和多级索引。这里只介绍线性索引技术。<strong>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。</strong>这里介绍三种线性索引：<strong>稠密索引、分块索引、倒排索引。</strong></p>
<a id="more"></a>
<h3 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h3><hr>
<p><strong>稠密索引是指在线性索引中，将数据集中的每一个记录对应一个索引项。</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/11.png?raw=true"><br></div>

<p><strong>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列</strong></p>
<p>索引项也有序也就意味着，我们要查找关键字时，可以用到折半，插值，斐波那契等有序查找算法，大大提高了效率。比如上图，我要查找关键字是18的记录，如果直接从右侧的数据表中查找，那只能顺序查找，需要查找6次才可以查到结果。而如果是从左侧的索引表中查找，只需两侧折半查找就可以得到18对应的指针，最终查找到结果。</p>
<p>这显然是稠密索引优点，到时如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说 ，可能就需要反复去访问磁盘，查找性能反而大大下降了。</p>
<h3 id="分块索引"><a href="#分块索引" class="headerlink" title="分块索引"></a>分块索引</h3><hr>
<p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立索引项，从而减少索引项的个数。</p>
<p><strong>分块有序，是把数据集的记录分成了若干块，并且这些快需要满足两个条件：</strong></p>
<ul>
<li><strong>块内无序，</strong>即每一块内的记录不要求有序，当然，如果块内记录有序更理想，不过块内有序需要大量时间和空间的代价，通常要求快内无序。</li>
<li><strong>块间有序,</strong>例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。</li>
</ul>
<p><strong>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引</strong></p>
<p>如图所示，定义的分块索引的索引项结构分三个数据项：</p>
<ul>
<li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块的最大关键字要大;</li>
<li>存储了块中的记录个数，以便于循环时使用;</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li>
</ul>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/12.png?raw=true"><br></div>

<p>在分块索引表中查找，就是分两步进行：</p>
<ol>
<li>在分块索引表中查找关键字所在的块。由于分块索引表是快间有序的，因此很容易利用折半，插值等算法得到结果。</li>
<li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序的，因此只能顺序查找。</li>
</ol>
<p>分块索引的时间复杂度：<br>设n个记录的数据集被平分成m块，每块中有t条记录，显然n=m×t,或者说m=n/t。再假设L<sub>b</sub>为查找索引表的平均查找长度，因最好与最差的等概率原则，所以L<sub>b</sub>的平均长度为(m+1)/2。L<sub>w</sub>为块中查找记录的平均查找长度，同理可知它的平均查找长度为(t+1)/2。这样分块索引查找的平均查找长度为:</p>
<div align="center"><br>ASL<sub>w</sub>=L<sub>b</sub>+L<sub>w</sub>=(m+1)/2+(t+1)/2=(1/2)*((n/t)+t)+1<br></div>

<p>注意上面这个式子的推导是为了让整个分块索引查找长度依赖n和t两个变量。从这里我们得到，平均长度不仅仅取决于数据集的总记录数n，还和每一个块的记录数t有关，最佳的情况就是分的块数m和块中的记录数t相同，此时意味着n=m×t=t<sup>2</sup>,即ASL<sub>w</sub>=(1/2)*((n/t)+t)+1=&radic;n+1</p>
<p>可见，分块索引的效率比之顺序查找的O(n)是高了不少。不过显然它与折半查找的O(logn)相比还是有不小的差距，因此在确定所在块的过程中，由于块间有序，所以可以应用折半，插值等手段来提高效率。</p>
<p>总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据表查找等技术的应用中。</p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><hr>
<p>在我们使用百度或者谷歌搜索的时候，当我们输入某个信息，搜索引擎都会在短时间内给我们一些结果，如图，它是用到什么算法技术实现的高效查找呢？</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/13.png?raw=true"><br></div>

<p>这里简单介绍，也算是最基础的搜索技术——倒排索引。<br>当然，搜索引擎所使用到的算法绝对比这复杂的多。<br>例如我们看如下两句话：</p>
<ol>
<li>Books and friends should be few but good</li>
<li>A good book is a good friend</li>
</ol>
<p>如图所示，我们将单词做了排序，也就是表格显示了每个不同的单词分别出现在哪篇文章中。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/14.png?raw=true"><br></div>

<p>有了这张表，我们在查每个单词时都能很快的查找到这个单词在哪篇文章。<br>在这里这张单词表就是索引表，索引项的通用结构是：</p>
<ul>
<li>次关键码，例如上表中的“英文单词”</li>
<li>记录号表，例如上表中的“文章编号”</li>
</ul>
<p>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构，&lt;strong&gt;索引就是把一个关键字与它对应的记录相关联的过程，&lt;/strong&gt;一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。&lt;/p&gt;
&lt;p&gt;索引按照结构可以分为线性索引、树形索引和多级索引。这里只介绍线性索引技术。&lt;strong&gt;所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。&lt;/strong&gt;这里介绍三种线性索引：&lt;strong&gt;稠密索引、分块索引、倒排索引。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="http://www.guiyongdong.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找算法之有序表查找</title>
    <link href="http://www.guiyongdong.com/2016/11/10/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE/"/>
    <id>http://www.guiyongdong.com/2016/11/10/查找算法之有序表查找/</id>
    <published>2016-11-10T08:46:24.000Z</published>
    <updated>2016-11-15T03:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="折半查找法"><a href="#折半查找法" class="headerlink" title="折半查找法"></a>折半查找法</h3><p><strong>折半查找(Binary Search)技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序(通常从小到大)，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找，不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</strong></p>
<a id="more"></a>
<p>假设现在有这样一个有序数组{0,1,16,24,35,47,59,62,73,88,99}，对它进行查找是否存在62这个数，我们来看折半查找的算法是如何工作的。</p>
<pre><code>/* 折半查找 **/
- (NSInteger)binary_search:(NSArray *)targetArray key:(NSInteger)key {
    NSInteger low,high,mid;
    low = 0;  /*定义最低下标为记录首位*/
    high = targetArray.count-1;  /*记录最高下标为记录末位*/
    while (low &lt;= high) {
        mid = (low + high)/2;   /*折半*/
        if (key &lt; [targetArray[mid] integerValue]) { /*若查找值比中值小*/
            high = mid-1;  /*最高下标调整到中位下标小一位*/
        }else if (key &gt; [targetArray[mid] integerValue]) {  /*若查找值比中值大*/
            low = mid+1;  /*最低下标调整到中位下标大一位*/
        }else {
            return mid;   /*若相等则说明mid即为查找到的位置*/
        }
    }
    return -1;
}
</code></pre><p>具体执行步骤为：</p>
<p>1.程序开始运行，参数targetArray={0,1,16,24,35,47,59,62,73,88,99}, key=62,初始化时，此时low=1,high=10,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/1.png?raw=true"><br></div>

<p>2.开始循环，进行查找。<br>3.开始折半，mid计算得5，由于[targetArray[5] integerValue]=47&lt;key,所以执行了low = mid+1，low=6,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/2.png?raw=true"><br></div>

<p>4.再次循环， mid=(6+10)/2=8,此时[targetArray[8] integerValue]=73&gt;key,所以执行high = mid-1，high=7,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/3.png?raw=true"><br></div>

<p>5.再次循环，mid=(6+7)/2=6,此时[targetArray[6] integerValue]=59&lt;key,所以执行了low = mid+1，low=7,如图所示。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/4.png?raw=true"><br></div>

<p>6.再次循环，mid=(7+7)/2=7, 此时[targetArray[7] integerValue]=62=key,查找成功，返回7.</p>
<p>该算法还是比较容易理解的，同时它的效率也是非常的高，但到底有多高，我们来计算此算法的时间复杂度。</p>
<p>首先， 将这个数组的查找过程绘制成一棵二叉树，如图所示，从图中可以理解，如果查找的关键字不是中间记录47的话，折半查找等于是把静态有序查找表分成了两棵子树，即查找结果只需要找其中的一半数据即可，等于工作量减少了一半，然后继续折半查找，效率当然是非常高了。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/5.png?raw=true"><br></div>

<p>由<strong>“具有n个结点的完全二叉树的深度为「log2n」+1”</strong> 可以看出，查找关键字的最坏为「log2n」+1  最好情况为1 所以折半算法的时间复杂度为0(logn),它显然好于顺序查找的O(n)时间复杂度了。</p>
<p>不过由于折半查找的前提条件是需要有序顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了，但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>如果对折半查找的第8句代码进行改造，得到如下公式mid=(low+high)/2=low+(high-low)/2;<br>也就是mid等于最低下标low加上最高下标high与low的差的一半，再进一步的改进得到如下方案：mid=low+(high-low)*(key-targetArray[low])/(targetArray[high]-targetArray[low]);<br>这就是插值查找的算法。</p>
<p><strong>插值查找（Interpolation Search）是根据要查找的关键字key与查找表中最大最小记录的关键字做比较后的查找方法，其核心就在于插值的计算公式：<br>（key-targetArray[low]）/(targetArray[high]-targetArray[low])。</strong> 应该说从时间复杂度来看，它也是O(logn),但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多，反之，数组中如果分布类似{0,1,2,2000,200,…..,999998,999999}这种极端不均匀的数据，用插值查找未必是最合适的选择。</p>
<h3 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h3><p><strong>斐波那契查找(Fibonacci Search)，它是利用了黄金分割原理来实现的。斐波那契数列：</strong></p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/6.png?raw=true"><br></div>

<p>上代码：</p>
<pre><code>/* 斐波那契查找 */
1  - (NSInteger)fibonacci_Search:(NSMutableArray *)targetArray key:(NSInteger)key {
2     NSArray *F = @[@0,@1,@1,@2,@3,@5,@8,@13,@21,@34];  /*斐波那契数列*/
3     NSInteger low,high,mid,i,k,n;
4     low = 0;  /*定义最低下标为记录首位*/
5     high = targetArray.count-1;  /*定义最高下标为记录末位*/
6     k = 0;
7     n = targetArray.count-1;
8     while (n &gt; [F[k] integerValue] - 1) {
9         k++;
10    }
11    for (i = n; i&lt;[F[k] integerValue]-1; i++) {  /*将不满的数值补齐*/
12        targetArray[i]=targetArray[n];
13    }

14    while (low &lt;= high) {
15        mid = low + [F[k-1] integerValue] - 1;  /*计算当前分割的下标*/
16        if (key &lt; [targetArray[mid] integerValue]) {  /*若查找记录小于当前分割记录*/
17            high = mid - 1;   /*最高下标调整到分割下标mid-1处*/
18            k = k - 1;  /*斐波那契数列下标减一位*/
19        }else if (key &gt; [targetArray[mid] integerValue]) {  /*若查找记录大于当前分割记录*/
20            low = mid + 1;   /*最低下标调整到分割下标mid+1处*/
21            k = k - 2;   /*斐波那契数列下标减两位*/
22        }else {
23            if (mid &lt;= n) {
24                return mid;  /*若相等则说明mid即为查找到的位置*/
25            }else {
26                return n;   /*若mid&gt;n说明是补全数值，返回n*/
27            }
28        }
29    }
30    return -1;
31  }
</code></pre><p>1.程序开始运行，参数targetArray={0,1,16,24,35,47,59,62,73,88,99},要查找的关键字key=59。注意此时我们已经有了事先计算好的全局变量数值F的具体数据，它的斐波那契数列，F={0,1,1,2,3,5,8,13,21,…..}。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/7.png?raw=true"><br></div>

<p>2.第6~10行是计算当前的n处于斐波那契数列的位置，现在n=10，F[6]&lt;n&lt;F[7],所以计算得出k=7。</p>
<p>3.第11~13行，由于k=7,计算时是以F[7]=13<br>为基础，而a中最大的仅是a[10],后面的a[11],a[12]均为赋值，这不能构成有序数列，因此将它们都赋值为最大的数值值，所以此时a[11]=a[12]=a[10]=99。</p>
<p>4.第14~29行查找正式开始。</p>
<p>5.第15行，mid=0+F[7-1]-1=7,也就是说，我们第一个要对比的数值是从下标为7开始的。</p>
<p>6.由于此时key=59 而targetArray[7]=62,因此执行第17~18行，得到high=6,k=6,</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/8.png?raw=true"><br></div>

<p>7.再次循环，mid=0+F[6-1]-1=4。此时targetArray[4]=35&lt;key,因此执行20~21行，得到low=4+1=5,k=6-2=4,注意此时k下调2个单位。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/9.png?raw=true"><br></div>

<p>8.再次循环，mid=5+F[4-1]-1=6。此时targetArray[6]=59=key,因此执行第24行，返回mid=6。程序结束运行。</p>
<p>斐波那契查找算法的核心在于：</p>
<ol>
<li>当key=targetArray[mid]时，查找就成功；</li>
<li>当key=targetArray[mid]时,新范围是第low个到第mid-1个，此时范围个数为F[k-1]-1个；</li>
<li>当key&gt;targetArray[mid]时，新范围是第m+1个到第high个，此时范围个数为F[k-2]-1个。</li>
</ol>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/miscellaneous/10.png?raw=true"><br></div>

<p>也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些，所以尽管斐波那契查找的时间复杂度也为O(logn)，但就平均性能来说，斐波那契查找要优于折半查找。可惜如果最坏情况，比如这里key=1,那么始终都处于左侧长半区在查找，则查找效率要低折半查找。</p>
<p>还有比较关键的一点，折半查找是进行加法与除法运算(mid=(low+high)/2)，插值查找进行复杂的四则运算(mid=low+(high-low)*(key-targetArray[high]-targetArray[low])),而斐波那契查找只是最简单加减法运算(mid=low+F[k-1]-1),在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。</p>
<p>以上三种有序表的查找本质上是分割点的选择不同，各有各的优劣，实际开发中，可以根据数据的特点综合考虑再做出选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;折半查找法&quot;&gt;&lt;a href=&quot;#折半查找法&quot; class=&quot;headerlink&quot; title=&quot;折半查找法&quot;&gt;&lt;/a&gt;折半查找法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;折半查找(Binary Search)技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序(通常从小到大)，线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找，不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="http://www.guiyongdong.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找算法之顺序表查找</title>
    <link href="http://www.guiyongdong.com/2016/11/10/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>http://www.guiyongdong.com/2016/11/10/查找算法之顺序表查找法/</id>
    <published>2016-11-10T07:45:23.000Z</published>
    <updated>2016-11-15T03:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h3><p><strong>顺序查找法（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或者最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，查找成功，找到查找的记录；如果知道最后一个（或第一个）记录，其关键字和给定值比较都不相等时，则表中没有所查的记录，查找不成功。</strong></p>
<p>顺序查找的算法实现如下：</p>
<pre><code>- (NSInteger)sequential_search:(NSArray *)targetArray key:(id)key {
    NSInteger n = targetArray.count;
    for (int i = 0; i &lt; n; i++) {
        if (targetArray[i] == key) {
            return i;
        }
    }
    return -1;
}
</code></pre><p>这段代码非常简单，就是在数组targetArray中查看有没有关键字（key），当你需要查找复杂表结构的记录时，只需要把数组targetArray和关键字key定义成你需要的表结构和数据类型即可。</p>
<p>对于这种顺序查找算法来说，查找成功最好的情况就是在第一个位置就找到了，算法的时间复杂度为O(1)，最坏的情况是在最后一个位置才找到，需要比较n次，时间复杂度为O(n)，由于关键字在任何一位置的概率相同，所以平均查找次数为(n+1)/2，所以最终时间复杂度还是O(n)。</p>
<p>很显然，顺序查找技术是由很大缺点的，n很大时，查找效率极为地下，不过优点也是有的，这个算法非常简单，对静态查找表的记录没有任何的要求，在一些小型数据的查找时，是可以使用的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;顺序查找法&quot;&gt;&lt;a href=&quot;#顺序查找法&quot; class=&quot;headerlink&quot; title=&quot;顺序查找法&quot;&gt;&lt;/a&gt;顺序查找法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;顺序查找法（Sequential Search）又叫线性查找，是最基本的查找技术，它的查找过程是：从
    
    </summary>
    
      <category term="算法" scheme="http://www.guiyongdong.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="http://www.guiyongdong.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>iOS触摸事件处理详解</title>
    <link href="http://www.guiyongdong.com/2016/11/09/iOS%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.guiyongdong.com/2016/11/09/iOS触摸事件处理详解/</id>
    <published>2016-11-09T06:39:39.000Z</published>
    <updated>2017-03-09T07:02:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你设计一个app的时候，可能会有这样的场景，你想动态的去响应一个事件。例如，在屏幕上的一个触摸事件可能在不同的对象中都发生，并且你不得不决定由哪一个对象来响应这个事件并且尝试去理解怎么样的一个对象接收了到这个事件。</p>
<p>当一个常见的用户事件发生的时候，UIKit会创建一个事件对象Event Object,该对象包含了事件处理所必须得一些信息。然后它会将事件对象置于激活的app事件队列。例如触摸事件，该触摸时事件对象是一系列触摸信息包装集。例如手势事件，该事件是一个动态的变量它取决于你使用了什么框架以及你感兴趣的手势事件类型。</p>
<a id="more"></a>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>iOS 事件分为三大类</p>
<ul>
<li>触摸事件</li>
<li>加速器事件</li>
<li>远程控制事件</li>
</ul>
<p>这篇博客主要讲解触摸事件<br>触摸事件是我们平时遇到最多的事件，例如单击、长按、滑动等等。当用户点击按钮，到按钮处理回调。整个过程是如何发生，需要什么样的原则，这些都是问题。为了使系统能更加鲜明符合用户的操作逻辑，iOS系统将事件相应过程拆分成两部分：</p>
<ol>
<li>寻找响应链；</li>
<li>事件响应，先将事件通过某种规则来分发，找到处理事件的控件，其次是将事件传递分发，响应。</li>
</ol>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><p><strong>UIEvent</strong><br>iOS将触摸事件定义为第一个手指开始触摸屏幕到最后一个手指离开屏幕定义为一个触摸事件。用类UIEvent表示。</p>
<p><strong>UITouch</strong><br>一个手指第一次点击屏，会形成一个UITouch对象，直到离开销毁。表示触碰。UITouch对象能表明了当前手指触碰的屏幕位置，状态。状态分为开始触碰、移动、离开。</p>
<p>根据定义，UIEvent实际包括了多个UITouch对象。有几个手指触碰，就会有几个UITouch对象。<br>定义代码如下:</p>
<pre><code>@interface UIEvent : NSObject
@property(nonatomic,readonly) UIEventType     type NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly) UIEventSubtype  subtype NS_AVAILABLE_IOS(3_0);
@property(nonatomic,readonly) NSTimeInterval  timestamp;
#if UIKIT_DEFINE_AS_PROPERTIES
//UITouch SET
@property(nonatomic, readonly, nullable) NSSet &lt;UITouch *&gt; *allTouches;
//省略部分代码
@end
</code></pre><p>UIEventType表明了事件类型，UIEvent表示了三大事件。allTouches是该事件的所有UITouch对象的集合。</p>
<pre><code>//UITouch
@interface UITouch : NSObject
@property(nonatomic,readonly) NSTimeInterval      timestamp;
@property(nonatomic,readonly) UITouchPhase        phase;
@property(nonatomic,readonly) NSUInteger          tapCount;   // touch down within a certain point within a certain amount of time
@property(nonatomic,readonly) UITouchType         type NS_AVAILABLE_IOS(9_0);

@property(ullable,nonatomic,readonly,strong) UIWindow                        *window;
@property(nullable,nonatomic,readonly,strong) UIView                          *view;
@property(nullable,nonatomic,readonly,copy)   NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers 
NS_AVAILABLE_IOS(3_2);
//省略部分代码
@end
//Touch 状态枚举
typedef NS_ENUM(NSInteger, UITouchPhase) {
    UITouchPhaseBegan,             // whenever a finger touches the surface.
    UITouchPhaseMoved,             // whenever a finger moves on the surface.
    UITouchPhaseStationary,        // whenever a finger is touching the surface but hasn&apos;t moved since the previous event.
    UITouchPhaseEnded,             // whenever a finger leaves the surface.
    UITouchPhaseCancelled,         // whenever a touch doesn&apos;t end but we need to stop tracking (e.g. putting device to face)
};
</code></pre><p>UITouch中phase表明了手指移动的状态，包括1.开始点击；2.移动；3.保持; 4.离开；5.被取消（手指没有离开屏幕，但是系统不再跟踪它了）</p>
<p>综上，UIEvent就是一组UITouch。每当该组中任何一个UITouch对象的phase发生变化，系统都会产生一条TouchMessage。也就是说每次用户手指的移动和变化，UITouch都会形成状态改变，系统变回会形成Touch message进行传递和派发。那么 一次触摸事件是由一组UITouch对象状态变化引起的一组Touch message的转发和派送。那么事件派发的原则是什么？</p>
<h3 id="响应者"><a href="#响应者" class="headerlink" title="响应者"></a>响应者</h3><p>我们先来了解一下什么是响应者。<br>只要继承了UIResponder的对象就可以作为事件的响应者，下面看一下 UIResponder及其子类的继承关系：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Responder/Responder1.png?raw=true"><br></div>

<p>平常开发中所使用到的控件例如：UIButton,UiView,UIViController,APPDelegate，UIApplication等都能响应事件。与用户交互的控件就是第一响应者，它将作为响应者链的开始，事件首先发送给第一响应者，然后再依次传递下去，直到该事件被某个响应者处理。</p>
<h3 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h3><p>响应链是“事件派发”的原则和规定，那么响应链是什么？顾名思义事件链是一个链条，详细的定义如下:</p>
<ul>
<li>每条链是一个 链表状结构，整个是一棵树</li>
<li>链表的每一个node是一个 UIResponser对象</li>
</ul>
<p>UIResponser,响应链中的响应者，用来接收和处理事件的类，先抛开iOS中的具体传递细节，系统发送UIEvent的Touch message给UIResponser类。UIResponser提供了一下几个函数来做事件处理</p>
<pre><code>//触摸事件
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);

//物理按钮，遥控器上面的按钮在按压状态等状态下的回调
- (void)pressesBegan:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesChanged:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesEnded:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);
- (void)pressesCancelled:(NSSet&lt;UIPress *&gt; *)presses withEvent:(nullable UIPressesEvent *)event NS_AVAILABLE_IOS(9_0);

//设备的陀螺仪和加速传感器使用
- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event NS_AVAILABLE_IOS(3_0);
</code></pre><p>UIResponser包括了各种Touch message 的处理，比如开始，移动，停止等等。</p>
<p>回到响应链，响应链是由UIResponser组成的，那么是按照哪种规则形成的。</p>
<ol>
<li>程序启动<ul>
<li>UIApplication会生成一个单例，并会关联一个APPDelegate。APPDelegate作为整个响应链的根建立起来，而UIApplication会将自己与这个单例链接，即UIApplication的nextResponser(下一个事件处理者)为APPDelegate。</li>
</ul>
</li>
<li>创建UIWindow<ul>
<li>程序启动后，任何的UIWindow被创建时，UIWindow内部都会把nextResponser设置为UIApplication单例。</li>
<li>UIWindow初始化rootViewController, rootViewController的nextResponser会设置为UIWindow</li>
</ul>
</li>
<li>UIViewController初始化<ul>
<li>loadView, VC的view的nextResponser会被设置为VC。</li>
</ul>
</li>
<li>addSubView<ul>
<li>addSubView操作过程中，如果子subView不是VC的View,那么subView的nextResponser会被设置为superView。如果是VC的View,那就是 subView -&gt; subView.VC -&gt;superView</li>
<li>如果在中途，subView.VC被释放，就会变成subView.nextResponser = superView</li>
</ul>
</li>
</ol>
<p>最终形成类似这样一张图</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Responder/Responser2.png?raw=true"><br></div>

<p>其中应该是由箭头的，箭头的方向是朝上，也就是subView指向superView.</p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>有了响应网为基础，事件的传递就比较简单，只需要选择其中一条响应链，但是选择那一条响应链来传递呢？为了弄清真个过程，我们先来查看一下从触摸硬件事件转化为UIEvent消息。</p>
<ol>
<li>首先用户触摸屏幕，系统的硬件进程会获取到这个点击事件，将事件简单处理封装后存到系统中，由于硬件检测进程和当前运行的APP是两个进程，所以进程两者之间传递事件用的是端口通信。硬件检测进程会将事件放入到APP检测的那个端口。</li>
<li>其次，APP启动主线程RunLoop会注册一个端口事件，来检测触摸事件的发生。当时事件到达，系统会唤起当前APP主线程的Runloop。唤起原因就是端口触摸事件，主线程会分析这个事件。</li>
<li>最后，系统判断该次触摸是否导致了一个新的事件, 也就是说是否是第一个手指开始触碰，如果是，系统会先从响应网中 寻找响应链。如果不是，说明该事件是当前正在进行中的事件产生的一个Touch message， 也就是说已经有保存好的响应链。</li>
</ol>
<p>如果是新事件，系统会寻找响应链，为了符合用户的操作习惯，系统会根据用户的点击位置，在当前的整个APP的显示层级中寻找。过程如下：</p>
<ol>
<li>将所有的显示在屏幕上的 “合格的”UIWindow对象 按照层级结构从上到下排列成一个数组。</li>
<li>从第一个UIWindow对象开始，先判断UIWindow是否合格，其次判断 点击位置在不在这个Window内，如果不在 ，返回nil, 就换下一个UIWindow;如果在的话，并且UIWindow没有subView就返回自己，整个过程结束。如果UIWindow有subViews,就从后往前遍历整个subViews,做和UIWindow类似的事情，直到找到一个View。如果没有找到到就不做传递。</li>
<li><strong>合格的UIWindow，UIView。意思是控件被允许接受事件。符合三个条件：1.不能被隐藏；2.alpha值大于0.01(不是backgroundColor为clearColor)；3.isUserInteractionEnabled为YES，打开状态。一般UILabel,UIImageView纯显示的控件默认是关闭状态，也就是不处理事件。</strong></li>
</ol>
<p>显示控件有了两个方法来做上面这件事，就是常说的hitTest</p>
<pre><code> // 先判断点是否在View内部，然后遍历subViews
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;  
//判断点是否在这个View内部
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;   // default returns YES if point is in bounds
</code></pre><p>整个过程的系统实现大致如下</p>
<pre><code>- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event {
  //判断是否合格
    if (!self.hidden &amp;&amp; self.alpha &gt; 0.01 &amp;&amp; self.isUserInteractionEnabled) {
        //判断点击位置是否在自己区域内部
        if ([self pointInside: point withEvent:event]) {
            UIView *attachedView;
            for (int i = self.subviews.count - 1; i &gt;= 0; i--) {
                UIView *view  = self.subviews[i];
                //对子view进行hitTest
                attachedView =  [view hitTest:point withEvent:event];
                if (attachedView)
                    break;
            }
            if (attachedView)  {
                return attachedView;
            } else {
                return self;
            }
        }
    }
    return nil;
}
</code></pre><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>以上可知默认情况下，用户点击哪个View,系统就会在寻找过程中返回哪个view，但是我们可以重载上面两个方法做如下事情：</p>
<ul>
<li>将控件外部点规整到控件内部。 例如控件较小，点击位置在控件边缘外部，可以重载- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; 将外部的点也判断为内部点，这样hitTest就会遍历自己。</li>
<li>重载HitTest更改默认行为。 有时候点击subView的某些特殊位置需要superView处理，我们可以在superView的hitTest，返回superView。这样superView变成首部响应者</li>
</ul>
<blockquote>
<p>hitTest的逻辑代码中会把隐藏，透明（alpha&lt;0.01,不是backgroundColor为clearColor），不交互的view滤过，但不代表hitTest不会被调用，我们可以重载hitTest去让 已经隐藏、透明、不交互的view响应事件。不过最正规的方法是打开控件交互属性。</p>
</blockquote>
<p>以上过程返回的View被称作hitTestView，顺着hitTestView的nextResponser,可以形成一个链，即响应链。 最后指向appDelegate. 并且返回hitTestView之后，系统会持有hitTestView。事件不结束，这个hitTestView不会发生变化，即使用户点击之后将手指移动到其他控件上面，该点击都会绑定开始的hitTestView。当所有手指离开屏幕，事件结束。再次点击，事件重新开始。以上过程再来一次。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>形成响应链之后，UIWindow会把事件目标锁定为hitTestView(响应链头的控件)，当手指状态发生变化， 会不停的发送UITouch Message 给这个hitTestView。 下面这几个方法会被调用。<br>然后控件的以下方法会陆续被调用</p>
<pre><code>//点击刚开始，回调这个方法
- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
//点击之后移动，回调这个方法
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
//手指移开，点击结束
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
//点击过程中，事件被手势识别，会回调这个方法，关于手势后面会讲解
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);
</code></pre><h4 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h4><p>由于系统只会把事件发送给 hitTestView，如果你想让hitTestView之后的其他响应者处理该Touch Mesage ，需要自己实现以上几个方法做派发，例如</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event
{
    //do someThiing
  [self.nextResponser touchesBegan: touches withEvent:event];
}
</code></pre><p>事件转发可以做很多事情。大家可以尽可能的想象</p>
<h3 id="手势处理"><a href="#手势处理" class="headerlink" title="手势处理"></a>手势处理</h3><p>以上看来所有的事情都很平稳，无非就是寻找响应链，传递事件等等。但是接下来大家可能需要蒙圈。先来道题目</p>
<ul>
<li>AView 有子view BView，AView上面有一个<strong>单击手势</strong>，这个时候点击BView。默认情况下，Bview的四个Touch方法中，那些方法会被调用？</li>
</ul>
<p>可能很多人会说没有任何影响，基本都会调用，答案是整个过程会调用这两个方法。</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;
</code></pre><p>touchEnd不会被调用。<br>为什么？因为有手势的存在，我们先看一下手势。</p>
<h4 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h4><p>手势是苹果为处理常用的用户交互所推出了一个优先级更高的处理技术。为了让用户完成对多种控件的基本操作，苹果实现了以下几个手势</p>
<blockquote>
<p><strong>UITapGestureRecognizer</strong><br><strong>UIPinchGestureRecognizer</strong><br><strong>UIRotationGestureRecognizer</strong><br><strong>UISwipeGestureRecognizer</strong><br><strong>UIPanGestureRecognizer</strong><br><strong>UIScreenEdgePanGestureRecognizer</strong><br><strong>UILongPressGestureRecognizer</strong></p>
</blockquote>
<p>上面包括点击，长按，旋转，滑动等等手势。这样开发者就可以随便将其关联到某个控件上完成交互。<br>先抛开刚才的问题，先看单纯的手势如何识别用户操作。</p>
<p>系统会将用户触摸屏幕的点事件 发送给手势，手势会根据具体的点击位置和序列，判断是否是某种特定行为。具体的判断方法如下</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event;
</code></pre><p>和UIResponser一样，手势也有这几个方法，点击的每个阶段手势都会响应不同的方法，手势会在以上四个方法中去对手势的State做更改，手势的State表明当前手势是识别还是失败等等。比如单击手势会在touchesBegan 时记录点击位置，然后在touchesEnded判断点击次数、时间、是否移动过，最后得出是否识别该手势。这几个方法一般在自定义手势里面使用。</p>
<h4 id="手势状态"><a href="#手势状态" class="headerlink" title="手势状态"></a>手势状态</h4><pre><code>typedef NS_ENUM(NSInteger, UIGestureRecognizerState) {
    //未知状态
    UIGestureRecognizerStatePossible,   // the recognizer has not yet recognized its gesture, but may be evaluating touch events. this is the default state
    //首次识别状态，对于连续手势，例如长按，有这种状态
    UIGestureRecognizerStateBegan,      // the recognizer has received touches recognized as the gesture. the action method will be called at the next turn of the run loop
    //再次识别，当手连续手势识别之后，再次受到touch事件
    UIGestureRecognizerStateChanged,    // the recognizer has received touches recognized as a change to the gesture. the action method will be called at the next turn of the run loop
    //识别完成，受到touchend 消息之后
    UIGestureRecognizerStateEnded,      // the recognizer has received touches recognized as the end of the gesture. the action method will be called at the next turn of the run loop and the recognizer will be reset to UIGestureRecognizerStatePossible
    //取消识别
    UIGestureRecognizerStateCancelled,  // the recognizer has received touches resulting in the cancellation of the gesture. the action method will be called at the next turn of the run loop. the recognizer will be reset to UIGestureRecognizerStatePossible
    //识别失败
    UIGestureRecognizerStateFailed,     // the recognizer has received a touch sequence that can not be recognized as the gesture. the action method will not be called and the recognizer will be reset to UIGestureRecognizerStatePossible
    // Discrete Gestures – gesture recognizers that recognize a discrete event but do not report changes (for example, a tap) do not transition through the Began and Changed states and can not fail or be cancelled
    //识别状态，与识别结束一个意思
    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded // the recognizer has received touches recognized as the gesture. the action method will be called at the next turn of the run loop and the recognizer will be reset to UIGestureRecognizerStatePossible
};
</code></pre><p>手势的状态有以上几种,我们来看手势的整个迁移过程，先明确几个信息</p>
<ol>
<li>手势的状态迁移只有在它们收到Touch message的时候，才能做状态变化处理代码。</li>
<li>手势分为连续状态手势和不连续状态手势。连续手势有长按，慢滑等。不连续手势有单击，双击等等。</li>
<li>当用户没有点击屏幕，所有手势都处于Possiable状态。</li>
</ol>
<p>当用户点击屏幕，手势会收到Touch Began Message， 手势的touchBegan方法会被调用。手势开始记录点击位置和时间。仍处于Possiable状态。如果用户按住不放，间隔超过一定时间，单击手势会变化为失败状态，并在下个一runloop变为possiable。如果时间大于长按手势设定时间，长按手势就会变化为Began状态，当用户移动手指，长按手势的touch move方法被调用，长按手势将自己状态设置为Change，并且也会回调处理方法。最后手指离开，系统调用长按手势touchEnd方法，手势状态回归为Recognized状态。</p>
<h4 id="手势混合处理"><a href="#手势混合处理" class="headerlink" title="手势混合处理"></a>手势混合处理</h4><p>如果一个View上既有单击，又有双击，用户点击该view两次， 默认情况下，单击被处理，双击不管用。因为默认情况下，一旦事件被某个手势处理，第二个手势会识别失败 幸运的是苹果提供了方法让我们修改这种默认行为，具体的方法如下</p>
<pre><code>@protocol UIGestureRecognizerDelegate &lt;NSObject&gt;
@optional
// called when a gesture recognizer attempts to transition out of UIGestureRecognizerStatePossible. returning NO causes it to transition to UIGestureRecognizerStateFailed
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;

// called when the recognition of one of gestureRecognizer or otherGestureRecognizer would be blocked by the other
// return YES to allow both to recognize simultaneously. the default implementation returns NO (by default no two gestures can be recognized simultaneously)
//
// note: returning YES is guaranteed to allow simultaneous recognition. returning NO is not guaranteed to prevent simultaneous recognition, as the other gesture&apos;s delegate may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;

// called once per attempt to recognize, so failure requirements can be determined lazily and may be set up between recognizers across view hierarchies
// return YES to set up a dynamic failure requirement between gestureRecognizer and otherGestureRecognizer
//
// note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture&apos;s counterpart delegate or subclass methods may return YES
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer NS_AVAILABLE_IOS(7_0);

// called before touchesBegan:withEvent: is called on the gesture recognizer for a new touch. return NO to prevent the gesture recognizer from seeing this touch
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;

// called before pressesBegan:withEvent: is called on the gesture recognizer for a new press. return NO to prevent the gesture recognizer from seeing this press
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceivePress:(UIPress *)press;

@end
</code></pre><p>上面是手势的代理方法，你可以实现手势的这几个代理方法，更改默认行为。</p>
<ul>
<li>(BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;<br>手势已经应分析出该事件可以响应，再对自己的状态进行更改之前，会询问代理的这个方法是否允许更改。默认为YES，如果你实现并设置为NO,那么手势会变为失败状态，这个可以用在手势只识别View的某几个区域的相应。</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer;<br>当两个手势都对该事件进行识别，但只有一个能响应，另外一个会失败。比如一个View上绑定两个单击事件。为了让两个手势都响应，我们可以实现此方法，让两个手势都响应。</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer NS_AVAILABLE_IOS(7_0);</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer )otherGestureRecognizer NS_AVAILABLE_IOS(7_0);<br>这两个方法是iOS 7引入的，目的是让两个手势之间增加依赖，比如单击和双击，如果需要单击在双击失败的情况下识别，那么可以实现这两个方法。</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldReceiveTouch:(UITouch )touch;</li>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer )gestureRecognizer shouldReceivePress:(UIPress )press;<br>这两个方法是判断手势在新的Touch和Press Began阶段是否关注该UITouch和UIPress对象，默认为YES，如果设置为NO,手势不会关注该Touch的任何状态变化。</li>
</ul>
<h4 id="手势与事件响应"><a href="#手势与事件响应" class="headerlink" title="手势与事件响应"></a>手势与事件响应</h4><p>回到我们上面问过的问题，BView只有touchBegan， touchesCancelle 的原因是什么？答案在于整个触摸事件全过程</p>
<ol>
<li>系统会通过hitTest的方法寻找响应链，完成之后会形成下图模型。</li>
</ol>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/Responder/Responser3.png?raw=true"><br></div>

<blockquote>
<p>图中最右边是响应链，中间是关联在相应链在视图上的手势</p>
</blockquote>
<ol>
<li>有了模型之后就会发生图上的三个步骤</li>
</ol>
<p>第一步：系统会将所有的 Touch message 优先发送给 关联在响应链上的全部手势。手势根据Touch序列消息和手势基本规则更改自己的状态（有的可能失败，有的可能识别等等）。如果没有一个手势对Touch message 进行拦截（拦截:系统不会将Touch message 发送给响应链顶部响应者)，系统会进入第二步</p>
<p>第二步：系统将Touch message 发送给响应链 顶部的 视图控件，顶部视图控件这个时候就会调用Touch相关的四个方法中的某一个。之后进入自定义Touch message转发</p>
<p>第三步：自定义Touch message转发可以继承UIResponser的四个Touch函数做转发。</p>
<p>解释一下第一步中说的拦截，手势会表明是否拦截该Touch Message,主要由下面三个属性控制。</p>
<p>再回到那道题目，如果我们想hitTestView的toucheEnd函数依然能得到调用，怎么办？其实UIGestureRecognizer有三个属性</p>
<pre><code>@property(nonatomic) BOOL cancelsTouchesInView;       // default is YES. causes touchesCancelled:withEvent: or pressesCancelled:withEvent: to be sent to the view for all touches or presses recognized as part of this gesture immediately before the action method is called.
@property(nonatomic) BOOL delaysTouchesBegan;         // default is NO.  causes all touch or press events to be delivered to the target view only after this gesture has failed recognition. set to YES to prevent views from processing any touches or presses that may be recognized as part of this gesture
@property(nonatomic) BOOL delaysTouchesEnded;         // default is YES. causes touchesEnded or pressesEnded events to be delivered to the target view only after this gesture has failed recognition. this ensures that a touch or press that is part of the gesture can be cancelled if the gesture is recognized
</code></pre><ul>
<li>cancelsTouchesInView<br>  默认为YES,表明当手势识别了该事件，系统会将Touch cancel消息发送给hitTestView ，并调用hitTestView的TouchCancel。设置为NO，不会再收到TouchCancel</li>
<li>delaysTouchesBegan<br>  默认为NO, 表明无论什么情况下，不会拦截Touch began消息。如果设置为YES，只要有一个手势不识别失败，都不会发送Touch began到响应链的第一响应者。</li>
<li>delaysTouchesEnded<br>  默认为NO, 和delaysTouchesBegan类似，不过它是用来控制TouchEnd message的拦截</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>iOS整个事件处理的过程就是这样，系统为完成整个交互做了很多东西，核心点如下：</p>
<ul>
<li>事件分发过程分为：1.寻找响应链；2.事件消息分发</li>
<li>响应网是事件响应的基础，响应链是事件响应的具体路径。</li>
<li>事件消息分发优先发送给手势集合，手势内部会做冲突处理，过滤消息。不被过滤的消息会传递给响应链对象。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你设计一个app的时候，可能会有这样的场景，你想动态的去响应一个事件。例如，在屏幕上的一个触摸事件可能在不同的对象中都发生，并且你不得不决定由哪一个对象来响应这个事件并且尝试去理解怎么样的一个对象接收了到这个事件。&lt;/p&gt;
&lt;p&gt;当一个常见的用户事件发生的时候，UIKit会创建一个事件对象Event Object,该对象包含了事件处理所必须得一些信息。然后它会将事件对象置于激活的app事件队列。例如触摸事件，该触摸时事件对象是一系列触摸信息包装集。例如手势事件，该事件是一个动态的变量它取决于你使用了什么框架以及你感兴趣的手势事件类型。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="响应者链" scheme="http://www.guiyongdong.com/tags/%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>iOS照片开发之PhotoKit</title>
    <link href="http://www.guiyongdong.com/2016/10/22/iOS%E7%85%A7%E7%89%87%E5%BC%80%E5%8F%91%E4%B9%8BPhotoKit/"/>
    <id>http://www.guiyongdong.com/2016/10/22/iOS照片开发之PhotoKit/</id>
    <published>2016-10-22T08:44:37.000Z</published>
    <updated>2017-03-09T07:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>PhotoKit 是一套比 AssetsLibrary 更完整也更高效的库，对资源的处理跟 AssetsLibrary 也有很大的不同。它是iOS8之后出现的框架，在使用框架之前需要导入<code>#import &lt;Photos/Photos.h&gt;</code>库</p>
<a id="more"></a>
<p>首先简单介绍几个概念：</p>
<ul>
<li><strong>PHAsset</strong>: 代表照片库中的一个资源，跟 ALAsset 类似，通过 PHAsset 可以获取和保存资源</li>
<li><strong>PHFetchOptions</strong>: 获取资源时的参数，可以传 nil，即使用系统默认值</li>
<li><strong>PHFetchResult</strong>: 表示一系列的资源集合，也可以是相册的集合</li>
<li><strong>PHAssetCollection</strong>: 表示一个相册或者一个时刻，或者是一个「智能相册（系统提供的特定的一系列相册，例如：最近删除，视频列表，收藏等等，如下图所示）</li>
<li><strong>PHImageManager</strong>: 用于处理资源的加载，加载图片的过程带有缓存处理，可以通过传入一个 PHImageRequestOptions 控制资源的输出尺寸等规格</li>
<li><strong>PHImageRequestOptions</strong>: 如上面所说，控制加载图片时的一系列参数</li>
</ul>
<p>这里还有一个额外的概念PHCollectionList，表示一组PHCollection，它本身也是一个PHCollection，因此PHCollection 作为一个集合，可以包含其他集合，这使到 PhotoKit 的组成比 ALAssetLibrary 要复杂一些。另外与 ALAssetLibrary 相似，一个 PHAsset 可以同时属于多个不同的 PHAssetCollection，最常见的例子就是刚刚拍摄的照片，至少同时属于“最近添加”、“相机胶卷”以及“照片 - 精选”这三个 PHAssetCollection。关于这几个概念的关系如下图：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/PhotoKit_1.png?raw=true"><br></div>

<h3 id="PhotoKit-的机制"><a href="#PhotoKit-的机制" class="headerlink" title="PhotoKit 的机制"></a>PhotoKit 的机制</h3><h5 id="1-获取资源"><a href="#1-获取资源" class="headerlink" title="1. 获取资源"></a>1. 获取资源</h5><p>在 ALAssetLibrary 中获取数据，无论是相册，还是资源，本质上都是使用枚举的方式，遍历照片库取得相应的数据，并且数据是从 ALAssetLibrary（照片库） - ALAssetGroup（相册）- ALAsset（资源）这一路径逐层获取，即使有直接从 ALAssetLibrary 这一层获取 ALAsset 的接口，本质上也是枚举 ALAssetLibrary 所得，并不是直接获取，这样的好处很明显，就是非常符合实际应用中资源的显示路径：照片库 - 相册 - 图片或视频，但由于采用枚举的方式获取资源，效率低而且不灵活。</p>
<p>而在 PhotoKit 中，则是采用“获取”的方式拉取资源，这些获取的手段，都是一系列形如 class func fetchXXX(…, options: PHFetchOptions) -&gt; PHFetchResult 的类方法，具体使用哪个类方法，则视乎需要获取的是相册、时刻还是资源，这类方法中的 option 充当了过滤器的作用，可以过滤相册的类型，日期，名称等，从而直接获取对应的资源而不需要枚举。</p>
<p><strong>获取相册-PHAssetCollection:</strong></p>
<pre><code>- (IBAction)getAllSmartAlbums:(id)sender {
    // 列出所有相册智能相册
    PHFetchResult *smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:nil];
    //列出用户创建的相册.
    PHFetchResult *topLevelUserCollections = [PHCollectionList fetchTopLevelUserCollectionsWithOptions:nil];

    for (NSInteger i = 0; i &lt; smartAlbums.count; i++) {
        PHCollection *collection = smartAlbums[i];
        if ([collection isKindOfClass:[PHAssetCollection class]]) {
            PHAssetCollection *assetCollection = (PHAssetCollection *)collection;
            NSLog(@&quot;%@&quot;,assetCollection);
        }else {
            NSAssert(NO, @&quot;Fetch collection not PHCollection: %@&quot;, collection);
        }
    }
}
</code></pre><p>以上方法第一种需要指定两个参数：</p>
<pre><code>typedef NS_ENUM(NSInteger, PHAssetCollectionType) {
    PHAssetCollectionTypeAlbum      = 1,//从 iTunes 同步来的相册，以及用户在 Photos 中自己建立的相册
    PHAssetCollectionTypeSmartAlbum = 2,//经由相机得来的相册
    PHAssetCollectionTypeMoment     = 3,//Photos 为我们自动生成的时间分组的相册
} NS_ENUM_AVAILABLE_IOS(8_0);

typedef NS_ENUM(NSInteger, PHAssetCollectionSubtype) {

    // PHAssetCollectionTypeAlbum regular subtypes  
    PHAssetCollectionSubtypeAlbumRegular         = 2, //用户在 Photos 中创建的相册，也就是我所谓的逻辑相册
    PHAssetCollectionSubtypeAlbumSyncedEvent     = 3, //使用 iTunes 从 Photos 照片库或者 iPhoto 照片库同步过来的事件。然而，在iTunes 12 以及iOS 9.0 beta4上，选用该类型没法获取同步的事件相册，而必须使用AlbumSyncedAlbum。
    PHAssetCollectionSubtypeAlbumSyncedFaces     = 4,//使用 iTunes 从 Photos 照片库或者 iPhoto 照片库同步的人物相册。
    PHAssetCollectionSubtypeAlbumSyncedAlbum     = 5,//做了 AlbumSyncedEvent 应该做的事
    PHAssetCollectionSubtypeAlbumImported        = 6,//从相机或是外部存储导入的相册，完全没有这方面的使用经验，没法验证。

    // PHAssetCollectionTypeAlbum shared subtypes
    PHAssetCollectionSubtypeAlbumMyPhotoStream   = 100,//用户的 iCloud 照片流
    PHAssetCollectionSubtypeAlbumCloudShared     = 101,//用户使用 iCloud 共享的相册

    // PHAssetCollectionTypeSmartAlbum subtypes
    PHAssetCollectionSubtypeSmartAlbumGeneric    = 200,//文档解释为非特殊类型的相册，主要包括从 iPhoto 同步过来的相册。由于本人的 iPhoto 已被 Photos 替代，无法验证。不过，在我的 iPad mini 上是无法获取的，而下面类型的相册，尽管没有包含照片或视频，但能够获取到。
    PHAssetCollectionSubtypeSmartAlbumPanoramas  = 201, //相机拍摄的全景照片
    PHAssetCollectionSubtypeSmartAlbumVideos     = 202,//相机拍摄的视频
    PHAssetCollectionSubtypeSmartAlbumFavorites  = 203,//收藏文件夹
    PHAssetCollectionSubtypeSmartAlbumTimelapses = 204,//延时视频文件夹，同时也会出现在视频文件夹中
    PHAssetCollectionSubtypeSmartAlbumAllHidden  = 205,//包含隐藏照片或视频的文件夹
    PHAssetCollectionSubtypeSmartAlbumRecentlyAdded = 206,//相机近期拍摄的照片或视频
    PHAssetCollectionSubtypeSmartAlbumBursts     = 207,//连拍模式拍摄的照片，在 iPad mini 上按住快门不放就可以了，但是照片依然没有存放在这个文件夹下，而是在相机相册里。
    PHAssetCollectionSubtypeSmartAlbumSlomoVideos = 208,//Slomo 是 slow motion 的缩写，高速摄影慢动作解析，在该模式下，iOS 设备以120帧拍摄。不过我的 iPad mini 不支持，没法验证。
    PHAssetCollectionSubtypeSmartAlbumUserLibrary = 209,//这个命名最神奇了，就是相机相册，所有相机拍摄的照片或视频都会出现在该相册中，而且使用其他应用保存的照片也会出现在这里。
    PHAssetCollectionSubtypeSmartAlbumSelfPortraits NS_AVAILABLE_IOS(9_0) = 210,
    PHAssetCollectionSubtypeSmartAlbumScreenshots NS_AVAILABLE_IOS(9_0) = 211,

    // Used for fetching, if you don&apos;t care about the exact subtype
    PHAssetCollectionSubtypeAny = NSIntegerMax //包含所有类型
} NS_ENUM_AVAILABLE_IOS(8_0);
</code></pre><p><strong>注意</strong>：获取指定类型的相册时，主类型和子类型要匹配，不要串台。如果不匹配，系统会按照 Any 子类型来处理。对于 Moment 类型，子类型使用 Any。</p>
<p>如前面提到过的那样，从PHAssetCollection 获取中获取到的可以是相册也可以是资源，但无论是哪种内容，都统一使用PHFetchResult 对象封装起来，因此虽然 PHAssetCollection 获取到的结果可能是多样的，但通过PHFetchResult 就可以使用统一的方法去处理这些内容（即遍历 PHFetchResult）。</p>
<p><strong>获取资源-PHAsset</strong></p>
<pre><code>//方式一
// 列出所有相册智能相册
PHFetchResult *smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType:PHAssetCollectionTypeSmartAlbum subtype:PHAssetCollectionSubtypeAlbumRegular options:nil];
// 这时 smartAlbums 中保存的应该是各个智能相册对应的 PHAssetCollection
for (NSInteger i = 0; i &lt; fetchResult.count; i++) {
    // 获取一个相册（PHAssetCollection）
    PHCollection *collection = fetchResult[i];
    if ([collection isKindOfClass:[PHAssetCollection class]]) {
        PHAssetCollection *assetCollection = (PHAssetCollection *)collection;
        // 从每一个智能相册中获取到的 PHFetchResult 中包含的才是真正的资源（PHAsset）
        PHFetchResult *fetchResult = [PHAsset fetchAssetsInAssetCollection:assetCollection options:fetchOptions];
        for (NSInteger i = 0; i &lt; fetchResult.count; i++) {
            // 获取一个资源（PHAsset）
            PHAsset *asset = fetchResult[i];
            NSLog(@&quot;%@&quot;,asset);
        }
    else {
        NSAssert(NO, @&quot;Fetch collection not PHCollection: %@&quot;, collection);
    }
}

//方式二  
// 获取所有资源的集合，并按资源的创建时间排序
PHFetchOptions *options = [[PHFetchOptions alloc] init];
options.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@&quot;creationDate&quot; ascending:YES]];
PHFetchResult *assetsFetchResults = [PHAsset fetchAssetsWithOptions:options];
// 这时 assetsFetchResults 中包含的，应该就是各个资源（PHAsset）
for (NSInteger i = 0; i &lt; fetchResult.count; i++) {
    // 获取一个资源（PHAsset）
    PHAsset *asset = fetchResult[i];
}
</code></pre><h5 id="获取图像的方式与坑点"><a href="#获取图像的方式与坑点" class="headerlink" title="获取图像的方式与坑点"></a>获取图像的方式与坑点</h5><p>经过了上面的步骤，已经可以了解到如何在 PhotoKit 中获取到代表资源的 PHAsset 了，但与 ALAssetLibrary 中从 ALAsset 中直接获取图像的方式不同，PhotoKit 无法直接从 PHAsset 的实例中获取图像，而是引入了一个管理器?PHImageManager 获取图像。PHImageManager 是通过请求的方式拉取图像，并可以控制请求得到的图像的尺寸、剪裁方式、质量，缓存以及请求本身的管理（发出请求、取消请求）等。而请求图像的方法是PHImageManager 的一个实例方法：</p>
<pre><code>- (PHImageRequestID)requestImageForAsset:(PHAsset *)asset 
                              targetSize:(CGSize)targetSize 
                               contentMode:(PHImageContentMode)contentMode 
                                options:(nullable PHImageRequestOptions *)options 
                          resultHandler:(void (^)(UIImage *__nullable result, NSDictionary *__nullable info))resultHandler;
</code></pre><p>这个方法中的参数坑点不少，下面逐个参数列举一下其作用及坑点：</p>
<ul>
<li><strong>asset</strong>:图像对应的 PHAsset。</li>
<li><strong>targetSize</strong>:需要获取的图像的尺寸，如果输入的尺寸大于资源原图的尺寸，则只返回原图。需要注意在 PHImageManager 中，所有的尺寸都是用 Pixel 作为单位（Note that all sizes are in pixels），因此这里想要获得正确大小的图像，需要把输入的尺寸转换为 Pixel。如果需要返回原图尺寸，可以传入 PhotoKit 中预先定义好的常量PHImageManagerMaximumSize，表示返回可选范围内的最大的尺寸，即原图尺寸。</li>
<li><strong>contentMode</strong>:图像的剪裁方式，与UIView 的 contentMode 参数相似，控制照片应该以按比例缩放还是按比例填充的方式放到最终展示的容器内。注意如果 targetSize 传入PHImageManagerMaximumSize，则 contentMode 无论传入什么值都会被视为?PHImageContentModeDefault。</li>
<li><strong>options</strong>:一个PHImageRequestOptions 的实例，可以控制的内容相当丰富，包括图像的质量、版本，也会有参数控制图像的剪裁，下面再展开说明。</li>
<li><strong>resultHandler</strong>:请求结束后被调用的 block，返回一个包含资源对于图像的 UIImage 和包含图像信息的一个 NSDictionary，在整个请求的周期中，这个 block 可能会被多次调用，关于这点连同 options 参数在下面展开说明。</li>
</ul>
<h6 id="PHImageRequestOptions-与-iCloud-照片库"><a href="#PHImageRequestOptions-与-iCloud-照片库" class="headerlink" title="PHImageRequestOptions 与 iCloud 照片库"></a>PHImageRequestOptions 与 iCloud 照片库</h6><p>PHImageRequestOptions 中包含了一系列控制请求图像的属性。</p>
<p>resizeMode 属性控制图像的剪裁，不知道为什么 PhotoKit 会在请求图像方法（requestImageForAsset）中已经有控制图像剪裁的参数后（contentMode），还在 options 中加入控制剪裁的属性，但如果两个地方所控制的剪裁结果有所冲突，PhotoKit 会以 resizeMode 的结果为准。另外，resizeMode 也有控制图像质量的作用。如resizeMode设置为PHImageRequestOptionsResizeModeExact 则返回图像必须和目标大小相匹配，并且图像质量也为高质量图像，而设置为 PHImageRequestOptionsResizeModeFast 则请求的效率更高，但返回的图像可能和目标大小不一样并且质量较低。</p>
<p>在 PhotoKit 中，对 iCloud 照片库有很好的支持，如果用户开启了 iCloud 照片库，并且选择了“优化 iPhone/iPad 储存空间”，或者选择了“下载并保留原件”但原件还没有加载好的时候，PhotoKit 也会预先拿到这些非本地图像的 PHAsset，但是由于本地并没有原图，所以如果产生了请求高清图的请求，PHotoKit 会尝试从 iCloud 下载图片，而这个行为最终的表现，会被PHImageRequestOptions 中的值所影响。PHImageRequestOptions 中常常会用的几个属性如下：</p>
<p>networkAccessAllowed 参数控制是否允许网络请求，默认为 NO，如果不允许网络请求，那么就没有然后了，当然也拉取不到 iCloud 的图像原件。deliveryMode 则用于控制请求的图片质量。synchronous 控制是否为同步请求，默认为 NO，如果?synchronous 为 YES，即同步请求时，deliveryMode 会被视为 PHImageRequestOptionsDeliveryModeHighQualityFormat，即自动返回高质量的图片，因此不建议使用同步请求，否则如果界面需要等待返回的图像才能进一步作出反应，则反应时长会很长。</p>
<p>还有一个与 iCloud 密切相关的属性progressHandler，当图像需要从 iCloud 下载时，这个 block 会被自动调用，block 中会返回图像下载的进度，图像的信息，出错信息。开发者可以利用这些信息反馈给用户当前图像的下载进度以及状况，但需要注意progressHandler 不在主线程上执行，因此在其中需要操作 UI，则需要手工放到主线程执行。</p>
<p>上面有提到，requestImageForAsset 中的参数resultHandler 可能会被多次调用，这种情况就是图像需要从 iCloud 中下载的情况。在requestImageForAsset 返回的内容中，一开始的那一次请求中会返回一个小尺寸的图像版本，当高清图像还在下载时，开发者可以首先给用户展示这个低清的图像版本，然后 block 在多次调用后，最终会返回高清的原图。至于当前返回的图像是哪个版本的图像，可以通过 block 返回的 NSDictionary info 中获知，PHImageResultIsDegradedKey 表示当前返回的 UIImage 是低清图。如果需要判断是否已经获得高清图，可以这样判断：</p>
<pre><code>// 排除取消，错误，低清图三种情况，即已经获取到了高清图
BOOL downloadFinined = ![[info objectForKey:PHImageCancelledKey] boolValue] &amp;&amp; ![info objectForKey:PHImageErrorKey] &amp;&amp; ![[info objectForKey:PHImageResultIsDegradedKey] boolValue];
</code></pre><p>另外，当我们使用requestImageForAsset 发出对图像的请求时，如果在同一个 PHImageManager 中同时对同一个资源发出图像请求，请求的进度是可以共享的，因此我们可以利用这个特性，把 PHImageManager 以单例的形式使用，这样在切换界面时也不用担心无法传递图像的下载进度。例如，在图像的列表页面触发了下载图像，当我们离开列表页面进入预览大图界面时，并不用担心会重新图像会重新下载，只要没有手工取消图像下载，进入预览大图界面下载图像会自动继续从上次的进度下载图像。</p>
<p>如果希望取消下载图像，则可以使用PHImageManager 的 cancelImageRequest 方法，它传入的是请求图像的请求 ID，这个 ID 可以从requestImageForAsset 的返回值中获得，也可以从前面提到的包含图像信息的NSDictionary info 中获得，当然前提是这个这个接收取消请求的 PHImageManager 与刚刚发出请求的 PHImageManager 是同一个实例，如上面所述使用单例是最为简单有效的方式。</p>
<p>最后，还要介绍一个PHImageRequestOptions 的属性 versions，这个属性是指获取的图像是否需要包含系统相册“编辑”功能处理过的信息（如滤镜，旋转等），这一点比 ALAssetLibrary 要灵活很多，ALAssetLibrary 中并不能灵活地控制获取的图像是否带有“编辑”处理过的效果，例如在 ALAsset 中获取原图的接口 fullResolutionImage 获取到的是不带“编辑”效果的图像，要想获取带有“编辑”效果的图像，只能自行处理获取这些滤镜效果，并手工叠加上去。在我们的 UI 框架 QMUI 中就有对获取原图作出这样的封装，整个过程也较为繁琐，而框架中处理 PhotoKit 的部分则灵活很多，这也体现了 PhotoKit 相比 ALAssetLibrary 的最主要特点——复杂但灵活。文章的第三部分也会详细列出如何处理这个问题。</p>
<h6 id="获取图像的优化"><a href="#获取图像的优化" class="headerlink" title="获取图像的优化"></a>获取图像的优化</h6><p>PHImageManager 提供了一个子类PHImageCachingManager 用于处理图像的缓存，但是这个子类并不只是图像本身的缓存，而是更加实用——处理图像的整个加载过程的缓存。例如要在一个collectionView 上展示图像列表这类大量的资源图像的缩略图时，可以利用 PHImageCachingManager预先将一些图像加载到内存中，这对优化 collectionView 滚动时的表现很有帮助。然而，这只是官方说法，实际上由于加载图像的过程并不确定，每个业务加载图像的实际需求都可能不一样，因此PHImageCachingManager 也采用比较松散的方法去控制这些缓存，其中的关键方法：</p>
<pre><code>- (void)startCachingImagesForAssets:(NSArray&lt;PHAsset *&gt; *)assets targetSize:(CGSize)targetSize contentMode:(PHImageContentMode)contentMode options:(nullable PHImageRequestOptions *)options;
</code></pre><p>需要传入一组 PHAsset，以及 targetSize，contentMode，以及一个PHImageRequestOptions，如上面所述，这些参数之间的有着互相影响的作用，因此实际上不同的场景对于每个参数要求都不一样，而这些参数的最佳取值也只能通过实际在场景中测试所得。因此，比起使用PHImageCachingManager，我总结了一些更为简易可行的缓存方法：</p>
<ul>
<li>获取图片时尽量获取预览图，不要直接显示原件，建议获取与设备屏幕同样大小的图像即可，实际上系统相册预览大图时使用的也是预览图，这也是系统相册加载速度快的原因。</li>
<li>获取图片使用异步请求，如上面所述，当请求为异步时返回图像的 block 会被多次调用，先返回低清图，再返回高清图，这样一来可以大大减少 UI 的等待时间。</li>
<li>获取到高清图后可以缓存下来，简单地使用变量缓存即可，尽量在获取到高清图后避免再次发起请求获取图像。因为即使图像原件已经下载下来，重新请求高清图时因为图片的尺寸比较大，因此系统生成图像和剪裁图像也会花费一些时间。</li>
<li>预先加载图像，如像预览大图这类情景中，用户同时只会看到一张大图，因此在观看某一张图片时，预先请求其邻近两张图片，对于加快 UI 的响应很有帮助。</li>
</ul>
<p>经过实际测试，如果请求的是缩略图（即尺寸小的图像），那么即使请求的图像很多，仍不会产生任何不流畅的表现，但如果请求的是高清大图，那么即使只是同时请求几张图都会产生不流畅的状况。如上面提到过的那样，这些的状况的出现很可能是请求大图时由图片元数据产生图像，以及剪裁图像的过程耗时较多。所以按实际表现来看，即使 PhotoKit 有自己的缓存策略，仍然很难避免这部分耗时。因此上面几点优化获取图像的策略重点也是放在减少图像大小，异步请求以及做缓存几个方面。</p>
<p>由于AssetsLibrary在ios9以后被苹果废弃，所有我基于AssetsLibrary和PhotoKit封装了一个简单的相册获取库，能够快速的获取相册、图片。欢迎大家访问。<a href="https://github.com/guiyongdong/PhotoManager" target="_blank" rel="external">传送门:GGPhotoManager</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PhotoKit 是一套比 AssetsLibrary 更完整也更高效的库，对资源的处理跟 AssetsLibrary 也有很大的不同。它是iOS8之后出现的框架，在使用框架之前需要导入&lt;code&gt;#import &amp;lt;Photos/Photos.h&amp;gt;&lt;/code&gt;库&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="iOS照片" scheme="http://www.guiyongdong.com/tags/iOS%E7%85%A7%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS照片开发之AssetsLibrary</title>
    <link href="http://www.guiyongdong.com/2016/10/15/iOS%E7%85%A7%E7%89%87%E5%BC%80%E5%8F%91%E4%B9%8BAssetsLibrary/"/>
    <id>http://www.guiyongdong.com/2016/10/15/iOS照片开发之AssetsLibrary/</id>
    <published>2016-10-15T03:25:30.000Z</published>
    <updated>2017-03-09T07:03:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客讲解了UIImagePickerController的使用，这篇博客简单说一下AssetsLibrary。在 iOS 8 出现之前，开发者只能使用 AssetsLibrary 框架来访问设备的照片库，而在 iOS8 出现之后，苹果提供了一个名为 PhotoKit 的框架。这里主要说AssetsLibrary。</p>
<p>另外值得强调的是，在 iOS 中，照片库并不只是照片的集合，同时也包含了视频。在 AssetsLibrary 中两者都有相同类型的对象去描述，只是类型不同而已。文中为了方便，大部分时候会使用「资源」代表 iOS 中的「照片和视频」。</p>
<a id="more"></a>
<h3 id="AssetsLibrary-组成介绍"><a href="#AssetsLibrary-组成介绍" class="headerlink" title="AssetsLibrary 组成介绍"></a>AssetsLibrary 组成介绍</h3><p>AssetsLibrary 的组成比较符合照片库本身的组成，照片库中的完整照片库对象、相册、相片都能在 AssetsLibrary 中找到一一对应的组成，这使到 AssetsLibrary 的使用变得直观而方便。</p>
<ul>
<li><strong>AssetsLibrary</strong>: 代表整个设备中的资源库（照片库），通过 AssetsLibrary 可以获取和包括设备中的照片和视频</li>
<li><strong>ALAssetsGroup</strong>: 映射照片库中的一个相册，通过 ALAssetsGroup 可以获取某个相册的信息，相册下的资源，同时也可以对某个相册添加资源。</li>
<li><strong>ALAsset</strong>: 映射照片库中的一个照片或视频，通过 ALAsset 可以获取某个照片或视频的详细信息，或者保存照片和视频。</li>
<li><strong>ALAssetRepresentation</strong>: ALAssetRepresentation 是对 ALAsset 的封装（但不是其子类），可以更方便地获取 ALAsset 中的资源信息，每个 ALAsset 都有至少有一个 ALAssetRepresentation 对象，可以通过 defaultRepresentation 获取。而例如使用系统相机应用拍摄的 RAW + JPEG 照片，则会有两个 ALAssetRepresentation，一个封装了照片的 RAW 信息，另一个则封装了照片的 JPEG 信息。</li>
</ul>
<h3 id="AssetsLibrary-的基本使用"><a href="#AssetsLibrary-的基本使用" class="headerlink" title="AssetsLibrary 的基本使用"></a>AssetsLibrary 的基本使用</h3><p>AssetsLibrary 的功能很多，基本可以分为对资源的获取/保存两个部分，保存的部分相对简单，API 也比较少，因此这里不作详细介绍。获取资源的 API 则比较丰富了，一个常见的使用大量 AssetsLibrary API 的例子就是图片选择器（ALAsset Picker）。要制作一个图片选择器，思路应该是获取照片库-列出所有相册-展示相册中的所有图片-预览图片大图。</p>
<p>首先是要检查 App 是否有照片操作授权：</p>
<pre><code>NSString *tipTextWhenNoPhotosAuthorization; // 提示语
// 获取当前应用对照片的访问授权状态
ALAuthorizationStatus authorizationStatus = [ALAssetsLibrary authorizationStatus];
// 如果没有获取访问授权，或者访问授权状态已经被明确禁止，则显示提示语，引导用户开启授权
if (authorizationStatus == ALAuthorizationStatusRestricted || authorizationStatus == ALAuthorizationStatusDenied) {
    NSDictionary *mainInfoDictionary = [[NSBundle mainBundle] infoDictionary];
    NSString *appName = [mainInfoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];
    tipTextWhenNoPhotosAuthorization = [NSString stringWithFormat:@&quot;请在设备的\&quot;设置-隐私-照片\&quot;选项中，允许%@访问你的手机相册&quot;, appName];
    // 展示提示语
}
</code></pre><p>照片操作权限枚举类型:</p>
<pre><code>typedef NS_ENUM(NSInteger, ALAuthorizationStatus) {
ALAuthorizationStatusNotDetermined = 0, 用户尚未做出了选择这个应用程序的问候
ALAuthorizationStatusRestricted,        此应用程序没有被授权访问的照片数据。可能是家长控制权限。
ALAuthorizationStatusDenied,            用户已经明确否认了这一照片数据的应用程序访问.
ALAuthorizationStatusAuthorized         用户已授权应用访问照片数据.
}
</code></pre><p>如果已经获取授权，则可以获取相册列表：</p>
<pre><code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    _assetLibrary = [[ALAssetsLibrary alloc] init];
    _albumsArray = [NSMutableArray array];
    [_assetLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
        NSLog(@&quot;%@&quot;,group);
        //查看相册的名字
        NSLog(@&quot;ALAssetsGroupPropertyName:%@&quot;,[group valueForProperty:ALAssetsGroupPropertyName]);
        //查看相册的类型
        NSLog(@&quot;ALAssetsGroupPropertyType:%@&quot;,[group valueForProperty:ALAssetsGroupPropertyType]);
        //查看相册的存储id
        NSLog(@&quot;ALAssetsGroupPropertyPersistentID:%@&quot;,[group valueForProperty:ALAssetsGroupPropertyPersistentID]);
        //查看相册存储的位置地址
        NSLog(@&quot;ALAssetsGroupPropertyURL:%@&quot;,[group valueForProperty:ALAssetsGroupPropertyURL]);
        //获取相册中一共的资源数量
        int count = [group numberOfAssets];
        //过滤器 设置相册组的筛选条件，ALAssetsFilter类表示筛选条件，allPhotos代表相册只包含相片，allVideos代表只包含视频，allAssets代表包含所有资源
        [group setAssetsFilter:[ALAssetsFilter allPhotos]];

        NSLog(@&quot;count:%d&quot;,count);
        //获取封面图片
        CGImageRef poster = [group posterImage];
        NSLog(@&quot;%@的封面照片是：%@&quot;,[group valueForProperty:ALAssetsGroupPropertyName],[UIImage imageWithCGImage:poster]);
        NSLog(@&quot;====================&quot;);
        if (group) {
            if (group.numberOfAssets &gt; 0) {
                [_albumsArray addObject:group];
            }
        }else {
            if ([_albumsArray count] &gt; 0) {
                // 把所有的相册储存完毕，可以展示相册列表
            } else {
                // 没有任何有资源的相册，输出提示
            }
        }
    } failureBlock:^(NSError *error) {
        NSLog(@&quot;读取失败&quot;);
    }];

}
</code></pre><p>通过上面的代码 我们可以获取到所有的相册组 <strong>ALAssetGroup</strong> 对象，打印所有的ALAssetGroup对象，得到以下信息:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/AssetsLibrary_cons.png?raw=true"><br></div>

<p>首先看一下本地模拟器我创建的相册:</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/AssetsLibrary_photo.png?raw=true" width="375" height="667/"><br></div>

<p>通过对比可以知道 ALAssetsLibrary 在遍历的时候会返回所有的ALAssetGroup对象，一些ALAssetGroup对象下其实并没有照片，所有，在这里会判断一下count是否为0。我们再来看看通过ALAssetsLibrary我们可以获取到相册的哪些信息。通多打印，可以知道，我们能获取相册组的<strong>组名</strong>,<strong>Type</strong>,<strong>count</strong>,<strong>PersistentID</strong>,<strong>URL</strong>,<strong>封面照片</strong><br>这些信息足够在我们开发中使用了。</p>
<p>上面的代码中，遍历出所有的相册列表，并把相册中资源数不为空的相册 ALAssetGroup 对象的引用储存到一个数组中。总结成一下几点：</p>
<ul>
<li>iOS 中允许相册为空，即相册中没有任何资源，如果不希望获取空相册，则需要像上面的代码中那样手动过滤</li>
<li>ALAssetsGroup 有一个 setAssetsFilter 的方法，可以传入一个过滤器，控制只获取相册中的照片或只获取视频。一旦设置过滤，ALAssetsGroup 中资源列表和资源数量的获取也会被自动更新。</li>
<li>整个 AssetsLibrary 中对相册、资源的获取和保存都是使用异步处理（Asynchronous），这是考虑到资源文件体积相当比较大（还可能很大）。例如上面的遍历相册操作，相册的结果使用 block 输出，如果相册遍历完毕，则最后一次输出的 block 中的 group 参数值为 nil。而 stop 参数则是用于手工停止遍历，只要把 *stop 置 YES，则会停止下一次的遍历。关于这一点常常会引起误会，所以需要注意。</li>
</ul>
<h3 id="ALAsset介绍"><a href="#ALAsset介绍" class="headerlink" title="ALAsset介绍"></a>ALAsset介绍</h3><p>现在，已经可以获取相册了，接下来是获取相册中的资源</p>
<pre><code>_imagesAssetArray = [[NSMutableArray alloc] init];
[assetsGroup enumerateAssetsWithOptions:NSEnumerationReverse usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
    if (result) {
        //资源的类型
        NSLog(@&quot;资源的类型:%@&quot;,[result valueForProperty:ALAssetPropertyType]);
        //资源地理位置（无位置信息返回null）
        NSLog(@&quot;资源地理位置:%@&quot;,[result valueForProperty:ALAssetPropertyLocation]);
        //播放时长（照片返回ALErorInvalidProperty)
        NSLog(@&quot;播放时长:%@&quot;,[result valueForProperty:ALAssetPropertyDuration]);
        //方向 共有8个方向，参见：ALAssetOrientation
        NSLog(@&quot;方向:%@&quot;,[result valueForProperty:ALAssetPropertyOrientation]);
        //拍摄时间 包含了年与日时分秒
        NSLog(@&quot;拍摄时间:%@&quot;,[result valueForProperty:ALAssetPropertyDate]);
        //描述（打印看了下，只有带后缀的名称）
        NSLog(@&quot;描述:%@&quot;,[result valueForProperty:ALAssetPropertyRepresentations]);
        //返回一个字典，键值分别是文件名和文件的url
        NSLog(@&quot;urlinfo:%@&quot;,[result valueForProperty:ALAssetPropertyURLs]);
        //文件的url
        NSLog(@&quot;url:%@&quot;,[result valueForProperty:ALAssetPropertyAssetURL]);

        //原始资源。若没有保存修改后资源，则原始资源为nil
        NSLog(@&quot;原始资源:%@&quot;,result.originalAsset);
        //指示资源是否可以编辑，只读属性
        NSLog(@&quot;原始资源:%@&quot;,result.editable);
        //获取小正方形的缩略图
        NSLog(@&quot;小正方形的缩略图:%@&quot;,[result thumbnail]);
        //按原始资源长宽比例的缩略图
        NSLog(@&quot;按原始资源长宽比例的缩略图:%@&quot;,[result aspectRatioThumbnail]);
        NSLog(@&quot;=========================&quot;);
        NSLog(@&quot; &quot;);


        [_imagesAssetArray addObject:result];
    } else {
        // result 为 nil，即遍历相片或视频完毕，可以展示资源列表
    }
}];
</code></pre><p>控制台输出信息：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/AssetsLibrary_cons1.png?raw=true"><br></div>

<p>跟遍历相册的过程类似，遍历相片也是使用一系列的异步方法，其中上面的方法所输出的 block 中，除了 result 参数表示资源信息，stop 用于手工停止遍历外，还提供了一个 index 参数，这个参数表示资源的索引。一般来说，展示资源列表都会使用缩略图（result.thumbnail），因此即使资源很多，遍历资源的速度也会相当快。但如果确实需要加载资源的高清图或者其他耗时的处理，则可以利用上面的 index 参数和 stop 参数做一个分段拉取资源。例如：</p>
<pre><code>NSUInteger _targetIndex; // index 目标值，拉取资源直到这个值就手工停止拉取
NSUInteger _currentIndex; // 当前 index，每次拉取资源时从这个值开始

_targetIndex = 50;
_currentIndex = 0;

- (void)loadAssetWithAssetsGroup:(assetsGroup *)assetsGroup {
    [assetsGroup enumerateAssetsAtIndexes:[NSIndexSet indexSetWithIndex:_currentIndex] options:NSEnumerationReverse usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
        _currentIndex = index;
        if (index &gt; _targetIndex) {
            // 拉取资源的索引如果比目标值大，则停止拉取
            *stop = YES;
        } else {
            if (result) {
                [_imagesAssetArray addObject:result];
            } else {
                // result 为 nil，即遍历相片或视频完毕
            }
        }
    }];
}

// 之前拉取的数据已经显示完毕，需要展示新数据，重新调用 loadAssetWithAssetsGroup 方法，并根据需要更新 _targetIndex 的值
</code></pre><p>以上两种方法都能获取到ALAssetsGroup中的ALAsset，ALAsset代表一个资源对象 通多ALAsset就可以获取到资源的详细信息。</p>
<h3 id="ALAssetRepresentation介绍"><a href="#ALAssetRepresentation介绍" class="headerlink" title="ALAssetRepresentation介绍"></a>ALAssetRepresentation介绍</h3><p>最后一步是获取图片详细信息，例如：</p>
<pre><code>- (UIImage *)getImageWithAsset:(ALAsset *)asset {
    // 获取资源图片的详细资源信息，其中 imageAsset 是某个资源的 ALAsset 对象
    ALAssetRepresentation *representation = [asset defaultRepresentation];
    // 获取资源图片的 fullScreenImage
    UIImage *contentImage = [UIImage imageWithCGImage:[representation fullScreenImage]];

    return contentImage;
}
</code></pre><p>对于一个 ALAssetRepresentation，里面包含了图片的多个版本。最常用的是 fullResolutionImage 和 fullScreenImage。fullResolutionImage 是图片的原图，通过 fullResolutionImage 获取的图片没有任何处理，包括通过系统相册中“编辑”功能处理后的信息也没有被包含其中，因此需要展示“编辑”功能处理后的信息，使用 fullResolutionImage 就比较不方便，另外 fullResolutionImage 的拉取也会比较慢，在多张 fullResolutionImage 中切换时能明显感觉到图片的加载过程。因此这里建议获取图片的 fullScreenImage，它是图片的全屏图版本，这个版本包含了通过系统相册中“编辑”功能处理后的信息，同时也是一张缩略图，但图片的失真很少，缺点是图片的尺寸是一个适应屏幕大小的版本，因此展示图片时需要作出额外处理，但考虑到加载速度非常快的原因（在多张图片之间切换感受不到图片加载耗时），仍建议使用 fullScreenImage。另外ALAssetRepresentation还包含的其他的资源属性，例如：acale(长宽比例),filename(文件名字)等。</p>
<p>系统相册的处理过程大概也是如上，可以看出，在整个过程中并没有使用到图片的 fullResolutionImage，从相册列表展示到最终查看资源，都是使用缩略图，这也是 iOS 相册加载快的一个重要原因。</p>
<h3 id="AssetsLibrary的写"><a href="#AssetsLibrary的写" class="headerlink" title="AssetsLibrary的写"></a>AssetsLibrary的写</h3><p><strong>创建相册组：</strong></p>
<pre><code>- (IBAction)createFileName:(id)sender {
    [self.assetLibrary addAssetsGroupAlbumWithName:@&quot;rrrrr&quot; resultBlock:^(ALAssetsGroup *group) {
        if (group) {
            //表明本地没有这个相册组
            NSLog(@&quot;本地没有这个相册组&quot;);
        }else {
            //表明本地有这个相册组
            NSLog(@&quot;本地有这个相册组&quot;);
        }
        NSLog(@&quot;%@&quot;,group);
    } failureBlock:^(NSError *error) {

    }];
}
</code></pre><p><strong>保存图片到指定相册组</strong></p>
<pre><code>- (IBAction)addImage:(id)sender {
    UIImage *image = [UIImage imageNamed:@&quot;aaa&quot;];
    //保存到系统照片 并保存到指定相册组
    __weak typeof (self)weakSelf = self;
    [self.assetLibrary writeImageToSavedPhotosAlbum:[image CGImage] orientation:ALAssetOrientationUp completionBlock:^(NSURL *assetURL, NSError *error) {

        [weakSelf.assetLibrary addAssetsGroupAlbumWithName:@&quot;Www&quot; resultBlock:^(ALAssetsGroup *group) {
            if (group) {
                //如果group不为空 表明新创建一个 ALAssetsGroup


                [weakSelf.assetLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
                    //添加资源
                    [group addAsset:asset];
                } failureBlock:^(NSError *error) {
                    NSLog(@&quot;查询照片失败&quot;);
                }];
            }else {
                //如果group为空 表明系统内已经有一个 ALAssetsGroup
                [weakSelf.assetLibrary enumerateGroupsWithTypes:ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
                    NSString *groupName = [group valueForProperty:ALAssetsGroupPropertyName];
                    if ([groupName isEqualToString:@&quot;Www&quot;]) {
                        [weakSelf.assetLibrary assetForURL:assetURL resultBlock:^(ALAsset *asset) {
                            [group addAsset:asset];
                        } failureBlock:^(NSError *error) {
                            NSLog(@&quot;查询照片失败&quot;);
                        }];
                    }
                } failureBlock:^(NSError *error) {

                }];
            }
            NSLog(@&quot;%@&quot;,group);
        } failureBlock:^(NSError *error) {

        }];   
    }];
}
</code></pre><h3 id="AssetsLibrary-的坑点"><a href="#AssetsLibrary-的坑点" class="headerlink" title="AssetsLibrary 的坑点"></a>AssetsLibrary 的坑点</h3><p>作为一套老框架，AssetsLibrary 不但有坑，而且还不少，除了上面提到的资源异步拉取时需要注意的事项，下面几点也是值得注意的：</p>
<h5 id="1-AssetsLibrary-实例需要强引用"><a href="#1-AssetsLibrary-实例需要强引用" class="headerlink" title="1. AssetsLibrary 实例需要强引用"></a>1. AssetsLibrary 实例需要强引用</h5><p>实例一个 AssetsLibrary 后，如上面所示，我们可以通过一系列枚举方法获取到需要的相册和资源，并把其储存到数组中，方便用于展示。但是，当我们把这些获取到的相册和资源储存到数组时，实际上只是在数组中储存了这些相册和资源在 AssetsLibrary 中的引用（指针），因而无论把相册和资源储存数组后如何利用这些数据，都首先需要确保 AssetsLibrary 没有被 ARC 释放，否则把数据从数组中取出来时，会发现对应的引用数据已经丢失（参见下图）。这一点较为容易被忽略，因此建议在使用 AssetsLibrary 的 viewController 中，把 AssetsLibrary 作为一个强持有的 property 或私有变量，避免在枚举出 AssetsLibrary 中所需要的数据后，AssetsLibrary 就被 ARC 释放了。</p>
<p>如下图：实例化一个 AssetsLibrary 的局部变量，枚举所有相册并储存在名为 _albumsArray 的数组中，展示相册时再次查看数组，发现 ALAssetsGroup 中的数据已经丢失。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/photo/ALAssetsLibrary_release.png?raw=true"><br></div>

<h5 id="2-AssetsLibrary-遵循写入优先原则"><a href="#2-AssetsLibrary-遵循写入优先原则" class="headerlink" title="2. AssetsLibrary 遵循写入优先原则"></a>2. AssetsLibrary 遵循写入优先原则</h5><p>写入优先也就是說，在利用 AssetsLibrary 读取资源的过程中，有任何其它的进程（不一定是同一个 App）在保存资源时，就会收到 ALAssetsLibraryChangedNotification，让用户自行中断读取操作。最常见的就是读取 fullResolutionImage 时，用进程在写入，由于读取 fullResolutionImage 耗时较长，很容易就会 exception。</p>
<h5 id="开启-Photo-Stream-容易导致-exception"><a href="#开启-Photo-Stream-容易导致-exception" class="headerlink" title="开启 Photo Stream 容易导致 exception"></a>开启 Photo Stream 容易导致 exception</h5><p>本质上，这跟上面的 AssetsLibrary 遵循写入优先原则是同一个问题。如果用户开启了共享照片流（Photo Stream），共享照片流会以 mstreamd 的方式“偷偷”执行，当有人把相片写入 Camera Roll 时，它就会自动保存到 Photo Stream Album 中，如果用户刚好在读取，那就跟上面说的一样产生 exception 了。由于共享照片流是用户决定是否要开启的，所以开发者无法改变，但是可以通过下面的接口在需要保护的时刻关闭监听共享照片流产生的频繁通知信息。</p>
<pre><code>[ALAssetsLibrary disableSharedPhotoStreamsSupport];
</code></pre><p>下一篇博客会介绍iOS8以后出现的框架 <a href="http://www.guiyongdong.com/2016/10/22/iOS%E7%85%A7%E7%89%87%E5%BC%80%E5%8F%91%E4%B9%8BPhotoKit/"><strong>PhotoKit</strong></a> 敬请关注!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博客讲解了UIImagePickerController的使用，这篇博客简单说一下AssetsLibrary。在 iOS 8 出现之前，开发者只能使用 AssetsLibrary 框架来访问设备的照片库，而在 iOS8 出现之后，苹果提供了一个名为 PhotoKit 的框架。这里主要说AssetsLibrary。&lt;/p&gt;
&lt;p&gt;另外值得强调的是，在 iOS 中，照片库并不只是照片的集合，同时也包含了视频。在 AssetsLibrary 中两者都有相同类型的对象去描述，只是类型不同而已。文中为了方便，大部分时候会使用「资源」代表 iOS 中的「照片和视频」。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="iOS照片" scheme="http://www.guiyongdong.com/tags/iOS%E7%85%A7%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS照片开发之UIImagePickerController</title>
    <link href="http://www.guiyongdong.com/2016/10/12/iOS%E7%85%A7%E7%89%87%E5%BC%80%E5%8F%91%E4%B9%8BUIImagePickerController/"/>
    <id>http://www.guiyongdong.com/2016/10/12/iOS照片开发之UIImagePickerController/</id>
    <published>2016-10-12T02:37:08.000Z</published>
    <updated>2017-03-09T07:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS开发中，通常获取照片的方式有三种，1.直接调用摄像头拍照 2.从相册中选择 3.从图库中选择。 通常使用到的类或框架有UIImagePickerController,AssetsLibrary,PhotoKit(iOS8later)。本篇博客主要讲解UIImagePickerController，其他的后续会讲解到。</p>
<a id="more"></a>
<h3 id="UIImagePickerController"><a href="#UIImagePickerController" class="headerlink" title="UIImagePickerController"></a>UIImagePickerController</h3><p>UIImagePickerController 是系统提供的用来获取图片和视频的类;</p>
<p>用UIImagePickerController 类来获取图片视频，大体分为以下几个步骤：</p>
<pre><code>1. 初始化UIImagePickerController 类；
2. 设置UIImagePickerController 实例的数据来源类型（下面解释）；
3. 设置代理；
4. 如果需要做图片修改的话设置allowsEditing =yes。
</code></pre><p><strong>数据来源类型一共有三种：</strong></p>
<pre><code>enum {
    UIImagePickerControllerSourceTypePhotoLibrary ,//来自图库
    UIImagePickerControllerSourceTypeCamera ,//来自相机
    UIImagePickerControllerSourceTypeSavedPhotosAlbum //来自相册
};
</code></pre><p>在用这些来源的时候最好检测以下设备是否支持；</p>
<pre><code>if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera])
{
    NSLog(@&quot;支持相机&quot;);
}
if([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypePhotoLibrary])
{
    NSLog(@&quot;支持图库&quot;);
}
if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeSavedPhotosAlbum])
{
    NSLog(@&quot;支持相片库&quot;);
}
</code></pre><p>调用摄像头来获取资源</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    picker = [[UIImagePickerController alloc]init];
    //获取照片的类型
    UIImagePickerControllerSourceType sourcheType = UIImagePickerControllerSourceTypeCamera;
    picker.sourceType = sourcheType;
    //设置代理
    picker.delegate = self;
    //是否允许编辑
    picker.allowsEditing = YES;
}
</code></pre><p>上面只是实例了UIImagePickerController及其属性 在需要获取图片的时候需要弹出窗口调用</p>
<pre><code>[self presentViewController:picker animated:YES completion:nil];
</code></pre><p>代理中一共三个方法 其中一个3.0 已经废弃了，只剩下两个我们需要用的.<br>1.当用户选取完成后调用:</p>
<pre><code>- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info;
</code></pre><p><strong>选取的信息都在info中，info 是一个字典:</strong><br>字典中的键：</p>
<pre><code>NSString *const  UIImagePickerControllerMediaType ;指定用户选择的媒体类型（文章最后进行扩展）
NSString *const  UIImagePickerControllerOriginalImage ;原始图片
NSString *const  UIImagePickerControllerEditedImage ;修改后的图片
NSString *const  UIImagePickerControllerCropRect ;裁剪尺寸
NSString *const  UIImagePickerControllerMediaURL ;媒体的URL
NSString *const  UIImagePickerControllerReferenceURL ;原件的URL
NSString *const  UIImagePickerControllerMediaMetadata;当来数据来源是照相机的时候这个值才有效
</code></pre><p>1.当用户取消选取时调用:</p>
<pre><code>- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker;
</code></pre><p>UIImagePickerControllerMediaType 包含着KUTTypeImage 和KUTTypeMovie</p>
<p>1.KUTTypeImage 包含:</p>
<pre><code>const CFStringRef  kUTTypeImage ;抽象的图片类型
const CFStringRef  kUTTypeJPEG ;
const CFStringRef  kUTTypeJPEG2000 ;
const CFStringRef  kUTTypeTIFF ;
const CFStringRef  kUTTypePICT ;
const CFStringRef  kUTTypeGIF ;
const CFStringRef  kUTTypePNG ;
const CFStringRef  kUTTypeQuickTimeImage ;
const CFStringRef  kUTTypeAppleICNS 
const CFStringRef kUTTypeBMP;
const CFStringRef  kUTTypeICO;
</code></pre><p>2.KUTTypeMovie 包含:</p>
<pre><code>const CFStringRef  kUTTypeAudiovisualContent ;抽象的声音视频
const CFStringRef  kUTTypeMovie ;抽象的媒体格式（声音和视频）
const CFStringRef  kUTTypeVideo ;只有视频没有声音
const CFStringRef  kUTTypeAudio ;只有声音没有视频
const CFStringRef  kUTTypeQuickTimeMovie ;
const CFStringRef  kUTTypeMPEG ;
const CFStringRef  kUTTypeMPEG4 ;
const CFStringRef  kUTTypeMP3 ;
const CFStringRef  kUTTypeMPEG4Audio ;
const CFStringRef  kUTTypeAppleProtectedMPEG4Audio;
</code></pre><p>好了,写了个小Demo,直接上代码了</p>
<pre><code>#import &quot;ViewController.h&quot;

@interface ViewController ()&lt;UIImagePickerControllerDelegate,UINavigationControllerDelegate&gt;

/** imageView */
@property (nonatomic, strong) UIImageView *imageView;

/** imageViewR */
@property (nonatomic, strong) UIImageView *imageViewR;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.imageViewR = [[UIImageView alloc] initWithFrame:CGRectMake((self.view.frame.size.width - 100)/2, 30, 100, 100)];
    self.imageViewR.backgroundColor = [UIColor grayColor];
    self.imageViewR.layer.cornerRadius = 50;
    self.imageViewR.layer.masksToBounds = YES; // 裁剪边
    [self.view addSubview:self.imageViewR];

    self.imageView = [[UIImageView alloc] initWithFrame:CGRectMake(16, 140, self.view.frame.size.width - 32, self.view.frame.size.width - 32)];
    self.imageView.backgroundColor = [UIColor grayColor];
    [self.view addSubview:self.imageView];

    UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom];
    btn.frame = CGRectMake(16, CGRectGetMaxY(self.imageView.frame) + 20, self.view.frame.size.width - 32, 35);
    btn.backgroundColor = [UIColor greenColor];
    btn.layer.cornerRadius = 5;
    btn.layer.masksToBounds = YES;
    [btn setTitle:@&quot;获取图片&quot; forState:UIControlStateNormal];
    [btn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:btn];
}

- (void)btnClick:(UIButton *)button
{
    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;选择照片&quot; message:nil preferredStyle:(UIAlertControllerStyleActionSheet)];
    // 判断是否支持相机
    if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) {
        UIAlertAction *cameraAc = [UIAlertAction actionWithTitle:@&quot;拍照&quot; style:(UIAlertActionStyleDefault) handler:^(UIAlertAction * _Nonnull action) {
            UIImagePickerController *imagePickerController = [[UIImagePickerController alloc] init];
            imagePickerController.delegate = self;
            imagePickerController.allowsEditing = YES;
            // 设置数据源类型
            imagePickerController.sourceType = UIImagePickerControllerSourceTypeCamera;
            [self presentViewController:imagePickerController animated:YES completion:nil];
        }];
        [alertController addAction:cameraAc];
    }
    // 图集
    UIAlertAction *photoAc = [UIAlertAction actionWithTitle:@&quot;相册&quot; style:(UIAlertActionStyleDefault) handler:^(UIAlertAction * _Nonnull action) {
        UIImagePickerController *imagePickerController = [[UIImagePickerController alloc] init];
        imagePickerController.delegate = self;
        imagePickerController.allowsEditing = YES;
        imagePickerController.sourceType = UIImagePickerControllerSourceTypePhotoLibrary;
        [self presentViewController:imagePickerController animated:YES completion:nil];
    }];
    [alertController addAction:photoAc];

    // 相片库
    UIAlertAction *albumAc = [UIAlertAction actionWithTitle:@&quot;相片库&quot; style:(UIAlertActionStyleDefault) handler:^(UIAlertAction * _Nonnull action) {
        UIImagePickerController *imagePickerController = [[UIImagePickerController alloc] init];
        imagePickerController.delegate = self;
        imagePickerController.allowsEditing = YES;
        imagePickerController.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;;
        [self presentViewController:imagePickerController animated:YES completion:nil];
    }];
    [alertController addAction:albumAc];

    UIAlertAction *cancel = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {

    }];

    [alertController addAction:cancel];

    [self presentViewController:alertController animated:YES completion:nil];

}


- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker
{
    [self dismissViewControllerAnimated:YES completion:nil];
}

// 代理方法,获取图片
// 选取的信息都在info中，info 是一个字典。
/**
// info dictionary keys
UIKIT_EXTERN NSString *const UIImagePickerControllerMediaType __TVOS_PROHIBITED;      // an NSString (UTI, i.e. kUTTypeImage)
UIKIT_EXTERN NSString *const UIImagePickerControllerOriginalImage __TVOS_PROHIBITED;  // a UIImage
UIKIT_EXTERN NSString *const UIImagePickerControllerEditedImage __TVOS_PROHIBITED;    // a UIImage
UIKIT_EXTERN NSString *const UIImagePickerControllerCropRect __TVOS_PROHIBITED;       // an NSValue (CGRect)
UIKIT_EXTERN NSString *const UIImagePickerControllerMediaURL __TVOS_PROHIBITED;       // an NSURL
UIKIT_EXTERN NSString *const UIImagePickerControllerReferenceURL        NS_AVAILABLE_IOS(4_1) __TVOS_PROHIBITED;  // an NSURL that references an asset in the AssetsLibrary framework
UIKIT_EXTERN NSString *const UIImagePickerControllerMediaMetadata       NS_AVAILABLE_IOS(4_1) __TVOS_PROHIBITED;  // an NSDictionary containing metadata from a captured photo
UIKIT_EXTERN NSString *const UIImagePickerControllerLivePhoto NS_AVAILABLE_IOS(9_1) __TVOS_PROHIBITED;  // a PHLivePhoto
/
- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info
{
    [picker dismissViewControllerAnimated:YES completion:nil];

    UIImage *image = [info objectForKey:UIImagePickerControllerEditedImage];

    // 保存图片到本地沙盒,
    [self saveImage:image withName:@&quot;avatar.png&quot;];

    NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:@&quot;avatar.png&quot;];
    UIImage *saveImage = [[UIImage alloc] initWithContentsOfFile:fullPath];

    // 设置图片显示
    self.imageView.image = saveImage;
    self.imageViewR.image = saveImage;
}

- (void)saveImage:(UIImage *)currentImage withName:(NSString *)imageName
{
    NSData *imageData = UIImageJPEGRepresentation(currentImage, 1); // 1为不缩放保存,取值为(0~1)

    // 获取沙河路径
    NSString *fullPath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:imageName];
    // 将照片写入文件
    [imageData writeToFile:fullPath atomically:NO];
}

- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

@end
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发中，通常获取照片的方式有三种，1.直接调用摄像头拍照 2.从相册中选择 3.从图库中选择。 通常使用到的类或框架有UIImagePickerController,AssetsLibrary,PhotoKit(iOS8later)。本篇博客主要讲解UIImagePickerController，其他的后续会讲解到。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="http://www.guiyongdong.com/categories/Objective-C/"/>
    
    
      <category term="iOS照片" scheme="http://www.guiyongdong.com/tags/iOS%E7%85%A7%E7%89%87/"/>
    
  </entry>
  
</feed>
