
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="贵大头的博客">
    <title>load 方法全程跟踪 - 贵大头的博客</title>
    <meta name="author" content="贵永冬">
<link rel="icon" href="https://github.com/guiyongdong/Resource/blob/master/hexoImage/favicon.ico?raw=true">
    
    
        <link rel="icon" href="https://github.com/guiyongdong/Resource/blob/master/hexoImage/favicon.ico?raw=true">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="load方法的调用时机我们都知道，每个类都有两个初始化方法，其中一个就是load方法，对于每一个Class和Category来说，必定会调用此方法，而且仅调用一次。当包含Class和Category的程序被库载入系统时，就会执行此方法，并且此过程通常是在程序启动的时候执行。
不同的是，现在iOS系统中已经加入了动态加载特性，这是从macOS应用程序中迁移而来的特性，等应用程序启动好之后再去加载程序">
<meta property="og:type" content="blog">
<meta property="og:title" content="load 方法全程跟踪">
<meta property="og:url" content="http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/index.html">
<meta property="og:site_name" content="贵大头的博客">
<meta property="og:description" content="load方法的调用时机我们都知道，每个类都有两个初始化方法，其中一个就是load方法，对于每一个Class和Category来说，必定会调用此方法，而且仅调用一次。当包含Class和Category的程序被库载入系统时，就会执行此方法，并且此过程通常是在程序启动的时候执行。
不同的是，现在iOS系统中已经加入了动态加载特性，这是从macOS应用程序中迁移而来的特性，等应用程序启动好之后再去加载程序">
<meta property="og:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load1.png?raw=true">
<meta property="og:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load2.png?raw=true">
<meta property="og:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load3.png?raw=true">
<meta property="og:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load4.png?raw=true">
<meta property="og:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load5.png?raw=true">
<meta property="og:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load6.png?raw=true">
<meta property="og:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load6.png?raw=true">
<meta property="og:updated_time" content="2017-07-15T06:38:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="load 方法全程跟踪">
<meta name="twitter:description" content="load方法的调用时机我们都知道，每个类都有两个初始化方法，其中一个就是load方法，对于每一个Class和Category来说，必定会调用此方法，而且仅调用一次。当包含Class和Category的程序被库载入系统时，就会执行此方法，并且此过程通常是在程序启动的时候执行。
不同的是，现在iOS系统中已经加入了动态加载特性，这是从macOS应用程序中迁移而来的特性，等应用程序启动好之后再去加载程序">
<meta name="twitter:image" content="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load1.png?raw=true">
    
    
        
    
    
        <meta property="og:image" content="http://www.guiyongdong.com/assets/images/header.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-yrst5vo1nxaxbp2g3v9na2wg1lixlpr3ghbjdvskeixmu79deycecx3rh4bt.min.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
    <!--STYLES END-->
    
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">贵大头的博客</a>
    </div>
    
        
            <a  class="header-right-icon "
                href="#about">
        
        
            <i class="fa fa-lg fa-header.jpg"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/header.jpg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">贵永冬</h4>
                
                    <h5 class="sidebar-profile-bio"><p>iOS开发者<br> 会一点RN和android,  十足的海贼迷</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/guiyongdong" target="_blank">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:564024928@qq.com" target="_blank">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                        <span class="sidebar-button-desc">订阅</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            load 方法全程跟踪
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" datetime="2017-07-14T12:00:41+08:00">
	
		    7月 14, 2017
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Objective-C/">Objective-C</a>


    
</div>

</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <h3 id="load方法的调用时机"><a href="#load方法的调用时机" class="headerlink" title="load方法的调用时机"></a>load方法的调用时机</h3><p>我们都知道，每个类都有两个初始化方法，其中一个就是<code>load</code>方法，对于每一个<code>Class</code>和<code>Category</code>来说，必定会调用此方法，而且仅调用一次。当包含<code>Class</code>和<code>Category</code>的程序被库载入系统时，就会执行此方法，并且此过程通常是在程序启动的时候执行。</p>
<p>不同的是，现在<code>iOS</code>系统中已经加入了动态加载特性，这是从<code>macOS</code>应用程序中迁移而来的特性，等应用程序启动好之后再去加载程序库。如果<code>Class</code>和其<code>Category</code>中都重写了<code>load</code>方法，则先调用<code>Class</code>中的。那么为什么会先调用<code>Class</code>的<code>load</code>方法呢？通过这篇文章想必你会有个答案。</p>
<a id="more"></a>
<p>因为<code>Objective-C</code>的<code>runtime</code>只能在<code>macOS</code>下才能编译，所以，文章中的所有代码都是在<code>macOS</code>下运行了，这里推荐大家直接使用<a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="external">RetVal</a>封装好的<code>debug</code>版最新源码进行断点调试，来追踪一下<code>load</code>方法的全部处理过程，以便于了解这个函数以及<code>Objective-C</code>强大的动态性。</p>
<p>创建一个<code>Class</code>文件<code>GGObject</code>和两个分类<code>GGObject+GG</code>、<code>NSString+GG</code>，然后分别在这三个文件中添加<code>load</code>方法。运行程序，会看到<code>load</code>方法的调用时机是在入口函数主程序之前。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load1.png?raw=true"><br></div>

<p>然后在<code>GGObject</code>中<code>load</code>方法下增加断点，查看其调用栈并跟踪函数执行时候的上层代码：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load2.png?raw=true"><br></div>

<p>调用栈显示栈情况如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="number">0</span> +[GGObject load]</div><div class="line"><span class="number">1</span> call_class_loads()</div><div class="line"><span class="number">2</span> call_load_methods()</div><div class="line"><span class="number">3</span> load_images(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> mach_header *)</div><div class="line"><span class="number">4</span> dyld::notifySingle(dyld_image_states, ImageLoader <span class="keyword">const</span>*, ImageLoader::InitializerTimingList*)</div><div class="line"><span class="number">11</span> _dyld_start</div></pre></td></tr></table></figure>
<p>追其源头，从<code>_dyld_start</code>开始研究。<strong>dyld(The Dynamic Link Editor)</strong>是苹果的动态链接库，系统内核做好程序启动的初始准备后，将其他事务交给<code>dyld</code>负责。这里不再细究。</p>
<p>在研究<code>load_images</code>方法之前，先来研究一下什么是<code>images</code>，<code>images</code>表示的是二进制文件编译后的符号、代码等。所以<code>load_images</code>的工作是传入处理过后的二进制文件并让<code>runtime</code>进行处理，并且每一个文件对应一个抽象实例来负责加载，这里的实例是<code>ImageLoader</code>，从调用栈的方法4可以清楚的看到参数类型：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">dyld::notifySingle(dyld_image_states, ImageLoader <span class="keyword">const</span>*, ImageLoader::InitializerTimingList*)</div></pre></td></tr></table></figure>
<p><code>ImageLoader</code>处理二进制文件的时机是在<code>main</code>入口函数以前，它在加载文件时主要做两个工作：</p>
<ul>
<li>在程序运行时它先将动态链接的<code>image</code>递归加载</li>
<li>再从可执行文件<code>image</code>递归加载所有符号</li>
</ul>
<p>我们可以通过断点来打印出所有加载的<code>image</code>。在刚才断点的调用栈中，选中<code>3 load_images(const char*, const mach_header *)</code>，并添加断点：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load3.png?raw=true"><br></div>

<p>这样可以将当前的<code>image</code>全部显示，我们列出来<code>image</code>的<code>path</code>和<code>slice</code>信息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">(<span class="keyword">const</span> <span class="keyword">char</span> *) $<span class="number">0</span> = <span class="number">0x000000010004d0b8</span> <span class="string">"/Users/guiyongdong/Library/Developer/Xcode/DerivedData/objc-gursabanmdkytddcknzhdonlrrvk/Build/Products/Debug/libobjc.A.dylib"</span></div><div class="line">(<span class="keyword">const</span> mach_header *) $<span class="number">1</span> = <span class="number">0x00000001000ad000</span></div><div class="line">(<span class="keyword">const</span> <span class="keyword">char</span> *) $<span class="number">2</span> = <span class="number">0x00007fffd60caec8</span> <span class="string">"/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation"</span></div><div class="line">(<span class="keyword">const</span> mach_header *) $<span class="number">3</span> = <span class="number">0x00007fffd60ca000</span></div><div class="line">(<span class="keyword">const</span> <span class="keyword">char</span> *) $<span class="number">4</span> = <span class="number">0x00007fffead2d9d0</span> <span class="string">"/usr/lib/libnetwork.dylib"</span></div><div class="line">(<span class="keyword">const</span> mach_header *) $<span class="number">5</span> = <span class="number">0x00007fffead2d000</span></div><div class="line">(<span class="keyword">const</span> <span class="keyword">char</span> *) $<span class="number">6</span> = <span class="number">0x00007fffd52bbc50</span> <span class="string">"/System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork"</span></div><div class="line">(<span class="keyword">const</span> mach_header *) $<span class="number">7</span> = <span class="number">0x00007fffd52bb000</span></div><div class="line">(<span class="keyword">const</span> <span class="keyword">char</span> *) $<span class="number">8</span> = <span class="number">0x00007fffda1a5610</span> <span class="string">"/System/Library/Frameworks/NetFS.framework/Versions/A/NetFS"</span></div><div class="line">(<span class="keyword">const</span> mach_header *) $<span class="number">9</span> = <span class="number">0x00007fffda1a5000</span></div><div class="line">(<span class="keyword">const</span> <span class="keyword">char</span> *) $<span class="number">10</span> = <span class="number">0x00007fffe4ef0a20</span> <span class="string">"/System/Library/PrivateFrameworks/LanguageModeling.framework/Versions/A/LanguageModeling"</span></div><div class="line">(<span class="keyword">const</span> mach_header *) $<span class="number">11</span> = <span class="number">0x00007fffe4ef0000</span></div><div class="line">(<span class="keyword">const</span> <span class="keyword">char</span> *) $<span class="number">12</span> = <span class="number">0x00007fffd5d42b10</span> <span class="string">"/System/Library/Frameworks/CoreData.framework/Versions/A/CoreData"</span></div><div class="line">(<span class="keyword">const</span> mach_header *) $<span class="number">13</span> = <span class="number">0x00007fffd5d42000</span></div><div class="line">(<span class="keyword">const</span> <span class="keyword">char</span> *) $<span class="number">14</span> = <span class="number">0x00007fffeaa53ac0</span> <span class="string">"/usr/lib/libmecabra.dylib"</span></div><div class="line">(<span class="keyword">const</span> mach_header *) $<span class="number">15</span> = <span class="number">0x00007fffeaa53000</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>这里会传入很多的动态链接库<code>.dylib</code>以及官方静态框架<code>.framework</code>的image，而<code>path</code>就是其对应的二进制文件的地址。在<code>&lt;mach-o/dyld.h&gt;</code>动态库头文件中，也为我们提供了查询所有动态库<code>image</code>的方法，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">listImages</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">uint32_t</span> i;</div><div class="line">    <span class="keyword">uint32_t</span> ic = <span class="number">_</span>dyld_image_count();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"image 的个数 %d \n"</span>,ic);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic; i++) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %p\t%s\t(slide: %ld)\n"</span>,</div><div class="line">               i,</div><div class="line">               <span class="number">_</span>dyld_get_image_header(i),</div><div class="line">               <span class="number">_</span>dyld_get_image_name(i),</div><div class="line">               <span class="number">_</span>dyld_get_image_vmaddr_slide(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line">    listImages();</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        NSLog(@<span class="string">"Application start"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以通过系统库提供的接口方法，来深入学习官方的动态库情况：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load4.png?raw=true"><br></div>

<h3 id="load-images"><a href="#load-images" class="headerlink" title="load_images"></a>load_images</h3><p>此时，系统已经将所有的<code>image</code>加载进内存，然后交由<code>load_images</code>函数来解析。我们来分析一下<code>load_images</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">load_images</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path <span class="number">__u</span>nused, <span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mh)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 先快速的查找image中是否有Class或者Category需要加载 如果没有 直接返回</span></div><div class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 定义可递归锁对象</span></div><div class="line">    <span class="comment">// 由于 load_images 方法由dyld进行回调，所以数据需要上锁才能保证线程安全</span></div><div class="line">    <span class="comment">// 为了防止多次加锁造成的死锁情况，使用递归锁解决</span></div><div class="line">    <span class="keyword">recursive_mutex_locker_t</span> lock(loadMethodLock);</div><div class="line">    </div><div class="line">    <span class="comment">// 收集所有的 load 方法</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 对 Darwin 提供的线程写锁的封装类</span></div><div class="line">        <span class="keyword">rwlock_writer_t</span> lock2(runtimeLock);</div><div class="line">        <span class="comment">// 提前准备好满足 load 方法调用条件的 Class</span></div><div class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 调用 所有的load 方法 (without runtimeLock - re-entrant)</span></div><div class="line">    call_load_methods();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们一步一步分析。首先调用的是<code>hasLoadMethods</code>函数。其中为了查询<code>load</code>函数列表，会分别查询该函数在内存数据段上指定<code>section</code>区域是否有所记录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 快速查询image中是否有类列表或者分类类别</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> count;</div><div class="line">    <span class="comment">//查询image中是否有类</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">_</span>getObjc2NonlazyClassList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="comment">//查询iamge中是否有Category</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">_</span>getObjc2NonlazyCategoryList(mhdr, &amp;count)  &amp;&amp;  count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>objc-file.mm</code>文件中存在以下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 通过宏处理泛型操作</span></div><div class="line"><span class="comment">// 函数内容是从内存数据段的某个区下查询改位置的情况，并回传指针</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> GETSECT(name, type, sectname)                                   \</span></div><div class="line">    type *name(const headerType *mhdr, size_t *outCount) &#123;              \</div><div class="line">        return getDataSection<span class="meta-string">&lt;type&gt;</span>(mhdr, sectname, nil, outCount);     \</div><div class="line">    &#125;                                                                   \</div><div class="line">    type *name(const header_info *hi, size_t *outCount) &#123;               \</div><div class="line">        return getDataSection<span class="meta-string">&lt;type&gt;</span>(hi-&gt;mhdr(), sectname, nil, outCount); \</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">// 根据dyld 对images的解析来特定区域查询内存</span></div><div class="line">GETSECT(<span class="number">_</span>getObjc2NonlazyClassList,    <span class="keyword">classref_t</span>,      <span class="string">"__objc_nlclslist"</span>);</div><div class="line">GETSECT(<span class="number">_</span>getObjc2NonlazyCategoryList, <span class="keyword">category_t</span> *,    <span class="string">"__objc_nlcatlist"</span>);</div></pre></td></tr></table></figure>
<p>在<code>Apple</code>的官方文档中，我们可以在<code>__DATA</code>段中查询到<code>__objc_classlist</code>的用途，主要是用在访问<code>Objective-C</code>的类列表，而<code>__objc_nlcatlist</code>用于访问<code>Objective-C</code>的分类列表。这一块对类信息的解析是由<code>dyld</code>处理时期完成的，也就是我们上文提到的<code>map_images</code>方法的解析工作。而且从侧面可以看出，<code>Objective-C</code>的强大动态性，与<code>dyld</code>前期处理密不可分。</p>
<p>通过这一步，会将<code>image</code>中的类列表和分类列表的个数快速的查询出来，只要满足其中一个条件就能继续进行，否则<code>image</code>中连类列表和分类列表都没有，就一定不会有<code>load</code>方法。</p>
<h3 id="可递归锁"><a href="#可递归锁" class="headerlink" title="可递归锁"></a>可递归锁</h3><p>接下来需要定义锁，然后加锁。在<code>load_image</code>方法所在的<code>objc-runtime-new.mm</code>中，全局<code>loadMethodLock</code>是一个<code>recursive_mutex_t</code>类型的变量。这个是苹果通过<code>C</code>实现的一个互斥递归锁<code>Class</code>，来解决多次上锁而不会发生死锁的问题。之所以用递归锁，是因为接下来会递归类的父类直到<code>NSObject</code>。</p>
<p><code>recursive_mutex_t</code>其作用与<code>NSRecursiveLock</code>相同，但不是由<code>NSLock</code>再封装，而是通过<code>C</code>为<code>runtime</code>的使用场景而写的一个<code>Class</code>。更多关于线程锁的知识，可以看看我这篇<a href="http://www.guiyongdong.com/2017/06/26/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%90%84%E7%A7%8D%E9%94%81%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/">iOS多线程之各种锁的简单介绍</a></p>
<h3 id="准备-load-运行的从属Class"><a href="#准备-load-运行的从属Class" class="headerlink" title="准备 load 运行的从属Class"></a>准备 load 运行的从属Class</h3><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> count, i;</div><div class="line"></div><div class="line">    runtimeLock.assertWriting();</div><div class="line"></div><div class="line">    <span class="comment">//收集有load方法的Class</span></div><div class="line">    <span class="comment">//获取所有的类的列表</span></div><div class="line">    <span class="keyword">classref_t</span> *classlist = </div><div class="line">        <span class="number">_</span>getObjc2NonlazyClassList(mhdr, &amp;count);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="comment">// 通过remapClass 获取类指针</span></div><div class="line">        <span class="comment">// schedule_class_load 递归到父类逐层载入</span></div><div class="line">        schedule_class_load(remapClass(classlist[i]));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 收集有load方法的Category</span></div><div class="line">    <span class="comment">// 获取所有的Category列表</span></div><div class="line">    <span class="keyword">category_t</span> **categorylist = <span class="number">_</span>getObjc2NonlazyCategoryList(mhdr, &amp;count);</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</div><div class="line">        <span class="comment">// 通过remapClass 获取Category对象存有的Class对象</span></div><div class="line">        Class cls = remapClass(cat-&gt;cls);</div><div class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</div><div class="line">        <span class="comment">// 对类进行第一次初始化，主要用来分配可读写数据空间并返回真正的类结构</span></div><div class="line">        realizeClass(cls);</div><div class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</div><div class="line">        <span class="comment">// 将需要执行load的Category添加到一个全局列表中</span></div><div class="line">        add_category_to_loadable_list(cat);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>prepare_load_methods</code>作用是为load方法做准备，从代码中可以看出<code>Class</code>的<code>load</code>方法是优先于<code>Category</code>。其中在收集<code>Class</code>的<code>load</code>方法中，因为需要对<code>Class</code>关系树的根节点逐层遍历运行，在<code>schedule_class_load</code>方法中使用深层递归的方式递归到根节点，优先进行收集。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 用来递归检查Class是否有load方法，包括父类</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</div><div class="line">    <span class="comment">// 查看 RW_REALIZED 是否被标记</span></div><div class="line">    assert(cls-&gt;isRealized());</div><div class="line">    <span class="comment">// 查看 RW_LOADED 是否被标记</span></div><div class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果有父类 递归到深层运行</span></div><div class="line">    schedule_class_load(cls-&gt;superclass);</div><div class="line">    </div><div class="line">    <span class="comment">// 将有load方法的Class添加到一个全局列表中</span></div><div class="line">    add_class_to_loadable_list(cls);</div><div class="line">    <span class="comment">// 标记 RW_LOADED 符号</span></div><div class="line">    cls-&gt;setInfo(RW_LOADED); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>schedule_class_load</code>中，<code>Class</code>的读取方式是<code>cls</code>指针方式，其中有很多内存符号位用来记录状态。<code>isRealized()</code>查看的就是<code>RW_REALIZED</code>位，改位记录的是当前<code>Class</code>是否初始化一个类的指标。而之后查看的<code>RW_LOADED</code>是记录当前类的<code>load</code>方法是否已经被检测。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 检测Class是否有load函数 并将其添加到全局静态数组中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//标记方法</span></div><div class="line">    IMP method;</div><div class="line"></div><div class="line">    loadMethodLock.assertLocked();</div><div class="line">    <span class="comment">//获取类的load方法的IMP</span></div><div class="line">    method = cls-&gt;getLoadMethod();</div><div class="line">    <span class="comment">//如果没有load方法 返回</span></div><div class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</div><div class="line">        <span class="number">_</span>objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </div><div class="line">                     cls-&gt;nameForLogging());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断数组是否已满</span></div><div class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</div><div class="line">        <span class="comment">// 动态扩容 为线性表释放空间</span></div><div class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</div><div class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</div><div class="line">            <span class="built_in">realloc</span>(loadable_classes,</div><div class="line">                              loadable_classes_allocated *</div><div class="line">                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> loadable_class));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将cls method 存储到loadable_classes 指针中</span></div><div class="line">    loadable_classes[loadable_classes_used].cls = cls;</div><div class="line">    loadable_classes[loadable_classes_used].method = method;</div><div class="line">    <span class="comment">// 索引++</span></div><div class="line">    loadable_classes_used++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在存储静态表的方法中，方法对象会以指针的方式作为传递参数，然后用名为<code>loadable_classes</code>的静态类型数组对即将运行的<code>load</code>方法进行存储，以及方法所属的<code>Class</code>。其下标索引<code>loadable_classes_used</code>为（从0开始）的全局量，并在每次录入方法后自加操作实现索引的偏移。</p>
<p>赛选过<code>Class</code>以后，接下来会继续赛选<code>Category</code>。通过<code>_getObjc2NonlazyCategoryList</code>获取到<code>image</code>中所有的<code>Category</code>后，遍历执行<code>add_category_to_loadable_list</code>方法，将有<code>load</code>方法的<code>Category</code>添加到全局<code>loadable_categories</code>静态类型的数组中。<code>add_category_to_loadable_list</code>方法的实现原理与<code>add_class_to_loadable_list</code>几乎一样。这里不再细说。</p>
<p>由此可以看出，在<code>prepare_load_methods</code>方法中，<code>runtime</code>对<code>Class</code>和<code>Category</code>进行了筛选工作，并且将即将执行的<code>load</code>方法以指针的形式组织成一个线性表结构，为之后执行操作打下基础。</p>
<h3 id="通过函数指针让load方法跑起来"><a href="#通过函数指针让load方法跑起来" class="headerlink" title="通过函数指针让load方法跑起来"></a>通过函数指针让load方法跑起来</h3><p>通过加载镜像(image)、缓存类和分类列表后，开始执行<code>call_load_methods</code>方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//是否已经录入</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</div><div class="line">    <span class="comment">//是否有关联的Category</span></div><div class="line">    <span class="keyword">bool</span> more_categories;</div><div class="line"></div><div class="line">    loadMethodLock.assertLocked();</div><div class="line"></div><div class="line">    <span class="comment">// 由于loading是全局静态布尔值，如果已经录入方法则直接退出</span></div><div class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</div><div class="line">    <span class="comment">//修改全局标记 开始录入</span></div><div class="line">    loading = YES;</div><div class="line"></div><div class="line">    <span class="comment">//声明一个autoreleasePool 对象</span></div><div class="line">    <span class="comment">// 使用push操作其目的是为了创建一个新的 autoreleasePool 对象</span></div><div class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="comment">// 检查全局 load 方法数组的长度 并调用load 方法 知道调用完毕</span></div><div class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</div><div class="line">            call_class_loads();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 调用 Category 中的load 方法</span></div><div class="line">        more_categories = call_category_loads();</div><div class="line"></div><div class="line">        <span class="comment">// 只要 Class 或者 Category 其中一个有load 都会继续调用</span></div><div class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</div><div class="line">    <span class="comment">// 将创建的 autoreleasePool 对象释放掉</span></div><div class="line">    objc_autoreleasePoolPop(pool);</div><div class="line">    <span class="comment">// 修改全局标记 录入完毕</span></div><div class="line">    loading = NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实<code>call_load_methods</code>由以上代码可知，仅是运行<code>load</code>方法的入口，其中最重要的方法<code>call_class_loads</code>和<code>call_category_loads</code>会分别从<code>loadable_classes</code>和<code>loadable_categories</code>列表中找出对应的<code>Class</code>和<code>Category</code>，并分别使用<code>selector(load)</code>的实现并加载。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//声明下标</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    </div><div class="line">    <span class="comment">// 分离加载的 Class列表</span></div><div class="line">    <span class="keyword">struct</span> loadable_class *classes = loadable_classes;</div><div class="line">    <span class="comment">// 调用标记</span></div><div class="line">    <span class="keyword">int</span> used = loadable_classes_used;</div><div class="line">    <span class="comment">//重置之前的列表 标记</span></div><div class="line">    loadable_classes = nil;</div><div class="line">    loadable_classes_allocated = <span class="number">0</span>;</div><div class="line">    loadable_classes_used = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 调用列表中的Class 类的load方法</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</div><div class="line">        <span class="comment">//获取 Class指针</span></div><div class="line">        Class cls = classes[i].cls;</div><div class="line">        <span class="comment">// 获取load 方法</span></div><div class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</div><div class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </div><div class="line"></div><div class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</div><div class="line">            <span class="number">_</span>objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//方法调用</span></div><div class="line">        (*load_method)(cls, SEL_load);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 释放classes列表</span></div><div class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>(*load_method)(cls, SEL_load)</code>通过这一句就可以调用<code>load</code>方法。这是一个函数指针。其中<code>load_method_t</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">load_method_t</span>)</span><span class="params">(id, SEL)</span></span>;</div></pre></td></tr></table></figure>
<p>可以看到，我们将<code>Class</code>和<code>SEL</code>传递过去，至此完成<code>load</code>方法的动态调用。<code>call_category_loads</code>和<code>call_class_loads</code>的调用机制类似，只是后续会继续做很多内存操作，有兴趣的可以看看。</p>
<p>至此完成了<code>load</code>方法的动态调用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你过去可能会听说，对于<code>load</code>方法的调用顺序有两条规则：</p>
<ol>
<li>父类先于子类调用</li>
<li>类先于分类调用</li>
</ol>
<p>通过我们的整体分析，你会发现这种现象是很有原因的。在<code>schedule_class_load</code>递归方法中，会保证父类先于子类加入到<code>loadable_classes</code>数组红，从而确保类的调用顺序的正确性。</p>
<p>而在<code>call_load_methods</code>方法中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</div><div class="line">        call_class_loads();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    more_categories = call_category_loads();</div><div class="line"></div><div class="line">&#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</div></pre></td></tr></table></figure>
<p>会一次性将所有类的<code>load</code>方法调用完毕，之后才会调用分类的<code>load</code>放法。至此，整个<code>load</code>调用流程图如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load5.png?raw=true"><br></div>

<p><code>load</code>可以说是我们日常开发中接触到调用时间最靠前的方法，这就成为了我们玩黑魔法的绝佳时机。</p>
<p>但是由于<code>load</code>方法的运行时间过早，所以这里可能不是一个理想的环境，因为某些类可能需要在在其它类之前加载，但是这是我们无法保证的。不过在这个时间点，所有的<code>framework</code>都已经加载到了运行时中，所以调用<code>framework</code>中的方法都是安全的。</p>
<h3 id="扩展initialize"><a href="#扩展initialize" class="headerlink" title="扩展initialize"></a>扩展initialize</h3><p>说到<code>load</code>方法就不得不提<code>initialize</code>方法，我们都知道<code>load</code>会在程序启动的时候加载，而<code>initialize</code>方法会在类或者类的子类收到第一条消息之前被调用。现在，我们已经非常清楚<code>load</code>方法的调用原理，至于<code>initialize</code>呢？我们现在继续分析。</p>
<p>紧接着我们刚才的例子，新建类<code>GGSuperObject</code>，并实现<code>initialize</code>方法，让<code>GGObject</code>继承<code>GGSuperObject</code>，接着实现<code>GGObject</code>和<code>GGObject (GG)</code>的<code>initialize</code>方法，在<code>main</code>中，我们创建<code>GGObject</code>的实例，运行程序如下：</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load6.png?raw=true"><br></div>

<p>运行结果很符合我们的预期，父类会优先调用，分类会覆盖本类的<code>initialize</code>，下面我们通过代码来看具体的实现原理。当我们向某个类发送消息时，<code>runtime</code>会调用<code>lookUpImpOrForward</code>这个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></div><div class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</div><div class="line">&#123;</div><div class="line">    IMP imp = nil;</div><div class="line">    <span class="keyword">bool</span> triedResolver = NO;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">	 <span class="comment">// 类没有初始化 对类进行初始化</span></div><div class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class="line">        runtimeLock.unlockRead();</div><div class="line">        <span class="comment">//初始化</span></div><div class="line">        <span class="number">_</span>class_initialize (<span class="number">_</span>class_getNonMetaClass(cls, inst));</div><div class="line">        runtimeLock.read();</div><div class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></div><div class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></div><div class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></div><div class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">return</span> imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看到当类没有初始化时，会调用<code>_class_initialize</code>对类进行初始化，<code>_class_getNonMetaClass</code>这里主要是对类进行一些转换，我们这里不用过多考虑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="number">_</span>class_initialize(Class cls)</div><div class="line">&#123;</div><div class="line">    assert(!cls-&gt;isMetaClass());</div><div class="line"></div><div class="line">    Class supercls;</div><div class="line">    <span class="keyword">bool</span> reallyInitialize = NO;</div><div class="line"></div><div class="line">    <span class="comment">// 先找到父类</span></div><div class="line">    supercls = cls-&gt;superclass;</div><div class="line">    <span class="comment">// 如果父类没有初始化 对父类进行初始化</span></div><div class="line">    <span class="comment">// 我们发现 又有递归调用 从这里我们可以发现，父类的initialize比子类先调用</span></div><div class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</div><div class="line">        <span class="number">_</span>class_initialize(supercls);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (reallyInitialize) &#123;</div><div class="line">        ...</div><div class="line">        @<span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 发送调用类的initialize的消息</span></div><div class="line">            callInitialize(cls);</div><div class="line"></div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，显示对入参的父类进行递归调用，以确保父类优先于子类初始化，还有一个关键的地方，我们来看<code>callInitialize</code>发送消息的具体实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></div><div class="line">&#123;</div><div class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</div><div class="line">    <span class="keyword">asm</span>(<span class="string">""</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有没有很熟悉，<code>runtime</code>使用了发送消息<code>objc_msgSend</code>的方式对<code>initialize</code>方法进行调用，这样，<code>initialize</code>方法的调用就是与普通方法的调用是一致的，都是走的发送消息的流程，那么我们再回到<code>lookUpImpOrForward</code>方法中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></div><div class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</div><div class="line">&#123;</div><div class="line">    IMP imp = nil;</div><div class="line">    <span class="keyword">bool</span> triedResolver = NO;</div><div class="line"></div><div class="line">    runtimeLock.assertUnlocked();</div><div class="line"></div><div class="line">    <span class="comment">// 这里会先从缓存中查找 imp</span></div><div class="line">    <span class="keyword">if</span> (cache) &#123;</div><div class="line">        imp = cache_getImp(cls, sel);</div><div class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</div><div class="line">    &#125;</div><div class="line">    runtimeLock.read();</div><div class="line">    <span class="comment">// 注册类</span></div><div class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</div><div class="line">        runtimeLock.write();</div><div class="line">		</div><div class="line">        realizeClass(cls);</div><div class="line"></div><div class="line">        runtimeLock.unlockWrite();</div><div class="line">        runtimeLock.read();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 初始化类 </span></div><div class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</div><div class="line">        runtimeLock.unlockRead();</div><div class="line">        <span class="number">_</span>class_initialize (<span class="number">_</span>class_getNonMetaClass(cls, inst));</div><div class="line">        runtimeLock.read();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line"> retry:    </div><div class="line">    runtimeLock.assertReading();</div><div class="line"></div><div class="line">    <span class="comment">// 先从缓存中查找 imp （本例中的imp  就是initialize）</span></div><div class="line">    imp = cache_getImp(cls, sel);</div><div class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</div><div class="line"></div><div class="line">    <span class="comment">// 缓存中没有 去方法列表中找 imp 的实现</span></div><div class="line">    &#123;</div><div class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</div><div class="line">        <span class="keyword">if</span> (meth) &#123;</div><div class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</div><div class="line">            <span class="comment">//找到了就调用</span></div><div class="line">            imp = meth-&gt;imp;</div><div class="line">            <span class="keyword">goto</span> done;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 去父类的缓存列表和方法列表中找imp 的实现</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">unsigned</span> attempts = unreasonableClassCount();</div><div class="line">        <span class="comment">//循环遍历父类</span></div><div class="line">        <span class="keyword">for</span> (Class curClass = cls;</div><div class="line">             curClass != nil;</div><div class="line">             curClass = curClass-&gt;superclass)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</div><div class="line">                <span class="number">_</span>objc_fatal(<span class="string">"Memory corruption in class list."</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 去缓存中寻找</span></div><div class="line">            imp = cache_getImp(curClass, sel);</div><div class="line">            <span class="keyword">if</span> (imp) &#123;</div><div class="line">                <span class="keyword">if</span> (imp != (IMP)<span class="number">_</span>objc_msgForward_impcache) &#123;</div><div class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</div><div class="line">                    <span class="keyword">goto</span> done;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//去方法列表中找</span></div><div class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</div><div class="line">            <span class="keyword">if</span> (meth) &#123;</div><div class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</div><div class="line">                imp = meth-&gt;imp;</div><div class="line">                <span class="keyword">goto</span> done;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 无论是类 或者父类 都没有找到 接下来走消息转发机制</span></div><div class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</div><div class="line">        runtimeLock.unlockRead();</div><div class="line">        <span class="number">_</span>class_resolveMethod(cls, sel, inst);</div><div class="line">        runtimeLock.read();</div><div class="line">        </div><div class="line">        triedResolver = YES;</div><div class="line">        <span class="keyword">goto</span> retry;</div><div class="line">    &#125;</div><div class="line">    imp = (IMP)<span class="number">_</span>objc_msgForward_impcache;</div><div class="line">    cache_fill(cls, sel, imp, inst);</div><div class="line"></div><div class="line"> done:</div><div class="line">    runtimeLock.unlockRead();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，整个调用流程我们已经很清晰了，其实<code>initialize</code>走的就是完整的一个消息发送流程。</p>
<p>当我们第一次调用某个类的方法时，首先会递归遍历此类的父类，给父类发送<code>initialize</code>消息。接着又回调消息发送机制上，先查类的缓存，之后查类的方法列表，然后沿着继承链查父类的缓存，之后查父类的方法，如果都没有查到IMP，则走消息转发流程。至此，我们也明白为何子类会覆盖父类的方法，其实都是<code>runtime</code>的作用。</p>
<p>可能你还有个疑惑，为什么分类的<code>initialize</code>方法会覆盖本来的<code>initialize</code>方法呢？通过下面一段代码你会发现端倪：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">Method* methodList_f = class_copyMethodList(object_getClass([GGObject <span class="keyword">class</span>]),&amp;count_f);</div><div class="line">    </div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count_f;i++) &#123;</div><div class="line">    Method temp_f = methodList_f[i];</div><div class="line">    <span class="comment">//方法名字符串</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name_s =sel_getName(method_getName(temp_f));</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"方法名：%@"</span>,[<span class="built_in">NSString</span> stringWithUTF8String:name_s]);</div><div class="line">&#125;</div><div class="line">free(methodList_f);</div></pre></td></tr></table></figure>
<p>你会发现打印了两个<code>initialize</code>，其实这是因为类先于分类加载，在加载分类的时候，会将分类的方法放在类的方法的前面，所以类的方法列表中有两个<code>initialize</code>方法，并不是分类中的方法覆盖了本类中的方法，只是<code>runtime</code>在遍历方法列表的时候，只要找到一个就会返回，<code>runtime</code>不知道后面还有一个<code>initialize</code>方法。想必你现在知道类和分类的调用关系了吧。</p>
<div align="center"><br><img src="https://github.com/guiyongdong/Resource/blob/master/hexoImage/oc/load6.png?raw=true"><br></div>

<p>好了，至此<code>load</code>方法和<code>initialize</code>方法咱们已经说完。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md" target="_blank" rel="external">你真的了解 load 方法么？</a></p>

            
        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Runtime/">Runtime</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/06/26/iOS多线程之各种锁的简单介绍/" data-tooltip="iOS多线程之各种锁的简单介绍">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://v.t.sina.com.cn/share/share.php?url=http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/&amp;title=load 方法全程跟踪">
                <i class="fa fa-weibo"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/">
                <i class="fa fa-qq"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default"  href="javascript:show();" >
                <i class="fa fa-wechat (alias)"></i>
            </a>
        </li>
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>
<div id="jiathis_weixin_modal" style="z-index:1000;display:none; background-clip: padding-box;background-color: #FFFFFF;border: 1px solid rgba(0, 0, 0, 0.3);  border-radius: 6px 6px 6px 6px;  box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); left: 50%; margin: -200px 0 0 -200px;overflow: hidden; position: fixed; top: 50%; width:360px;height:370px; overflow:hidden;" class="jiathis_weixin_modal"><div class="jiathis_modal_header" id="jiathis_modal_header" style="border-bottom: 1px solid #EEEEEE; padding: 9px 15px;"><a style="text-decoration:none;  margin-top: 2px; color: #000000; float: right;  font-size: 20px;  font-weight: bold; cursor:pointer;line-height: 20px; opacity: 0.2; text-shadow: 0 1px 0 #FFFFFF;" class="jiathis_weixin_close" id="jiathis_weixin_close" href="javascript:hidden();" target="_self">×</a><h3 id="jiathis_weixin_h3" style=" line-height: 30px; margin: 0; font-weight:normal; font-family:" 微软雅黑";"="">分享到微信朋友圈</h3></div><div class="jiathis_modal_body" id="jiathis_modal_body" style="text-align:center;height:251px;"><p id="jiathis_webchat"><img alt="二维码加载失败..." style="margin-top: 15px;" src="http://s.jiathis.com/qrcode.php?url=http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/" height="220" width="220"></p></div><div class="jiathis_modal_footer" id="jiathis_modal_footer" style="border-radius: 0 0 6px 6px; border-top: 1px solid #DDDDDD; box-shadow: 0 1px 0 #FFFFFF inset; height:100%;padding:0 10px;padding-top:11px;text-align: right; font-size:12px;"><div id="jiathis_weixin_tip" style="text-align:left;margin:0; padding:0;font-size:12px;background-color: #FFFFFF;">打开微信，点击底部的“发现”，使用 “扫一扫” 即可将网页分享到我的朋友圈。</div></div></div>

<script charset="utf-8">
    function show(){
        $("#jiathis_weixin_modal").css("display", "block")
    }
    function hidden(){
        $("#jiathis_weixin_modal").css("display", "none")
    } 
</script>







        
            
                
<div class="duoshuo">
<div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script>
var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: "3b1a42e3f91145d197b9e8b6e2f2a144",
  target: "cloud-tie-wrapper"
};
var yunManualLoad = true;
Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>
</div>



            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2017 贵永冬. All Rights Reserved.
    </span>
</footer>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2017/06/26/iOS多线程之各种锁的简单介绍/" data-tooltip="iOS多线程之各种锁的简单介绍">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://v.t.sina.com.cn/share/share.php?url=http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/&amp;title=load 方法全程跟踪">
                <i class="fa fa-weibo"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/">
                <i class="fa fa-qq"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default"  href="javascript:show();" >
                <i class="fa fa-wechat (alias)"></i>
            </a>
        </li>
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>
<div id="jiathis_weixin_modal" style="z-index:1000;display:none; background-clip: padding-box;background-color: #FFFFFF;border: 1px solid rgba(0, 0, 0, 0.3);  border-radius: 6px 6px 6px 6px;  box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); left: 50%; margin: -200px 0 0 -200px;overflow: hidden; position: fixed; top: 50%; width:360px;height:370px; overflow:hidden;" class="jiathis_weixin_modal"><div class="jiathis_modal_header" id="jiathis_modal_header" style="border-bottom: 1px solid #EEEEEE; padding: 9px 15px;"><a style="text-decoration:none;  margin-top: 2px; color: #000000; float: right;  font-size: 20px;  font-weight: bold; cursor:pointer;line-height: 20px; opacity: 0.2; text-shadow: 0 1px 0 #FFFFFF;" class="jiathis_weixin_close" id="jiathis_weixin_close" href="javascript:hidden();" target="_self">×</a><h3 id="jiathis_weixin_h3" style=" line-height: 30px; margin: 0; font-weight:normal; font-family:" 微软雅黑";"="">分享到微信朋友圈</h3></div><div class="jiathis_modal_body" id="jiathis_modal_body" style="text-align:center;height:251px;"><p id="jiathis_webchat"><img alt="二维码加载失败..." style="margin-top: 15px;" src="http://s.jiathis.com/qrcode.php?url=http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/" height="220" width="220"></p></div><div class="jiathis_modal_footer" id="jiathis_modal_footer" style="border-radius: 0 0 6px 6px; border-top: 1px solid #DDDDDD; box-shadow: 0 1px 0 #FFFFFF inset; height:100%;padding:0 10px;padding-top:11px;text-align: right; font-size:12px;"><div id="jiathis_weixin_tip" style="text-align:left;margin:0; padding:0;font-size:12px;background-color: #FFFFFF;">打开微信，点击底部的“发现”，使用 “扫一扫” 即可将网页分享到我的朋友圈。</div></div></div>

<script charset="utf-8">
    function show(){
        $("#jiathis_weixin_modal").css("display", "block")
    }
    function hidden(){
        $("#jiathis_weixin_modal").css("display", "none")
    } 
</script>







                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <ul class="share-options">
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/">
                <i class="fa fa-weibo"></i><span>微博</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/">
                <i class="fa fa-qq"></i><span>QQ</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn"  href="javascript:show();" >
                <i class="fa fa-wechat (alias)"></i><span>微信</span>
            </a>
        </li>
    </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>



<div id="jiathis_weixin_modal" style="display:none; background-clip: padding-box;background-color: #FFFFFF;border: 1px solid rgba(0, 0, 0, 0.3);  border-radius: 6px 6px 6px 6px;  box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); left: 50%; margin: -200px 0 0 -200px;overflow: hidden; position: fixed; top: 50%; width:360px;height:370px; overflow:hidden;" class="jiathis_weixin_modal"><div class="jiathis_modal_header" id="jiathis_modal_header" style="border-bottom: 1px solid #EEEEEE; padding: 9px 15px;"><a style="text-decoration:none;  margin-top: 2px; color: #000000; float: right;  font-size: 20px;  font-weight: bold; cursor:pointer;line-height: 20px; opacity: 0.2; text-shadow: 0 1px 0 #FFFFFF;" class="jiathis_weixin_close" id="jiathis_weixin_close" href="javascript:hidden();" target="_self">×</a><h3 id="jiathis_weixin_h3" style=" line-height: 30px; margin: 0; font-weight:normal; font-family:" 微软雅黑";"="">分享到微信朋友圈</h3></div><div class="jiathis_modal_body" id="jiathis_modal_body" style="text-align:center;height:251px;"><p id="jiathis_webchat"><img alt="二维码加载失败..." style="margin-top: 15px;" src="http://s.jiathis.com/qrcode.php?url=http://www.guiyongdong.com/2017/07/14/load-方法全程跟踪/" height="220" width="220"></p></div><div class="jiathis_modal_footer" id="jiathis_modal_footer" style="border-radius: 0 0 6px 6px; border-top: 1px solid #DDDDDD; box-shadow: 0 1px 0 #FFFFFF inset; height:100%;padding:0 10px;padding-top:11px;text-align: right; font-size:12px;"><div id="jiathis_weixin_tip" style="text-align:left;margin:0; padding:0;font-size:12px;background-color: #FFFFFF;">打开微信，点击底部的“发现”，使用 “扫一扫” 即可将网页分享到我的朋友圈。</div></div></div>

<script charset="utf-8">
    function show(){
        $("#jiathis_weixin_modal").css("display", "block")
    }
    function hidden(){
        $("#jiathis_weixin_modal").css("display", "none")
    } 
</script>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/header.jpg" alt="作者的图片"/>
        
            <h4 id="about-card-name">贵永冬</h4>
        
            <div id="about-card-bio"><p>iOS开发者<br> 会一点RN和android,  十足的海贼迷</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>郑州市时空隧道信息技术有限公司</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                河南 郑州
            </div>
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    autofocus="autofocus"/>
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/08/11/初识ReactiveCocoa/">
                            <h3 class="media-heading">初识ReactiveCocoa</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年8月11日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>(简称为RAC), 是由Github开源的一个应用于iOS和OS开发的新框架, RAC具有函数式编程和响应式编程的特性, 通过这篇文章对RAC有一个简单的了解。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/08/12/深入ReactiveCocoa/">
                            <h3 class="media-heading">深入ReactiveCocoa</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年8月12日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>(简称为RAC),上一篇文章，我们简单的对RAC有个初步的了解，在开发中，我们实际用到的基本都是上一篇所介绍的知识，这篇文章我们对RAC有个深入的了解。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/06/ReactiveCocoa和RXSwift速查表/">
                            <h3 class="media-heading">ReactiveCocoa和RXSwift速查表</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>在接触了RAC以后,对RAC有了一个基本的了解，这里整理了一下RAC脑图，方便日后查看。ps(<a href="https://github.com/aiqiuqiu/FRPCheatSheeta">转载</a>)</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/06/关于RAC的一些资料/">
                            <h3 class="media-heading">关于RAC的一些资料</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>看了这么多RAC资料，在这里我整理了一下，以备学习。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/08/RunLoop总结/">
                            <h3 class="media-heading">RunLoop总结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月8日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>最近研究了一下RunLoop，在这里对RunLoop做一个总结，主要是对<code>&lt;CoreFoundation/CFRunLoop.h&gt;</code>的头文件函数总结。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/13/聊一聊GCD的那些事/">
                            <h3 class="media-heading">聊一聊GCD的那些事</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月13日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>GCD是iOS开发中经常使用到的技术，最近工作比较悠闲，有时间对GCD做一个全面的学习，这篇文章将对GCD做一个全面的解析。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/18/聊一聊NSOperation的那些事/">
                            <h3 class="media-heading">聊一聊NSOperation的那些事</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月18日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>在iOS开发中，多线程技术用到最多的就是GCD和NSOperation，上一篇文章已经对GCD有了全面的了解，这篇文章简单的聊一聊NSOperation。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/21/iOS动画篇-transfrom/">
                            <h3 class="media-heading">iOS动画篇之UIView动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月21日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/22/iOS动画篇之CoreAnimation动画/">
                            <h3 class="media-heading">iOS动画篇之CoreAnimation动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>App如果想被大众喜欢，漂亮的UI和精美的动画都是必不可少的，苹果虽然为UIView提供了一些常用动画，但是大部分看起来比较不错的效果都是通过操作Layer层实现的，因此了解核心动画是必要的.CoreAnimation是直接作用在CALayer上的(并非UIView上)非常强大的跨Mac OS X和iOS平台的动画处理API，Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。<br></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://www.guiyongdong.com/2016/09/22/iOS动画之CATransition动画/">
                            <h3 class="media-heading">iOS动画之CATransition动画</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2016年9月22日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>今天主要用到的动画类是CALayer下的CATransition至于各种动画类中如何继承的在这也不做赘述，网上的资料是一抓一大把。好废话少说切入今天的正题。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 52 篇文章
            </p>
        </div>
    </div>
</div>
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-rt08quwts7iav5x0cfd2ym0gb5qkd1lvrsmwrakxtkhefmaaes4ywkmnjnwf.min.js"></script>
<script src="/assets/js/prism.js"></script>
<!--SCRIPTS END-->

    
        <script type="text/javascript">
            var duoshuoQuery = {short_name:'guiyongdong'};
            (function() {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>
    



    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script>
    <script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
    <script>
        var algoliaClient = algoliasearch('DWKE0MOOLY', '141d50cf933ece6dd635747973c4fe00');
        var algoliaIndex = algoliaClient.initIndex('blog');
    </script>

    </body>
</html>
